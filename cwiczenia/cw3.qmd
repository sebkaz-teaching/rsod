# Zadania Ä†wiczenia 3

## ğŸ”— Rodzaje ZÅ‚Ä…czeÅ„ (JOIN) w SQL
ZÅ‚Ä…czenia sÅ‚uÅ¼Ä… do Å‚Ä…czenia wierszy z dwÃ³ch lub wiÄ™cej tabel na podstawie powiÄ…zanej kolumny (np. klucza obcego). RÃ³Å¼ne typy zÅ‚Ä…czeÅ„ decydujÄ… o tym, jak traktowane sÄ… wiersze, dla ktÃ³rych brakuje pasujÄ…cych danych w drugiej tabeli (np. pracownik bez dziaÅ‚u, lub dziaÅ‚ bez pracownika).

### INNER JOIN (ZÅ‚Ä…czenie WewnÄ™trzne)

Cel: Zwraca tylko te wiersze, ktÃ³re majÄ… pasujÄ…ce wartoÅ›ci w obu tabelach (przeciÄ™cie zbiorÃ³w).
DziaÅ‚anie: JeÅ›li wiersz z Tabeli A nie ma pasujÄ…cego wiersza w Tabeli B (lub odwrotnie), jest on pomijany.
Kiedy uÅ¼ywaÄ‡: Kiedy potrzebujesz danych, ktÃ³re sÄ… kompletne po obu stronach relacji.

PrzykÅ‚ad:
```sql
SELECT
    p.imie,
    p.nazwisko,
    d.nazwa_dzialu
FROM
    pracownicy p
INNER JOIN
    dzialy d ON p.id_dzialu = d.id_dzialu;

```

W Wyniku:

- PojawiÄ… siÄ™ wszyscy pracownicy, ktÃ³rzy majÄ… przypisany id_dzialu.
- Zostanie pominiÄ™ta Olga Lisiecka (pracownik bez dziaÅ‚u).
- Zostanie pominiÄ™ty dziaÅ‚ Badania i RozwÃ³j (dziaÅ‚ bez pracownikÃ³w).

### LEFT JOIN (ZÅ‚Ä…czenie Lewostronne)

Cel: Zwraca wszystkie wiersze z lewej tabeli (Tabela A) i pasujÄ…ce wiersze z prawej tabeli (Tabela B). JeÅ›li brak dopasowania, w kolumnach z Tabeli B pojawia siÄ™ wartoÅ›Ä‡ NULL.

DziaÅ‚anie: Tabela po lewej (pracownicy) jest priorytetowa.

Kiedy uÅ¼ywaÄ‡: Gdy chcesz zobaczyÄ‡ wszystkie rekordy z jednej strony relacji, nawet jeÅ›li nie majÄ… one powiÄ…zanych danych po drugiej stronie.

PrzykÅ‚ad:
```sql
SELECT
    p.imie,
    p.nazwisko,
    d.nazwa_dzialu
FROM
    pracownicy p
LEFT JOIN
    dzialy d ON p.id_dzialu = d.id_dzialu;
```
W Wyniku:

- PojawiÄ… siÄ™ wszyscy pracownicy, w tym Olga Lisiecka.
- Dla Olga Lisiecka kolumna nazwa_dzialu bÄ™dzie miaÅ‚a wartoÅ›Ä‡ NULL.
- DziaÅ‚ Badania i RozwÃ³j zostanie pominiÄ™ty, poniewaÅ¼ jest w prawej tabeli i nie ma pasujÄ…cego pracownika.


### RIGHT JOIN (ZÅ‚Ä…czenie Prawostronne)

Cel: Zwraca wszystkie wiersze z prawej tabeli (Tabela B) i pasujÄ…ce wiersze z lewej tabeli (Tabela A). JeÅ›li brak dopasowania, w kolumnach z Tabeli A pojawia siÄ™ wartoÅ›Ä‡ NULL.

DziaÅ‚anie: Tabela po prawej (dzialy) jest priorytetowa.

Kiedy uÅ¼ywaÄ‡: Analogicznie do LEFT JOIN, ale priorytetem jest zwrÃ³cenie wszystkich rekordÃ³w z drugiej strony relacji (np. wszystkich dziaÅ‚Ã³w).

PrzykÅ‚ad:
```sql
SELECT
    p.imie,
    p.nazwisko,
    d.nazwa_dzialu
FROM
    pracownicy p
RIGHT JOIN
    dzialy d ON p.id_dzialu = d.id_dzialu;

```
W Wyniku:

- PojawiÄ… siÄ™ wszystkie dziaÅ‚y, w tym Badania i RozwÃ³j.
- Dla dziaÅ‚u Badania i RozwÃ³j kolumny imie i nazwisko bÄ™dÄ… miaÅ‚y wartoÅ›Ä‡ NULL.
- Pracownik Olga Lisiecka zostanie pominiÄ™ty, poniewaÅ¼ nie ma pasujÄ…cego dziaÅ‚u.

### FULL OUTER JOIN (PeÅ‚ne ZÅ‚Ä…czenie ZewnÄ™trzne)

Cel: Zwraca wiersze, jeÅ›li istnieje dopasowanie w ktÃ³rejkolwiek z tabel. Jest to suma LEFT i RIGHT JOIN.

DziaÅ‚anie: Zwraca wszystkie wiersze z obu tabel, wypeÅ‚niajÄ…c NULL tam, gdzie brakuje dopasowania.

Kiedy uÅ¼ywaÄ‡: Gdy chcesz zobaczyÄ‡ caÅ‚Ä… przestrzeÅ„ danych: wszystkie rekordy z Tabeli A i wszystkie rekordy z Tabeli B, nawet te niepowiÄ…zane.

PrzykÅ‚ad:
```sql
SELECT
    p.imie,
    p.nazwisko,
    d.nazwa_dzialu
FROM
    pracownicy p
FULL OUTER JOIN
    dzialy d ON p.id_dzialu = d.id_dzialu;
```
W Wyniku:

- PojawiÄ… siÄ™ wszyscy pracownicy (w tym Olga Lisiecka z NULL dla dziaÅ‚u).
- PojawiÄ… siÄ™ wszystkie dziaÅ‚y (w tym Badania i RozwÃ³j z NULL dla pracownika).



## âŒ NajczÄ™Å›ciej PopeÅ‚niane BÅ‚Ä™dy w ZÅ‚Ä…czeniach ObciÄ…Å¼ajÄ…ce BazÄ™ Danych

### BÅ‚Ä…d Kartesian Product (Iloczyn KartezjaÅ„ski)

Jest to najbardziej krytyczny bÅ‚Ä…d wydajnoÅ›ciowy. WystÄ™puje, gdy zÅ‚Ä…czamy dwie tabele bez zdefiniowania klauzuli ON (warunku zÅ‚Ä…czenia).

Co siÄ™ dzieje: KaÅ¼dy wiersz z pierwszej tabeli Å‚Ä…czy siÄ™ z kaÅ¼dym wierszem z drugiej tabeli. JeÅ›li masz tabelÄ™ A (1000 wierszy) i tabelÄ™ B (1000 wierszy), wynikowy zbiÃ³r danych bÄ™dzie miaÅ‚ 1000Ã—1000=1,000,000 wierszy.

ObciÄ…Å¼enie bazy: Enormana iloÅ›Ä‡ pamiÄ™ci RAM i czasu procesora jest zuÅ¼ywana na generowanie i przesyÅ‚anie tego niepotrzebnego, gigantycznego zbioru danych.

Jak uniknÄ…Ä‡: Zawsze uÅ¼ywaj klauzuli ON (lub WHERE w starszym stylu zÅ‚Ä…czeÅ„, choÄ‡ jest to niezalecane) do okreÅ›lenia relacji miÄ™dzy tabelami.

### Brak IndeksÃ³w na Kolumnach ZÅ‚Ä…czenia

Silnik bazy danych uÅ¼ywa indeksÃ³w, aby szybko znaleÅºÄ‡ pasujÄ…ce wiersze podczas wykonywania zÅ‚Ä…czeÅ„.

Co siÄ™ dzieje: JeÅ›li kolumny uÅ¼ywane w klauzuli ON (np. p.id_dzialu = d.id_dzialu) nie sÄ… indeksowane (zwykle klucze gÅ‚Ã³wne i obce sÄ… indeksowane domyÅ›lnie, ale naleÅ¼y to sprawdziÄ‡!), baza musi wykonaÄ‡ peÅ‚ne skanowanie tabeli (Full Table Scan) dla kaÅ¼dego wiersza z drugiej tabeli, co jest powolne.

ObciÄ…Å¼enie bazy: Drastycznie wydÅ‚uÅ¼a czas wykonywania zapytaÅ„, zwÅ‚aszcza na duÅ¼ych tabelach. Jest to najczÄ™stsza przyczyna wolnych zapytaÅ„.

Jak uniknÄ…Ä‡: Upewnij siÄ™, Å¼e kaÅ¼da kolumna uÅ¼ywana w klauzulach JOIN ON, WHERE i ORDER BY jest odpowiednio indeksowana.

### ZÅ‚Ä…czenie Zbyt Wielu Tabel Naraz

ChociaÅ¼ czasami konieczne jest zÅ‚Ä…czenie wielu tabel (np. 5 lub 6), zbyt duÅ¼a liczba zÅ‚Ä…czeÅ„ w jednym zapytaniu moÅ¼e skomplikowaÄ‡ pracÄ™ optymalizatora zapytaÅ„.

Co siÄ™ dzieje: Optymalizator PostgreSQL musi znaleÅºÄ‡ optymalnÄ… Å›cieÅ¼kÄ™ zÅ‚Ä…czenia (kolejnoÅ›Ä‡ wykonywania zÅ‚Ä…czeÅ„). Im wiÄ™cej tabel, tym wiÄ™cej moÅ¼liwych kombinacji i dÅ‚uÅ¼szy czas potrzebny na znalezienie najlepszego planu.

ObciÄ…Å¼enie bazy: Wzrost zÅ‚oÅ¼onoÅ›ci obliczeniowej (NP-trudny problem) dla samego optymalizatora, co moÅ¼e prowadziÄ‡ do uÅ¼ycia suboptymalnego planu.

Jak uniknÄ…Ä‡: UÅ¼ywaj widokÃ³w (VIEW) lub materializowanych widokÃ³w (MATERIALIZED VIEW) do hermetyzowania zÅ‚oÅ¼onych zÅ‚Ä…czeÅ„, albo rozwaÅ¼ dekompozycjÄ™ zapytania na mniejsze kroki (chociaÅ¼ PostgreSQL jest bardzo dobry w optymalizacji).

### ZÅ‚Ä…czenia na Kolumnach z Niezgodnymi Typami Danych

PostgreSQL jest elastyczny i czÄ™sto umoÅ¼liwia zÅ‚Ä…czenia na kolumnach, ktÃ³re majÄ… rÃ³Å¼ne, ale konwertowalne typy danych (np. TEXT i VARCHAR).

Co siÄ™ dzieje: Silnik bazy danych musi jawnie konwertowaÄ‡ typy danych dla kaÅ¼dego wiersza przed ich zÅ‚Ä…czeniem. Ta konwersja (rzutowanie, ang. casting) uniemoÅ¼liwia uÅ¼ycie indeksÃ³w.

ObciÄ…Å¼enie bazy: KoniecznoÅ›Ä‡ wykonania operacji konwersji + niemoÅ¼noÅ›Ä‡ wykorzystania indeksÃ³w = powolne zÅ‚Ä…czenie.

Jak uniknÄ…Ä‡: Upewnij siÄ™, Å¼e kolumny uÅ¼ywane w klauzuli ON majÄ… identyczne typy danych (np. INTEGER z INTEGER).

### Filtracja Danych po ZÅ‚Ä…czeniu (Nieefektywne WHERE)

CzÄ™sto zdarza siÄ™, Å¼e deweloperzy zÅ‚Ä…czajÄ… duÅ¼e tabele, a dopiero potem filtrujÄ… dane w klauzuli WHERE.

Co siÄ™ dzieje: Baza danych najpierw generuje duÅ¼y, kosztowny zbiÃ³r wynikÃ³w zÅ‚Ä…czenia, a dopiero potem odrzuca niepotrzebne wiersze.

ObciÄ…Å¼enie bazy: Niepotrzebne zuÅ¼ycie zasobÃ³w na generowanie tymczasowego, nadmiarowego zbioru danych.

Jak uniknÄ…Ä‡: Filtruj tabele (uÅ¼ywaj WHERE) przed zÅ‚Ä…czeniem lub w momencie zÅ‚Ä…czenia (np. w klauzuli ON dla LEFT/RIGHT JOIN lub w podzapytaniu), aby zÅ‚Ä…czaÄ‡ mniejsze zbiory danych.

### Mylenie Klauzuli ON z WHERE w ZÅ‚Ä…czeniach ZewnÄ™trznych (LEFT/RIGHT)

To jest czÄ™sty bÅ‚Ä…d logiczny, ktÃ³ry ma implikacje wydajnoÅ›ciowe.

Co siÄ™ dzieje (BÅ‚Ä…d): Umieszczenie warunku filtrujÄ…cego kolumnÄ™ z prawej tabeli w klauzuli WHERE po LEFT JOIN zamienia to zÅ‚Ä…czenie na INNER JOIN (usuwa wiersze z wartoÅ›ciami NULL).

ObciÄ…Å¼enie bazy: ChociaÅ¼ bÅ‚Ä…d ten niekoniecznie obciÄ…Å¼a bazÄ™ bardziej niÅ¼ INNER JOIN, prowadzi do logicznie niepoprawnego zapytania. WaÅ¼ne jest, aby zrozumieÄ‡, Å¼e filtry na tabeli zewnÄ™trznej powinny iÅ›Ä‡ do ON (jeÅ›li majÄ… zachowaÄ‡ strukturÄ™ zewnÄ™trznÄ…) lub powinny byÄ‡ realizowane w podzapytaniu, aby wczeÅ›niej zredukowaÄ‡ rozmiar tabeli.

Jak uniknÄ…Ä‡: Zawsze weryfikuj, czy warunek filtrujÄ…cy w klauzuli WHERE nie wpÅ‚ywa nieumyÅ›lnie na dziaÅ‚anie zÅ‚Ä…czenia zewnÄ™trznego.


##  ğŸ“ Ä†wiczenia Podstawowe (SELECT, FROM, WHERE, DML)

1. WyÅ›wietl wszystkie dane z tabeli pracownicy.
2. "WyÅ›wietl tylko imie, nazwisko i pensja wszystkich pracownikÃ³w."
3. WyÅ›wietl wszystkie kolumny dla dziaÅ‚Ã³w z tabeli dzialy.
4. WyÅ›wietl nazwy projektÃ³w oraz ich typ z tabeli projekty.
5. "ZnajdÅº wszystkich pracownikÃ³w, ktÃ³rych pensja jest niÅ¼sza niÅ¼ 50000."
6. ZnajdÅº pracownika o nazwisku 'Kowalska'.
7. "ZnajdÅº wszystkie projekty, ktÃ³rych typ_projektu to 'Software'."
8. "Wstaw nowego pracownika: Jan Kowalski, Stanowisko: Tester, Pensja: 48000, DziaÅ‚: 1 (IT)."
9. Zaktualizuj pensjÄ™ pracownikowi o ID 1 (Anna Kowalska) o 5000 zÅ‚ (nowa pensja to 85000.00).
10. UsuÅ„ pracownika o imieniu 'Natalia' i nazwisku 'Kaczmarek' (ID: 9).

##  ğŸ” Logika i Sortowanie (AND, OR, NOT, IN, BETWEEN, ORDER BY)

11.  "ZnajdÅº pracownikÃ³w, ktÃ³rych pensja jest pomiÄ™dzy 50000 a 70000 (wÅ‚Ä…cznie)."
12.  "WyÅ›wietl pracownikÃ³w, ktÃ³rzy sÄ… 'Programistami' LUB pracujÄ… na 'Starszy Programista'."
13.  "WyÅ›wietl pracownikÃ³w, ktÃ³rzy sÄ… 'Programistami' I majÄ… pensjÄ™ wyÅ¼szÄ… niÅ¼ 65000."
14.  "WyÅ›wietl dziaÅ‚y, ktÃ³rych lokalizacja to 'Warszawa' LUB 'GdaÅ„sk'."
15.  "WyÅ›wietl dziaÅ‚y, ktÃ³re NIE znajdujÄ… siÄ™ w lokalizacji 'KrakÃ³w'."
16.  "WyÅ›wietl wszystkich pracownikÃ³w, posortowanych rosnÄ…co wedÅ‚ug nazwisko."
17.  "WyÅ›wietl wszystkich pracownikÃ³w, posortowanych malejÄ…co wedÅ‚ug pensja."
18.  "Posortuj pracownikÃ³w najpierw rosnÄ…co wedÅ‚ug id_dzialu, a nastÄ™pnie malejÄ…co wedÅ‚ug pensja."

##  ğŸ”¤ Wzorce i Unikatowe WartoÅ›ci (DISTINCT, LIKE)

19. WyÅ›wietl listÄ™ unikatowych stanowisk w firmie.
20. WyÅ›wietl unikatowe lokalizacje dziaÅ‚Ã³w.
21. "ZnajdÅº pracownikÃ³w, ktÃ³rych nazwisko zaczyna siÄ™ na literÄ™ 'L'."
22. "ZnajdÅº dziaÅ‚y, ktÃ³rych nazwa ma 'RozwÃ³j' w dowolnym miejscu.",
23. "ZnajdÅº pracownikÃ³w, ktÃ³rych trzecia litera w imie to 'm'."
24. "ZnajdÅº projekty, ktÃ³rych nazwa_projektu koÅ„czy siÄ™ na sÅ‚owo 'HR' lub '2024'.

## ğŸ“Š Agregacja i Grupowanie (GROUP BY, HAVING)


25. Oblicz Å›redniÄ… pensjÄ™ dla wszystkich pracownikÃ³w.,
26. Oblicz najwyÅ¼szÄ… i najniÅ¼szÄ… pensjÄ™ w firmie.,
27. Policz caÅ‚kowitÄ… liczbÄ™ pracownikÃ³w w firmie.,
28. Oblicz Å›redniÄ… pensjÄ™ dla kaÅ¼dego unikatowego stanowiska.,
29. "Policz, ilu pracownikÃ³w zatrudnionych jest w kaÅ¼dym id_dzialu.",
30. Oblicz sumÄ™ pensji (SUM) dla kaÅ¼dego dziaÅ‚u (z pogrupowaniem wedÅ‚ug id_dzialu).,
31. "Policz, ilu pracownikÃ³w ma pensjÄ™ powyÅ¼ej 60000, pogrupowane wedÅ‚ug stanowisko.",
32. Oblicz maksymalny czas_pracy_h dla kaÅ¼dego projektu (id_projektu).,
33. "WyÅ›wietl tylko te id_dzialu, w ktÃ³rych Å›rednia pensja jest wyÅ¼sza niÅ¼ 60000.",
34. "ZnajdÅº stanowiska, na ktÃ³rych pracuje wiÄ™cej niÅ¼ 1 osoba.",
35. "WyÅ›wietl id_projektu tylko te, dla ktÃ³rych caÅ‚kowity czas pracy (SUMA) przekracza 200 godzin."

# ğŸ”— ÅÄ…czenie Tabel (JOIN - 10 ZadaÅ„)

36. INNER JOIN (Standard),"WyÅ›wietl imie, nazwisko pracownika i nazwa_dzialu. PomiÅ„ pracownikÃ³w, ktÃ³rzy nie majÄ… dziaÅ‚u."
37. LEFT JOIN (Pracownicy),"WyÅ›wietl imie, nazwisko pracownika i nazwa_dzialu. UwzglÄ™dnij wszystkich pracownikÃ³w, nawet tych bez przypisanego dziaÅ‚u (np. Olga Lisiecka)."
38. RIGHT JOIN (DziaÅ‚y),"WyÅ›wietl nazwa_dzialu oraz imie, nazwisko pracownika. UwzglÄ™dnij wszystkie dziaÅ‚y, nawet te, ktÃ³re nie majÄ… pracownika (np. Badania i RozwÃ³j)."
39. FULL OUTER JOIN,"WyÅ›wietl imie, nazwisko oraz nazwa_dzialu. UwzglÄ™dnij WSZYSTKICH pracownikÃ³w i WSZYSTKIE dziaÅ‚y, niezaleÅ¼nie od powiÄ…zania."
40. JOIN z WHERE,"WyÅ›wietl imie i nazwisko wszystkich pracownikÃ³w, ktÃ³rzy pracujÄ… w dziale zlokalizowanym w 'KrakÃ³w'."
41. JOIN 3 Tabel (Lista ProjektÃ³w),"WyÅ›wietl imie, nazwisko pracownika oraz nazwa_projektu, w ktÃ³rym pracuje. PoÅ‚Ä…cz 3 tabele: pracownicy, przydzialy, projekty."
42. LEFT JOIN (Projekty),"WyÅ›wietl nazwa_projektu oraz imie i nazwisko przypisanych pracownikÃ³w. UwzglÄ™dnij wszystkie projekty, nawet jeÅ›li nikt do nich nie jest przypisany."
43. JOIN z ORDER BY,"WyÅ›wietl imie, nazwisko, pensja oraz nazwa_dzialu. Posortuj wynik malejÄ…co wedÅ‚ug pensji."
44. JOIN z AgregacjÄ… (4 Tabele),Oblicz caÅ‚kowitÄ… liczbÄ™ godzin (SUM(czas_pracy_h)) przepracowanÄ… w projektach dla kaÅ¼dego dziaÅ‚u. Wynik powinien zawieraÄ‡ nazwa_dzialu.
45. JOIN i DISTINCT,"WyÅ›wietl unikatowe nazwa_projektu, w ktÃ³rych pracujÄ… pracownicy z dziaÅ‚u 'IT'."