[
  {
    "objectID": "lectures/plan.html",
    "href": "lectures/plan.html",
    "title": "Relacyjne Systemy Organizacji Danych",
    "section": "",
    "text": "📙 WYKŁAD 3 – NORMALIZACJA I PROJEKTOWANIE BAZ DANYCH Temat: Jak uniknąć błędów w projektowaniu? Cele: nauczenie zasad normalizacji, zrozumienie zależności funkcjonalnych, wprowadzenie do diagramów ERD. Zakres treści: Problemy złego projektu: redundancja, anomalie aktualizacji, usuwania. Pojęcie zależności funkcjonalnych. Formy normalne (1NF–3NF, BCNF): przykłady i zastosowania. Diagramy ERD (Entity–Relationship Diagram): encje, atrybuty, relacje, kardynalności, identyfikatory. Proces projektowania bazy: analiza wymagań → model konceptualny → model logiczny → model fizyczny. Akcent praktyczny: ćwiczenie – model bazy danych dla systemu uczelnianego. Efekty uczenia się: potrafi projektować relacyjną bazę danych zgodnie z zasadami normalizacji. 📒 WYKŁAD 4 – TRANSAKCJE, WSPÓŁBIEŻNOŚĆ I WIDOKI Temat: Mechanizmy zapewniania spójności danych Cele: poznanie zasad transakcyjności, zrozumienie współbieżności i izolacji, wprowadzenie do widoków i ich zastosowań. Zakres treści: Pojęcie transakcji i właściwości ACID: atomicity, consistency, isolation, durability. Problemy współbieżności: utracone aktualizacje, odczyty brudnych danych, blokady. Poziomy izolacji transakcji. Widoki (Views): definicja, zalety (abstrakcja, bezpieczeństwo), przykłady CREATE VIEW, WITH CHECK OPTION. Przykład – transakcje w PostgreSQL (BEGIN/COMMIT/ROLLBACK). Akcent praktyczny: analiza równoczesnych transakcji na tej samej tabeli. Efekty uczenia się: rozumie zasady transakcyjności i umie zastosować widoki. 📕 WYKŁAD 5 – ADMINISTRACJA, BEZPIECZEŃSTWO I KOPIE ZAPASOWE Temat: Utrzymanie i ochrona baz danych Cele: poznanie zasad administrowania bazami danych, zrozumienie bezpieczeństwa i odporności systemów bazodanowych. Zakres treści: Role i uprawnienia użytkowników: GRANT, REVOKE, zarządzanie kontami. Bezpieczeństwo danych: szyfrowanie, kontrola dostępu, logowanie zdarzeń. Backup i odzyskiwanie: kopie pełne, przyrostowe, różnicowe, replikacja i wysokie dostępności (HA). Monitorowanie i optymalizacja: indeksy, analiza planów zapytań. Przegląd systemów bazodanowych: PostgreSQL, MySQL, SQLite, MS SQL, Oracle. Efekty uczenia się: zna metody ochrony i zarządzania bazami danych, potrafi wskazać strategie kopii zapasowych. 💡 PROJEKT ZALICZENIOWY (do realizacji na ćwiczeniach) Temat: Projekt i implementacja relacyjnej bazy danych wspierającej wybrany proces organizacyjny. Etapy projektu: Analiza problemu i identyfikacja wymagań. (np. system rezerwacji sal, ewidencja sprzętu, biblioteka, wypożyczalnia, rejestr studentów) Model konceptualny (ERD) i logiczny bazy danych. Implementacja bazy w wybranym systemie (np. PostgreSQL). Wypełnienie przykładowymi danymi, przygotowanie zapytań SQL. Demonstracja transakcji, widoków i podstawowych mechanizmów bezpieczeństwa. Efekty projektu: integracja wiedzy z zakresu modelowania, SQL i zarządzania, praktyczne umiejętności tworzenia bazy danych od podstaw, doświadczenie w pracy zespołowej i prezentacji wyników. 📈 POWIĄZANIE Z EFEKTAMI UCZENIA SIĘ Efekt uczenia się Odniesienie do wykładów / projektu Zna i rozumie algorytmy i metody w systemach BD Wykłady 2–5 Ma wiedzę z zakresu przetwarzania danych Wykład 1, 2 Zna standardy stosowane w BD Wykłady 2, 5 Potrafi przygotować prezentację i prowadzić dyskusję Projekt zespołowy Umie wykorzystać modele w realizacji projektów BD Wykład 3 + projekt Integruje wiedzę techniczną i pozatechniczną Projekt (analiza potrzeb użytkownika) Określa priorytety w realizacji zadań Projekt – planowanie etapów"
  },
  {
    "objectID": "lectures/wyklad3.html",
    "href": "lectures/wyklad3.html",
    "title": "Normalizacja i projektowanie baz danych",
    "section": "",
    "text": "Celem wykładu jest pokazanie, jak unikać błędów podczas projektowania relacyjnych baz danych poprzez stosowanie zasad normalizacji, zrozumienie zależności funkcjonalnych oraz wykorzystanie diagramów ERD (Entity–Relationship Diagram).",
    "crumbs": [
      "Książki",
      "Wykłady",
      "Normalizacja i projektowanie baz danych"
    ]
  },
  {
    "objectID": "lectures/wyklad3.html#temat-jak-uniknąć-błędów-w-projektowaniu",
    "href": "lectures/wyklad3.html#temat-jak-uniknąć-błędów-w-projektowaniu",
    "title": "Normalizacja i projektowanie baz danych",
    "section": "",
    "text": "Celem wykładu jest pokazanie, jak unikać błędów podczas projektowania relacyjnych baz danych poprzez stosowanie zasad normalizacji, zrozumienie zależności funkcjonalnych oraz wykorzystanie diagramów ERD (Entity–Relationship Diagram).",
    "crumbs": [
      "Książki",
      "Wykłady",
      "Normalizacja i projektowanie baz danych"
    ]
  },
  {
    "objectID": "lectures/wyklad3.html#cele-wykładu",
    "href": "lectures/wyklad3.html#cele-wykładu",
    "title": "Normalizacja i projektowanie baz danych",
    "section": "🧠 Cele wykładu",
    "text": "🧠 Cele wykładu\n\nnauczenie zasad normalizacji relacyjnych baz danych,\n\nzrozumienie pojęcia zależności funkcjonalnych,\n\nwprowadzenie do diagramów ERD jako narzędzia modelowania danych.",
    "crumbs": [
      "Książki",
      "Wykłady",
      "Normalizacja i projektowanie baz danych"
    ]
  },
  {
    "objectID": "lectures/wyklad3.html#zakres-treści",
    "href": "lectures/wyklad3.html#zakres-treści",
    "title": "Normalizacja i projektowanie baz danych",
    "section": "📋 Zakres treści",
    "text": "📋 Zakres treści\n\n1. Problemy złego projektu bazy danych\nZłe zaprojektowanie struktury bazy danych prowadzi do wielu problemów:\n\n🔹 Redundancja danych\nTo powielanie tych samych informacji w różnych miejscach bazy.\nPrzykład: jeśli w każdej tabeli z zamówieniami przechowujemy pełne dane klienta, to zmiana jego adresu wymaga aktualizacji wielu rekordów.\n\n\n🔹 Anomalie danych\nBłędy i niekonsekwencje wynikające z nadmiarowej struktury danych.\n\nAnomalia aktualizacji – zmiana jednej informacji wymaga wielu modyfikacji.\nNp. zmiana nazwiska wykładowcy w kilku wierszach tabeli.\nAnomalia wstawiania – brak możliwości dodania danych bez istnienia innych.\nNp. nie można dodać nowego kursu, dopóki nie zapisze się na niego student.\nAnomalia usuwania – usunięcie rekordu powoduje utratę innych informacji.\nNp. usunięcie ostatniego studenta z kursu powoduje utratę danych o samym kursie.\n\n👉 Wniosek: błędy projektowe utrudniają utrzymanie spójności danych.\n\n\n\n\n2. Zależności funkcjonalne\n\n🔹 Definicja\nZależność funkcjonalna (ang. functional dependency) opisuje relację między atrybutami w tabeli.\nMówimy, że atrybut B jest funkcyjnie zależny od atrybutu A (zapis:\nA → B), jeśli każdej wartości A odpowiada dokładnie jedna wartość B.\n\n\n🔹 Przykłady\n\nNrIndeksu → Imię, Nazwisko, Kierunek\n(każdy numer indeksu jednoznacznie identyfikuje studenta)\nKurs → Sala, Prowadzący\n(dany kurs odbywa się zawsze w tej samej sali, prowadzony przez tę samą osobę)\n\n\n\n🔹 Klucze\n\nKlucz główny (primary key) – jednoznacznie identyfikuje wiersz tabeli.\n\nKlucz kandydujący (candidate key) – minimalny zestaw atrybutów, który może być kluczem.\n\nKlucz obcy (foreign key) – wskazuje na klucz główny w innej tabeli i tworzy powiązanie między tabelami.\n\n\n\n🔹 Typy zależności\n\nZależność pełna – atrybut zależy od całego klucza złożonego.\n\nZależność częściowa – atrybut zależy tylko od części klucza.\n\nZależność przechodnia – atrybut zależy pośrednio od klucza (A → B → C).\n\n\n\n\n\n3. Formy normalne (1NF – 3NF, BCNF)\nNormalizacja to proces przekształcania tabel w taki sposób, aby usunąć redundancję i zapobiec anomaliom.\n\n🧩 Pierwsza postać normalna (1NF)\n\nWszystkie wartości w tabeli są atomowe (niepodzielne).\n\nBrak list, zbiorów lub kolumn powtarzających się.\n✅ Każda kolumna ma jedną wartość w komórce.\n\nPrzykład (naruszenie 1NF): | Student | NrIndeksu | Kursy | |———-|————|——–| | Jan Nowak | 12345 | Bazy danych, Programowanie |\n✅ Poprawnie:\nTworzymy osobną tabelę STUDENT_KURS, gdzie każdy kurs to osobny rekord.\n\n\n\n🧩 Druga postać normalna (2NF)\n\nTabela jest w 1NF i wszystkie atrybuty niekluczowe zależą w pełni od całego klucza głównego.\n\nDotyczy tabel z kluczem złożonym.\n\nPrzykład: Tabela ZAPISY(StudentID, KursID, Sala)\n→ atrybut Sala zależy tylko od KursID, a nie od całego klucza (StudentID, KursID).\nRozwiązanie: wydziel tabelę KURS(KursID, Sala).\n\n\n\n🧩 Trzecia postać normalna (3NF)\n\nTabela jest w 2NF i nie zawiera zależności przechodnich.\n\nKażdy atrybut niekluczowy zależy bezpośrednio od klucza głównego.\n\nPrzykład: NrIndeksu → Kierunek, Kierunek → Dziekan\n➡️ Dziekan zależy pośrednio od NrIndeksu.\nRozwiązanie: osobna tabela KIERUNEK(Dziekan, Kierunek).\n\n\n\n🧩 Postać Boyce’a-Codda (BCNF)\n\nDla każdej zależności A → B, zbiór A musi być kluczem kandydującym.\n\nBardziej restrykcyjna niż 3NF – eliminuje wszelkie potencjalne redundancje.\n\n\n\n\n\n4. Diagramy ERD (Entity–Relationship Diagram)\nDiagram ERD jest graficznym sposobem przedstawienia modelu konceptualnego bazy danych.\n\n🔹 Główne elementy ERD\n\nEncja (Entity) – obiekt, o którym przechowujemy dane (np. Student, Kurs).\n\nAtrybut (Attribute) – właściwość encji (np. Imię, Nazwisko, NrIndeksu).\n\nRelacja (Relationship) – powiązanie między encjami (np. Student zapisuje się na Kurs).\n\nKardynalność (Cardinality) – określa liczność relacji:\n\n1:1 (jeden do jednego)\n\n1:N (jeden do wielu)\n\nN:M (wielu do wielu)\n\n\nIdentyfikator (Primary Key) – atrybut jednoznacznie identyfikujący encję.\n\n\n\n🔹 Przykład:\nSTUDENT (NrIndeksu, Imię, Nazwisko, Kierunek)\nKURS (KursID, Nazwa, Prowadzący)\nZAPIS (NrIndeksu, KursID, DataZapisu)\nRelacja między STUDENT a KURS: N:M poprzez encję pośredniczącą ZAPIS.\n\n\n\n\n5. Proces projektowania bazy danych\nProjektowanie bazy to proces etapowy:\n\nAnaliza wymagań – zrozumienie, jakie dane są potrzebne i jakie operacje będą wykonywane.\n\nModel konceptualny – opis danych w postaci ERD.\n\nModel logiczny – zamiana modelu ERD na relacyjny schemat tabel.\n\nModel fizyczny – implementacja w konkretnym systemie DBMS (np. PostgreSQL, MySQL).\n\n\n\n\n6. Akcent praktyczny\nĆwiczenie (do wykonania na zajęciach):\nZaprojektuj model bazy danych dla prostego systemu uczelnianego, obejmującego: - Studentów, - Kursy, - Wykładowców, - Zapis na kursy.\nPrzygotuj: 1. Diagram ERD,\n2. Schemat relacyjny po normalizacji (do 3NF).",
    "crumbs": [
      "Książki",
      "Wykłady",
      "Normalizacja i projektowanie baz danych"
    ]
  },
  {
    "objectID": "lectures/wyklad3.html#efekty-uczenia-się",
    "href": "lectures/wyklad3.html#efekty-uczenia-się",
    "title": "Normalizacja i projektowanie baz danych",
    "section": "🎓 Efekty uczenia się",
    "text": "🎓 Efekty uczenia się\nPo zakończeniu wykładu student: - rozumie pojęcia normalizacji i zależności funkcjonalnych,\n- potrafi rozpoznać błędy projektowe (redundancja, anomalie),\n- potrafi zaprojektować relacyjną bazę danych zgodnie z zasadami normalizacji,\n- zna podstawowe elementy diagramów ERD i proces projektowania bazy danych.\n\n\n💡 Wskazówka dla studentów:\nW praktyce dążymy do uzyskania trzeciej postaci normalnej (3NF).\nCzasami stosuje się denormalizację dla poprawy wydajności, ale tylko po wcześniejszym zrozumieniu skutków tego działania.",
    "crumbs": [
      "Książki",
      "Wykłady",
      "Normalizacja i projektowanie baz danych"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Informacje ogólne",
    "section": "",
    "text": "Kod:\nSemestr: letni",
    "crumbs": [
      "Książki",
      "Informacje ogólne"
    ]
  },
  {
    "objectID": "index.html#relacyjne-systemy-organizacji-danych",
    "href": "index.html#relacyjne-systemy-organizacji-danych",
    "title": "Informacje ogólne",
    "section": "",
    "text": "Kod:\nSemestr: letni",
    "crumbs": [
      "Książki",
      "Informacje ogólne"
    ]
  },
  {
    "objectID": "index.html#kalendarz",
    "href": "index.html#kalendarz",
    "title": "Informacje ogólne",
    "section": "Kalendarz",
    "text": "Kalendarz\n\nWykład dla grup: WEL23EV1S0, WEL23EA1S0\n\n09.10.2025 Czwartek Wykład 1 - b. 61 sala 116 (3-4)\n14.10.2025 Wtorek Wykład 2 - b. 61 sala 116 (9-10)\n15.10.2025 Środa Wykład 3 - b. 61 sala 116 (3-4)\n29.10.2025 Środa Wykład 4 - b. 61 sala 116 (9-10)\n30.10.2025 Czwartek Wykład 5 - b. 61 sala 116 (5-6)\n\n\n\nLaboratorium grupa WEL23EV1S0:\n\n25.11.2025 Wtorek - b. 61 sala 116\n04.12.2025 czwartek - b. 61 sala 116\n18.12.2025 czwartek - b. 61 sala 116\n08.01.2026 Czwartek - b. 61 sala 116\n22.01.2026 czwartek - b. 61 sala 116\n\n\n\nLaboratorium grupa WEL23EA1S0:\n\n13.11.2025 Czwartek Lab - b. 61 sala 116\n26.11.2025 środa Lab - b. 61 sala 116\n11.12.2025 czwartek - b. 61 sala 116\n15.01.2026 czwartek - b. 61 sala 116\n21.01.2026 środa - b. 61 sala 116",
    "crumbs": [
      "Książki",
      "Informacje ogólne"
    ]
  },
  {
    "objectID": "ksiazki.html",
    "href": "ksiazki.html",
    "title": "Książki i strony WWW",
    "section": "",
    "text": "C.J. Date, An Introduction to Database Systems\nR. Elmasri, S.B. Navathe, Fundamentals of Database Systems\nDokumentacja PostgreSQL: https://www.postgresql.org/docs/"
  },
  {
    "objectID": "ksiazki.html#książki",
    "href": "ksiazki.html#książki",
    "title": "Książki i strony WWW",
    "section": "",
    "text": "C.J. Date, An Introduction to Database Systems\nR. Elmasri, S.B. Navathe, Fundamentals of Database Systems\nDokumentacja PostgreSQL: https://www.postgresql.org/docs/"
  },
  {
    "objectID": "lectures/wyklad2.html",
    "href": "lectures/wyklad2.html",
    "title": "MODEL RELACYJNY I PODSTAWY SQL",
    "section": "",
    "text": "Dane przechowywane w tabelach (relations)\nKażdy wiersz (row) = rekord / krotka\n\nKażda kolumna (column) = atrybut\n\nDziedzina (domain) = zbiór dopuszczalnych wartości w kolumnie\n\n\n\n\nid\nimie\nnazwisko\nrok_urodzenia\n\n\n\n\n1\nAdam\nMickiewicz\n1798\n\n\n2\nHenryk\nSienkiewicz\n1846",
    "crumbs": [
      "Książki",
      "Wykłady",
      "MODEL RELACYJNY I PODSTAWY SQL"
    ]
  },
  {
    "objectID": "lectures/wyklad2.html#model-relacyjny-przypomnienie-i-pojęcia-podstawowe",
    "href": "lectures/wyklad2.html#model-relacyjny-przypomnienie-i-pojęcia-podstawowe",
    "title": "MODEL RELACYJNY I PODSTAWY SQL",
    "section": "",
    "text": "Dane przechowywane w tabelach (relations)\nKażdy wiersz (row) = rekord / krotka\n\nKażda kolumna (column) = atrybut\n\nDziedzina (domain) = zbiór dopuszczalnych wartości w kolumnie\n\n\n\n\nid\nimie\nnazwisko\nrok_urodzenia\n\n\n\n\n1\nAdam\nMickiewicz\n1798\n\n\n2\nHenryk\nSienkiewicz\n1846",
    "crumbs": [
      "Książki",
      "Wykłady",
      "MODEL RELACYJNY I PODSTAWY SQL"
    ]
  },
  {
    "objectID": "lectures/wyklad2.html#klucze-i-więzy-integralności",
    "href": "lectures/wyklad2.html#klucze-i-więzy-integralności",
    "title": "MODEL RELACYJNY I PODSTAWY SQL",
    "section": "2️⃣ Klucze i więzy integralności",
    "text": "2️⃣ Klucze i więzy integralności\n\n🔸 Klucz główny (PRIMARY KEY)\n\nUnikalnie identyfikuje każdy wiersz w tabeli.\nNie może być NULL.\n\n\n\n🔸 Klucz obcy (FOREIGN KEY)\n\nOdwołuje się do innej tabeli (relacja między tabelami).\n\n\n\n🔸 Inne więzy:\n\nUNIQUE – unikalność wartości w kolumnie.\nNOT NULL – kolumna nie może mieć wartości pustej.\nCHECK – warunek logiczny na wartość kolumny.",
    "crumbs": [
      "Książki",
      "Wykłady",
      "MODEL RELACYJNY I PODSTAWY SQL"
    ]
  },
  {
    "objectID": "lectures/wyklad2.html#schemat-bazy-danych-przykład-biblioteka",
    "href": "lectures/wyklad2.html#schemat-bazy-danych-przykład-biblioteka",
    "title": "MODEL RELACYJNY I PODSTAWY SQL",
    "section": "3️⃣ Schemat bazy danych – przykład „Biblioteka”",
    "text": "3️⃣ Schemat bazy danych – przykład „Biblioteka”\n\nTabele:\n\nAutorzy (autor_id, imie, nazwisko)\nKsiazki (ksiazka_id, tytul, rok, autor_id)\n\n\n\nRelacja:\n\nKsiazki.autor_id \\(\\to\\) Autorzy.autor_id (klucz obcy)",
    "crumbs": [
      "Książki",
      "Wykłady",
      "MODEL RELACYJNY I PODSTAWY SQL"
    ]
  },
  {
    "objectID": "lectures/wyklad2.html#tworzenie-tabel-ddl-data-definition-language",
    "href": "lectures/wyklad2.html#tworzenie-tabel-ddl-data-definition-language",
    "title": "MODEL RELACYJNY I PODSTAWY SQL",
    "section": "4️⃣ Tworzenie tabel (DDL – Data Definition Language)",
    "text": "4️⃣ Tworzenie tabel (DDL – Data Definition Language)\nPolecenie CREATE TABLE służy do utworzenia nowej tabeli w bazie danych.\nW tym poleceniu definiujemy nazwy kolumn, ich typy danych oraz różne więzy integralności, takie jak PRIMARY KEY, NOT NULL czy FOREIGN KEY.\nKażda tabela powinna mieć kolumnę, która jednoznacznie identyfikuje każdy wiersz – to właśnie klucz główny.\nW przykładzie poniżej tworzymy dwie tabele: Autorzy i Ksiazki, które będą ze sobą powiązane relacją klucz główny–klucz obcy.\n\nPrzykład w SQLite i PostgreSQL\nCREATE TABLE Autorzy (\n    autor_id     INTEGER PRIMARY KEY,         -- w SQLite automatycznie AUTOINCREMENT\n    imie         TEXT NOT NULL,\n    nazwisko     TEXT NOT NULL\n);\n\nCREATE TABLE Ksiazki (\n    ksiazka_id   SERIAL PRIMARY KEY,          -- PostgreSQL: automatyczna numeracja\n    tytul        VARCHAR(200) NOT NULL,\n    rok          INTEGER CHECK (rok &gt; 0),\n    autor_id     INTEGER,\n    FOREIGN KEY (autor_id) REFERENCES Autorzy(autor_id)\n);\n\nW SQLite INTEGER PRIMARY KEY = alias dla AUTOINCREMENT.\nW PostgreSQL SERIAL lub GENERATED ALWAYS AS IDENTITY.\n\nW powyższym przykładzie tabela Autorzy przechowuje dane o autorach, a tabela Ksiazki – dane o książkach. Kolumna autor_id w tabeli Ksiazki jest kluczem obcym i wskazuje, który autor napisał daną książkę. Dzięki więzom integralności baza pilnuje, aby każda książka miała poprawnego autora. Takie powiązania są podstawą modelu relacyjnego.",
    "crumbs": [
      "Książki",
      "Wykłady",
      "MODEL RELACYJNY I PODSTAWY SQL"
    ]
  },
  {
    "objectID": "lectures/wyklad2.html#modyfikacja-i-usuwanie-tabel",
    "href": "lectures/wyklad2.html#modyfikacja-i-usuwanie-tabel",
    "title": "MODEL RELACYJNY I PODSTAWY SQL",
    "section": "5️⃣ Modyfikacja i usuwanie tabel",
    "text": "5️⃣ Modyfikacja i usuwanie tabel\nALTER TABLE Ksiazki ADD COLUMN gatunek TEXT;\n\nDROP TABLE Ksiazki;",
    "crumbs": [
      "Książki",
      "Wykłady",
      "MODEL RELACYJNY I PODSTAWY SQL"
    ]
  },
  {
    "objectID": "lectures/wyklad2.html#wstawianie-danych-dml-data-manipulation-language",
    "href": "lectures/wyklad2.html#wstawianie-danych-dml-data-manipulation-language",
    "title": "MODEL RELACYJNY I PODSTAWY SQL",
    "section": "6️⃣ Wstawianie danych (DML – Data Manipulation Language)",
    "text": "6️⃣ Wstawianie danych (DML – Data Manipulation Language)\nPolecenie INSERT INTO służy do wprowadzania nowych wierszy (rekordów) do tabeli. Wartości muszą być zgodne z typami kolumn oraz ograniczeniami (NOT NULL, CHECK, itp.). Można dodać jeden lub wiele rekordów w jednym poleceniu. Poniżej wstawiamy kilku autorów oraz ich książki do utworzonych wcześniej tabel.\nINSERT INTO Autorzy (imie, nazwisko) VALUES\n('Adam', 'Mickiewicz'),\n('Henryk', 'Sienkiewicz'),\n('Bolesław', 'Prus');\n\nINSERT INTO Ksiazki (tytul, rok, autor_id) VALUES\n('Pan Tadeusz', 1834, 1),\n('Quo Vadis', 1896, 2),\n('Lalka', 1890, 3);\nKażdy rekord reprezentuje jedną pozycję w tabeli. Polecenie INSERT wymaga podania wartości w tej samej kolejności, w jakiej wymieniono kolumny. Jeśli nie podamy jakiejś kolumny, a ma ona zdefiniowaną wartość domyślną (DEFAULT), baza wstawi ją automatycznie. Dzięki temu możemy stopniowo budować zawartość naszej bazy danych.",
    "crumbs": [
      "Książki",
      "Wykłady",
      "MODEL RELACYJNY I PODSTAWY SQL"
    ]
  },
  {
    "objectID": "lectures/wyklad2.html#wybieranie-danych-select",
    "href": "lectures/wyklad2.html#wybieranie-danych-select",
    "title": "MODEL RELACYJNY I PODSTAWY SQL",
    "section": "7️⃣ Wybieranie danych – SELECT",
    "text": "7️⃣ Wybieranie danych – SELECT\n\n🧩 Podstawowy SELECT\nPolecenie SELECT jest najczęściej używanym poleceniem SQL i służy do pobierania danych z tabel. Pozwala określić, które kolumny chcemy zobaczyć i z których tabel dane mają pochodzić. Jeśli użyjemy gwiazdki *, oznacza to, że wybieramy wszystkie kolumny. Poniższe zapytanie zwraca wszystkich autorów z tabeli Autorzy.\nSELECT * FROM Autorzy;\n\n\n🧩 Wybór konkretnych kolumn\nSELECT imie, nazwisko FROM Autorzy;\nWynik to pełna tabela z kolumnami autor_id, imie i nazwisko. Często jednak potrzebujemy tylko części danych, np. imienia i nazwiska – wtedy podajemy konkretne kolumny:\n\n\n🧩 Nadawanie aliasów\nSELECT imie AS \"Imię\", nazwisko AS \"Nazwisko\" FROM Autorzy;\nTakie zapytania pomagają ograniczyć ilość danych i zwiększyć czytelność wyników. Warto też nadawać aliasy (AS), które pozwalają zmienić nazwę kolumn w wynikach i nadać im bardziej opisowy wygląd.",
    "crumbs": [
      "Książki",
      "Wykłady",
      "MODEL RELACYJNY I PODSTAWY SQL"
    ]
  },
  {
    "objectID": "lectures/wyklad2.html#filtrowanie-where",
    "href": "lectures/wyklad2.html#filtrowanie-where",
    "title": "MODEL RELACYJNY I PODSTAWY SQL",
    "section": "8️⃣ Filtrowanie – WHERE",
    "text": "8️⃣ Filtrowanie – WHERE\nKiedy chcemy wybrać tylko część danych, używamy klauzuli WHERE. Dzięki niej możemy ustawić warunki, jakie muszą spełniać rekordy, by pojawiły się w wyniku. To bardzo potężne narzędzie, które pozwala np. wyszukiwać książki z konkretnego roku lub autora. W poniższym przykładzie wybieramy książki wydane po roku 1850.\nSELECT * FROM Ksiazki\nWHERE rok &gt; 1850;\n\n🧠 Operatory:\nMożemy też stosować inne operatory:\n\n=, &lt;&gt;, &lt;, &gt;, &lt;=, &gt;=\nLIKE ‘Q%’ → zaczyna się na Q\nIN (…)\nBETWEEN 1800 AND 1900\nIS NULL, IS NOT NULL\n\nNa przykład, aby znaleźć wszystkie książki, których tytuł zawiera literę „a”, używamy wzorca z LIKE:\nSELECT tytul FROM Ksiazki WHERE tytul LIKE '%a%';\nKlauzula WHERE pozwala więc filtrować dane na wiele sposobów, co czyni zapytania SQL bardzo elastycznymi.",
    "crumbs": [
      "Książki",
      "Wykłady",
      "MODEL RELACYJNY I PODSTAWY SQL"
    ]
  },
  {
    "objectID": "lectures/wyklad2.html#sortowanie-order-by",
    "href": "lectures/wyklad2.html#sortowanie-order-by",
    "title": "MODEL RELACYJNY I PODSTAWY SQL",
    "section": "9️⃣ Sortowanie – ORDER BY",
    "text": "9️⃣ Sortowanie – ORDER BY\nPo pobraniu danych często chcemy uporządkować je według określonego kryterium. Do tego służy klauzula ORDER BY, dzięki której możemy sortować rosnąco (ASC) lub malejąco (DESC). Sortowanie działa na dowolnej kolumnie, także tych, które nie są wyświetlane w wyniku. W przykładzie poniżej porządkujemy książki według roku wydania od najnowszej do najstarszej.\nSELECT * FROM Ksiazki ORDER BY rok DESC;\nJeśli nie podamy kierunku sortowania, domyślnie jest to ASC (rosnąco). Można też sortować według kilku kolumn jednocześnie, np. najpierw po autorze, a potem po roku. Sortowanie poprawia czytelność wyników i pozwala szybciej analizować dane.",
    "crumbs": [
      "Książki",
      "Wykłady",
      "MODEL RELACYJNY I PODSTAWY SQL"
    ]
  },
  {
    "objectID": "lectures/wyklad2.html#grupowanie-i-agregacja-group-by-having",
    "href": "lectures/wyklad2.html#grupowanie-i-agregacja-group-by-having",
    "title": "MODEL RELACYJNY I PODSTAWY SQL",
    "section": "🔟 Grupowanie i agregacja – GROUP BY, HAVING",
    "text": "🔟 Grupowanie i agregacja – GROUP BY, HAVING\nCzasem chcemy policzyć, ile danych należy do danej kategorii – np. ilu autorów napisało więcej niż jedną książkę. Do tego służy GROUP BY, które grupuje dane według wybranej kolumny. W połączeniu z funkcjami agregującymi, takimi jak COUNT(), AVG(), SUM(), MIN() czy MAX(), daje duże możliwości analizy. Klauzula HAVING pozwala odfiltrować grupy po obliczeniu agregacji.\nSELECT autor_id, COUNT(*) AS liczba_ksiazek\nFROM Ksiazki\nGROUP BY autor_id\nHAVING COUNT(*) &gt; 1;\nTo zapytanie zwraca tylko tych autorów, którzy mają więcej niż jedną książkę. Różnica między WHERE a HAVING polega na tym, że WHERE filtruje pojedyncze wiersze przed grupowaniem, a HAVING filtruje całe grupy po agregacji. Wyniki można potem łączyć z innymi tabelami, by uzyskać bardziej opisowe raporty.",
    "crumbs": [
      "Książki",
      "Wykłady",
      "MODEL RELACYJNY I PODSTAWY SQL"
    ]
  },
  {
    "objectID": "lectures/wyklad2.html#łączenie-tabel-join",
    "href": "lectures/wyklad2.html#łączenie-tabel-join",
    "title": "MODEL RELACYJNY I PODSTAWY SQL",
    "section": "1️⃣1️⃣ Łączenie tabel – JOIN",
    "text": "1️⃣1️⃣ Łączenie tabel – JOIN\nW relacyjnym modelu danych informacje są rozproszone w różnych tabelach, które łączy się przy pomocy kluczy obcych. Polecenie JOIN pozwala zestawić dane z kilku tabel na podstawie wspólnej kolumny. Najczęściej używany jest INNER JOIN, który zwraca tylko rekordy, dla których istnieje dopasowanie w obu tabelach. W przykładzie łączymy tabelę Ksiazki z Autorzy, aby zobaczyć tytuł książki i jej autora.\n\n🔹 INNER JOIN\nSELECT k.tytul, a.imie, a.nazwisko\nFROM Ksiazki k\nJOIN Autorzy a ON k.autor_id = a.autor_id;\nWynikiem będzie lista książek wraz z imieniem i nazwiskiem autora. Jeśli chcemy, aby w wynikach pojawiły się także książki bez autora (lub autorzy bez książek), używamy odpowiednio LEFT JOIN lub RIGHT JOIN. Łączenie tabel to fundament relacyjnych baz danych – dzięki niemu dane są spójne i nie trzeba ich powielać.\n\n\n🔹 LEFT JOIN\nSELECT k.tytul, a.imie, a.nazwisko\nFROM Ksiazki k\nLEFT JOIN Autorzy a ON k.autor_id = a.autor_id;",
    "crumbs": [
      "Książki",
      "Wykłady",
      "MODEL RELACYJNY I PODSTAWY SQL"
    ]
  },
  {
    "objectID": "lectures/wyklad2.html#aktualizacja-i-usuwanie-danych",
    "href": "lectures/wyklad2.html#aktualizacja-i-usuwanie-danych",
    "title": "MODEL RELACYJNY I PODSTAWY SQL",
    "section": "1️⃣2️⃣ Aktualizacja i usuwanie danych",
    "text": "1️⃣2️⃣ Aktualizacja i usuwanie danych\nPolecenie UPDATE pozwala modyfikować dane już istniejące w tabeli. Zawsze należy używać klauzuli WHERE, aby zmiana nie objęła wszystkich rekordów. Z kolei DELETE służy do usuwania rekordów – również z warunkiem, by nie usunąć wszystkiego przez pomyłkę. Przykład poniżej pokazuje, jak zmienić rok wydania książki i usunąć starsze pozycje.\nUPDATE Ksiazki SET rok = 1836 WHERE tytul = 'Pan Tadeusz';\n\nDELETE FROM Ksiazki WHERE rok &lt; 1850;\nUPDATE pozwala też aktualizować wiele kolumn naraz, a nawet wykonywać obliczenia. Z kolei DELETE usuwa rekordy z tabeli, ale nie zmienia struktury bazy. Warto zawsze testować warunek WHERE wcześniej przy pomocy SELECT, by uniknąć niechcianych usunięć.",
    "crumbs": [
      "Książki",
      "Wykłady",
      "MODEL RELACYJNY I PODSTAWY SQL"
    ]
  },
  {
    "objectID": "lectures/wyklad2.html#podsumowanie",
    "href": "lectures/wyklad2.html#podsumowanie",
    "title": "MODEL RELACYJNY I PODSTAWY SQL",
    "section": "Podsumowanie",
    "text": "Podsumowanie\nSQL jest językiem deklaratywnym – opisujemy co chcemy uzyskać, a nie jak to zrobić. Dzięki temu użytkownik nie musi znać szczegółów działania bazy danych, wystarczy, że opisze warunki i strukturę zapytania. Poznane dziś polecenia (CREATE, INSERT, SELECT, UPDATE, DELETE, JOIN, GROUP BY) to fundament pracy z bazami danych. Opanowanie ich pozwala budować i analizować nawet bardzo złożone systemy informacyjne.\n\nDokumentacja SQLite\nDokumentacja PostgreSQL\nA. Silberschatz, H. Korth, S. Sudarshan, Database System Concepts",
    "crumbs": [
      "Książki",
      "Wykłady",
      "MODEL RELACYJNY I PODSTAWY SQL"
    ]
  },
  {
    "objectID": "lectures/wyklad1.html",
    "href": "lectures/wyklad1.html",
    "title": "Od pliku do bazy danych",
    "section": "",
    "text": "zrozumienie pojęcia danych, informacji i wiedzy,\npoznanie podstawowych form organizacji danych,\nwprowadzenie do pojęcia systemu bazodanowego.\n\n\n\n\nDane, informacja, wiedza – hierarchia pojęć.\n\n\n\n\nustrukturyzowane (np. tabele CSV),\npółustrukturyzowane (JSON, XML),\nnieustrukturyzowane (obrazy, dźwięk, teksty).\n\n\n\n\npliki płaskie – cechy, wady, zalety,\nsystemy plików, metadane, nazwy, prawa dostępu.\n\n\n\n\n\nredundancja,\nniespójność,\nbrak współbieżności.\n\n\n\n\n\nidea centralnego repozytorium,\nkorzyści z relacyjnego modelu danych,\nkrótka historia (Codd, model relacyjny).\n\n\n\n\n\nEfekty uczenia się: rozumie, dlaczego stosuje się bazy danych i jakie problemy rozwiązują.",
    "crumbs": [
      "Książki",
      "Wykłady",
      "Od pliku do bazy danych"
    ]
  },
  {
    "objectID": "lectures/wyklad1.html#plan",
    "href": "lectures/wyklad1.html#plan",
    "title": "Od pliku do bazy danych",
    "section": "",
    "text": "zrozumienie pojęcia danych, informacji i wiedzy,\npoznanie podstawowych form organizacji danych,\nwprowadzenie do pojęcia systemu bazodanowego.\n\n\n\n\nDane, informacja, wiedza – hierarchia pojęć.\n\n\n\n\nustrukturyzowane (np. tabele CSV),\npółustrukturyzowane (JSON, XML),\nnieustrukturyzowane (obrazy, dźwięk, teksty).\n\n\n\n\npliki płaskie – cechy, wady, zalety,\nsystemy plików, metadane, nazwy, prawa dostępu.\n\n\n\n\n\nredundancja,\nniespójność,\nbrak współbieżności.\n\n\n\n\n\nidea centralnego repozytorium,\nkorzyści z relacyjnego modelu danych,\nkrótka historia (Codd, model relacyjny).\n\n\n\n\n\nEfekty uczenia się: rozumie, dlaczego stosuje się bazy danych i jakie problemy rozwiązują.",
    "crumbs": [
      "Książki",
      "Wykłady",
      "Od pliku do bazy danych"
    ]
  },
  {
    "objectID": "lectures/wyklad1.html#dane-informacja-wiedza",
    "href": "lectures/wyklad1.html#dane-informacja-wiedza",
    "title": "Od pliku do bazy danych",
    "section": "🧩 1. Dane, informacja, wiedza",
    "text": "🧩 1. Dane, informacja, wiedza\n🗣\nZacznijmy od podstawowego pytania: czym właściwie są dane?\nDane to surowe fakty – liczby, znaki, pomiary, które same w sobie nie mają znaczenia, dopóki ich nie zinterpretujemy.\nGdy dane zaczynamy rozumieć w kontekście – powstaje informacja.\nA gdy potrafimy z tej informacji wyciągać wnioski i podejmować decyzje – mamy wiedzę.\n\n📊 Przykład:\nDane: \\(36.7, 37.1, 38.2\\)\nInformacja: „Temperatura pacjenta w trzech pomiarach w ciągu dnia.”\nWiedza: „Pacjent ma gorączkę, prawdopodobnie infekcja.”\n\n\n💬 Pytanie:\n\nCzy można mieć dużo danych i żadnej wiedzy? Jakie są przykłady z życia codziennego?",
    "crumbs": [
      "Książki",
      "Wykłady",
      "Od pliku do bazy danych"
    ]
  },
  {
    "objectID": "lectures/wyklad1.html#rodzaje-danych-1",
    "href": "lectures/wyklad1.html#rodzaje-danych-1",
    "title": "Od pliku do bazy danych",
    "section": "💾 2. Rodzaje danych",
    "text": "💾 2. Rodzaje danych\n🗣\nW świecie informatyki dane występują w różnych formach. Warto je uporządkować według stopnia strukturyzacji.\n\n📚 Klasyfikacja:\n\nUstrukturyzowane\n\nDane w tabelach, arkuszach, bazach. Każdy wiersz ma taki sam zestaw kolumn.\nPrzykład: tabela klientów w Excelu lub SQL.\n\n\n\nID\nImię\nNazwisko\nMiasto\n\n\n\n\n1\nAnna\nNowak\nKraków\n\n\n2\nJan\nKowalski\nWarszawa\n\n\n\n\nPółustrukturyzowane\n\nZawierają strukturę, ale nie jest ona sztywna.\nPrzykład: pliki JSON, XML.\n{\n  \"imie\": \"Anna\",\n  \"miasto\": \"Kraków\",\n  \"zainteresowania\": [\"sport\", \"muzyka\"]\n}\n\nNieustrukturyzowane\n\nBrak jasno określonej struktury danych.\nPrzykład: obraz, dźwięk, wideo, dokument PDF.\nTakie dane trudno przeszukiwać klasycznymi metodami SQL.\n\n\n💬 Pytanie:\n\nJakie dane generujemy codziennie jako użytkownicy internetu? Które z nich są ustrukturyzowane?",
    "crumbs": [
      "Książki",
      "Wykłady",
      "Od pliku do bazy danych"
    ]
  },
  {
    "objectID": "lectures/wyklad1.html#pliki-jako-forma-przechowywania-danych-1",
    "href": "lectures/wyklad1.html#pliki-jako-forma-przechowywania-danych-1",
    "title": "Od pliku do bazy danych",
    "section": "🗂️ 3. Pliki jako forma przechowywania danych",
    "text": "🗂️ 3. Pliki jako forma przechowywania danych\n🗣\nZanim powstały bazy danych, dane przechowywano w plikach płaskich (flat files).\nTo po prostu zbiory rekordów w postaci tekstowej lub binarnej, np. plik .csv lub .txt.\n📄 Przykład pliku płaskiego (CSV):\nID,Imię,Nazwisko,Miasto\n1,Anna,Nowak,Kraków\n2,Jan,Kowalski,Warszawa\n3,Piotr,Wiśniewski,Poznań\n\n🗃 Co można zauważyć:\nDane są łatwe do odczytania – można otworzyć w Excelu lub notatniku.\nAle… brak:\n\nkontroli nad poprawnością (np. można wpisać błędny numer ID),\nrelacji między danymi (osobna lista klientów i zamówień się nie łączy),\nspójności przy równoczesnym dostępie.\n\n\n\n💬 Pytanie:\n\nCo się stanie, gdy dwie osoby jednocześnie edytują ten sam plik CSV?",
    "crumbs": [
      "Książki",
      "Wykłady",
      "Od pliku do bazy danych"
    ]
  },
  {
    "objectID": "lectures/wyklad1.html#problemy-pracy-z-plikami",
    "href": "lectures/wyklad1.html#problemy-pracy-z-plikami",
    "title": "Od pliku do bazy danych",
    "section": "🧱 4. Problemy pracy z plikami",
    "text": "🧱 4. Problemy pracy z plikami\n🗣\nWraz ze wzrostem ilości danych zaczynają się problemy.\nSystemy plikowe mają ograniczenia, których nie da się przeskoczyć bez bazy danych.\n\n⚠️ Typowe problemy:\n\nRedundancja danych – powielanie informacji. np. imię i adres klienta wpisywany przy każdym zamówieniu.\nNiespójność danych – różne wersje tych samych danych w wielu plikach.\nTrudność w aktualizacji – brak jednego miejsca prawdy.\nBrak współbieżności – tylko jeden użytkownik może bezpiecznie edytować.\nBrak bezpieczeństwa i kontroli dostępu.\n\n\n\n🧠 Przykład:\nPlik klienci.txt i zamowienia.txt – brak połączenia między nimi.\nTrudno ustalić, które zamówienie należy do którego klienta.\nklienci.txt:\n1;Anna Nowak;Kraków\n2;Jan Kowalski;Warszawa\n\nzamowienia.txt:\n10;Laptop;1\n11;Monitor;2\n12;Kabel HDMI;1\nTo działa, ale co jeśli zmienimy ID klienta lub nazwę produktu? Powstaje chaos.",
    "crumbs": [
      "Książki",
      "Wykłady",
      "Od pliku do bazy danych"
    ]
  },
  {
    "objectID": "lectures/wyklad1.html#od-pliku-do-bazy-danych",
    "href": "lectures/wyklad1.html#od-pliku-do-bazy-danych",
    "title": "Od pliku do bazy danych",
    "section": "🧮 5. Od pliku do bazy danych",
    "text": "🧮 5. Od pliku do bazy danych\n🗣\nAby rozwiązać te problemy, w latach 70. pojawiła się koncepcja systemu bazodanowego.\nPomysł był prosty, ale rewolucyjny:\n\ndane przechowywane są w jednym centralnym repozytorium,\ndostęp do nich odbywa się przez język zapytań (SQL),\nkontrolowana jest spójność, współbieżność, bezpieczeństwo.\n\n\n📚 Pojęcia podstawowe:\n\nBaza danych – zbiór danych o określonej strukturze.\nSystem zarządzania bazą danych (DBMS) – oprogramowanie do tworzenia, przechowywania, udostępniania danych.\nUżytkownicy – aplikacje, programiści, analitycy, którzy korzystają z danych.\n\n\n\n📊 Przykład:\nPorównanie pliku CSV z tabelą SQL:\n\n\n\n\n\n\n\n\nCecha\nPlik CSV\nBaza danych (SQL)\n\n\n\n\nStruktura danych\nTekstowa, dowolna\nŚciśle zdefiniowana (kolumny, typy)\n\n\nSpójność danych\nNie\nZapewnia DBMS\n\n\nWspółbieżność\nBrak\nObsługiwana\n\n\nWyszukiwanie\nPełne skanowanie\nZapytania, indeksy\n\n\nBezpieczeństwo\nBrak\nKontrola dostępu",
    "crumbs": [
      "Książki",
      "Wykłady",
      "Od pliku do bazy danych"
    ]
  },
  {
    "objectID": "lectures/wyklad1.html#różnice-w-przetwarzaniu-danych-przykład-porównawczy",
    "href": "lectures/wyklad1.html#różnice-w-przetwarzaniu-danych-przykład-porównawczy",
    "title": "Od pliku do bazy danych",
    "section": "🧠 6. Różnice w przetwarzaniu danych – przykład porównawczy",
    "text": "🧠 6. Różnice w przetwarzaniu danych – przykład porównawczy\n🗣\nZanim przejdziemy do SQL, warto zrozumieć, że rodzaj danych determinuje sposób ich przetwarzania.\n\n\n\n\n\n\n\n\n\nTyp danych\nPrzykład\nNarzędzie przetwarzania\nTypowe operacje\n\n\n\n\nTabelaryczne\nsprzedaż, klienci\nSQL, Excel\nsortowanie, sumowanie, filtracja\n\n\nTekstowe\nartykuły, maile\nwyszukiwanie pełnotekstowe\nindeksowanie, analiza słów\n\n\nObraz\nzdjęcia, wideo\nbiblioteki CV, AI\nklasyfikacja, rozpoznawanie obiektów\n\n\nDźwięk\nnagrania, mowa\nDSP, ML\nfiltracja, transkrypcja\n\n\n\n\n💬 Pytanie:\n\nDlaczego dane tabelaryczne można łatwo ująć w relacje, a dźwięk czy obraz – już nie?",
    "crumbs": [
      "Książki",
      "Wykłady",
      "Od pliku do bazy danych"
    ]
  },
  {
    "objectID": "lectures/wyklad1.html#podsumowanie-wykładu",
    "href": "lectures/wyklad1.html#podsumowanie-wykładu",
    "title": "Od pliku do bazy danych",
    "section": "🧩 7. Podsumowanie wykładu",
    "text": "🧩 7. Podsumowanie wykładu\n\n🔑 Kluczowe pojęcia:\nDane vs informacja vs wiedza\nUstrukturyzowane / nieustrukturyzowane dane\nPlik płaski i jego ograniczenia\nPowody wprowadzenia systemów baz danych\n\n\n🧭 Wniosek:\n\nBazy danych powstały nie dlatego, że ktoś lubił tabele, ale dlatego, że pliki przestały wystarczać do utrzymania spójnych, współdzielonych informacji.",
    "crumbs": [
      "Książki",
      "Wykłady",
      "Od pliku do bazy danych"
    ]
  },
  {
    "objectID": "lectures/wyklad1.html#historia-i-ewolucja-baz-danych",
    "href": "lectures/wyklad1.html#historia-i-ewolucja-baz-danych",
    "title": "Od pliku do bazy danych",
    "section": "Historia i ewolucja baz danych",
    "text": "Historia i ewolucja baz danych\nBazy danych nie są wynalazkiem XXI wieku — ich początki sięgają lat 60. XX wieku, gdy organizacje zaczęły gromadzić coraz większe ilości danych.\n\n🔹 Systemy plikowe\nPierwsze systemy przechowywały dane w plikach na dyskach. Choć były proste, miały poważne ograniczenia:\n\nBrak centralnej kontroli nad danymi\nTrudność w utrzymaniu spójności\nBrak uniwersalnych narzędzi do wyszukiwania\n\n💡 Zadanie: Na jakich innych obiektach, oprócz plików, można pracować w systemach operacyjnych?\n\n\n🔹 Wczesne systemy DBMS\nW latach 60. i 70. pojawiły się pierwsze systemy zarządzania bazami danych (DBMS). Zapewniały:\n\ncentralną kontrolę danych,\nintegralność i bezpieczeństwo,\nwydajne przetwarzanie i wyszukiwanie.\n\n\n\n🔹 Modele hierarchiczne i sieciowe\nWczesne systemy wykorzystywały struktury drzewiaste lub grafowe. Były skuteczne, ale trudne w modyfikacji i rozwoju.\n\n\n🔹 Przełom: model relacyjny\nW 1970 roku Edgar F. Codd zaproponował model relacyjny danych, w którym:\n\ndane są przechowywane w tabelach (relacjach),\nkażda tabela ma kolumny (atrybuty) i wiersze (krotki).\n\nZalety:\n\nprostota i przejrzystość,\nelastyczność (łatwo dodawać nowe tabele),\nbezpieczeństwo i spójność danych.\n\n\n\n🔹 SQL – język pracy z danymi\nWraz z rozwojem modelu relacyjnego powstał SQL (Structured Query Language) – język do tworzenia, modyfikowania i pobierania danych.\nDziś SQL jest fundamentem większości systemów: od aplikacji biurowych po duże systemy korporacyjne. Nawet współczesne rozwiązania NoSQL często nawiązują do idei relacyjnych.",
    "crumbs": [
      "Książki",
      "Wykłady",
      "Od pliku do bazy danych"
    ]
  },
  {
    "objectID": "lectures/wyklad1.html#dane-informacja-baza-danych-i-dbms",
    "href": "lectures/wyklad1.html#dane-informacja-baza-danych-i-dbms",
    "title": "Od pliku do bazy danych",
    "section": "Dane, informacja, baza danych i DBMS",
    "text": "Dane, informacja, baza danych i DBMS\n\n🔹 Dane a informacja\n\nDane – surowe fakty, liczby, teksty, które same w sobie niewiele znaczą. 👉 np. 25, Warszawa, 12345\nInformacja – dane zinterpretowane i zorganizowane w kontekście. 👉 np. „25 klientów z Warszawy złożyło zamówienie w ostatnim tygodniu”.\n\nDane to materiał, informacja to znaczenie.\n\n\n🔹 Baza danych\nZorganizowany zbiór danych umożliwiający ich łatwe przeszukiwanie, aktualizację i analizę.\nCechy:\n\nStrukturalność\nCentralizacja\nTrwałość i bezpieczeństwo\n\nPrzykłady:\n\nLista kontaktów w telefonie\nSystem rezerwacji hotelowej\nSklep internetowy",
    "crumbs": [
      "Książki",
      "Wykłady",
      "Od pliku do bazy danych"
    ]
  },
  {
    "objectID": "lectures/wyklad1.html#materiały-do-dalszej-lektury",
    "href": "lectures/wyklad1.html#materiały-do-dalszej-lektury",
    "title": "Od pliku do bazy danych",
    "section": "📚 Materiały do dalszej lektury",
    "text": "📚 Materiały do dalszej lektury\n\nC.J. Date, An Introduction to Database Systems\nR. Elmasri, S.B. Navathe, Fundamentals of Database Systems\nDokumentacja PostgreSQL: https://www.postgresql.org/docs/",
    "crumbs": [
      "Książki",
      "Wykłady",
      "Od pliku do bazy danych"
    ]
  }
]