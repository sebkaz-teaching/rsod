[
  {
    "objectID": "lectures/plan.html",
    "href": "lectures/plan.html",
    "title": "Relacyjne Systemy Organizacji Danych",
    "section": "",
    "text": "📙 WYKŁAD 3 – NORMALIZACJA I PROJEKTOWANIE BAZ DANYCH Temat: Jak uniknąć błędów w projektowaniu? Cele: nauczenie zasad normalizacji, zrozumienie zależności funkcjonalnych, wprowadzenie do diagramów ERD. Zakres treści: Problemy złego projektu: redundancja, anomalie aktualizacji, usuwania. Pojęcie zależności funkcjonalnych. Formy normalne (1NF–3NF, BCNF): przykłady i zastosowania. Diagramy ERD (Entity–Relationship Diagram): encje, atrybuty, relacje, kardynalności, identyfikatory. Proces projektowania bazy: analiza wymagań → model konceptualny → model logiczny → model fizyczny. Akcent praktyczny: ćwiczenie – model bazy danych dla systemu uczelnianego. Efekty uczenia się: potrafi projektować relacyjną bazę danych zgodnie z zasadami normalizacji. 📒 WYKŁAD 4 – TRANSAKCJE, WSPÓŁBIEŻNOŚĆ I WIDOKI Temat: Mechanizmy zapewniania spójności danych Cele: poznanie zasad transakcyjności, zrozumienie współbieżności i izolacji, wprowadzenie do widoków i ich zastosowań. Zakres treści: Pojęcie transakcji i właściwości ACID: atomicity, consistency, isolation, durability. Problemy współbieżności: utracone aktualizacje, odczyty brudnych danych, blokady. Poziomy izolacji transakcji. Widoki (Views): definicja, zalety (abstrakcja, bezpieczeństwo), przykłady CREATE VIEW, WITH CHECK OPTION. Przykład – transakcje w PostgreSQL (BEGIN/COMMIT/ROLLBACK). Akcent praktyczny: analiza równoczesnych transakcji na tej samej tabeli. Efekty uczenia się: rozumie zasady transakcyjności i umie zastosować widoki. 📕 WYKŁAD 5 – ADMINISTRACJA, BEZPIECZEŃSTWO I KOPIE ZAPASOWE Temat: Utrzymanie i ochrona baz danych Cele: poznanie zasad administrowania bazami danych, zrozumienie bezpieczeństwa i odporności systemów bazodanowych. Zakres treści: Role i uprawnienia użytkowników: GRANT, REVOKE, zarządzanie kontami. Bezpieczeństwo danych: szyfrowanie, kontrola dostępu, logowanie zdarzeń. Backup i odzyskiwanie: kopie pełne, przyrostowe, różnicowe, replikacja i wysokie dostępności (HA). Monitorowanie i optymalizacja: indeksy, analiza planów zapytań. Przegląd systemów bazodanowych: PostgreSQL, MySQL, SQLite, MS SQL, Oracle. Efekty uczenia się: zna metody ochrony i zarządzania bazami danych, potrafi wskazać strategie kopii zapasowych. 💡 PROJEKT ZALICZENIOWY (do realizacji na ćwiczeniach) Temat: Projekt i implementacja relacyjnej bazy danych wspierającej wybrany proces organizacyjny. Etapy projektu: Analiza problemu i identyfikacja wymagań. (np. system rezerwacji sal, ewidencja sprzętu, biblioteka, wypożyczalnia, rejestr studentów) Model konceptualny (ERD) i logiczny bazy danych. Implementacja bazy w wybranym systemie (np. PostgreSQL). Wypełnienie przykładowymi danymi, przygotowanie zapytań SQL. Demonstracja transakcji, widoków i podstawowych mechanizmów bezpieczeństwa. Efekty projektu: integracja wiedzy z zakresu modelowania, SQL i zarządzania, praktyczne umiejętności tworzenia bazy danych od podstaw, doświadczenie w pracy zespołowej i prezentacji wyników. 📈 POWIĄZANIE Z EFEKTAMI UCZENIA SIĘ Efekt uczenia się Odniesienie do wykładów / projektu Zna i rozumie algorytmy i metody w systemach BD Wykłady 2–5 Ma wiedzę z zakresu przetwarzania danych Wykład 1, 2 Zna standardy stosowane w BD Wykłady 2, 5 Potrafi przygotować prezentację i prowadzić dyskusję Projekt zespołowy Umie wykorzystać modele w realizacji projektów BD Wykład 3 + projekt Integruje wiedzę techniczną i pozatechniczną Projekt (analiza potrzeb użytkownika) Określa priorytety w realizacji zadań Projekt – planowanie etapów\nnowe elementy"
  },
  {
    "objectID": "lectures/wyklad4.html",
    "href": "lectures/wyklad4.html",
    "title": "WYKŁAD 4 – Podstawy PL/SQL, transakcje i indeksy",
    "section": "",
    "text": "Celem wykładu jest wprowadzenie do języka proceduralnego PL/SQL, pokazanie zasad przetwarzania transakcyjnego w bazach danych oraz omówienie roli indeksów w przyspieszaniu wyszukiwania danych.",
    "crumbs": [
      "Książki",
      "Wykłady",
      "WYKŁAD 4 – Podstawy PL/SQL, transakcje i indeksy"
    ]
  },
  {
    "objectID": "lectures/wyklad4.html#temat-programowanie-w-plsql-i-podstawy-optymalizacji",
    "href": "lectures/wyklad4.html#temat-programowanie-w-plsql-i-podstawy-optymalizacji",
    "title": "WYKŁAD 4 – Podstawy PL/SQL, transakcje i indeksy",
    "section": "",
    "text": "Celem wykładu jest wprowadzenie do języka proceduralnego PL/SQL, pokazanie zasad przetwarzania transakcyjnego w bazach danych oraz omówienie roli indeksów w przyspieszaniu wyszukiwania danych.",
    "crumbs": [
      "Książki",
      "Wykłady",
      "WYKŁAD 4 – Podstawy PL/SQL, transakcje i indeksy"
    ]
  },
  {
    "objectID": "lectures/wyklad4.html#cele-wykładu",
    "href": "lectures/wyklad4.html#cele-wykładu",
    "title": "WYKŁAD 4 – Podstawy PL/SQL, transakcje i indeksy",
    "section": "🧠 Cele wykładu",
    "text": "🧠 Cele wykładu\nStudent po wykładzie będzie potrafił:\n\nzrozumieć różnice między SQL a PL/SQL,\n\npisać proste bloki PL/SQL do operowania na danych,\n\nzarządzać transakcjami (commit, rollback),\n\nrozumieć rolę i zasady tworzenia indeksów w bazie danych.",
    "crumbs": [
      "Książki",
      "Wykłady",
      "WYKŁAD 4 – Podstawy PL/SQL, transakcje i indeksy"
    ]
  },
  {
    "objectID": "lectures/wyklad4.html#wprowadzenie-do-plsql",
    "href": "lectures/wyklad4.html#wprowadzenie-do-plsql",
    "title": "WYKŁAD 4 – Podstawy PL/SQL, transakcje i indeksy",
    "section": "1️⃣ Wprowadzenie do PL/SQL",
    "text": "1️⃣ Wprowadzenie do PL/SQL\n\n🔹 Czym jest PL/SQL?\n\nPL/SQL to proceduralny język rozszerzający SQL w systemach Oracle i kompatybilnych.\n\nUmożliwia użycie instrukcji warunkowych, pętli, zmiennych i procedur, czego SQL nie oferuje w formie deklaratywnej.\n\nPrzykład prostego bloku PL/SQL:\nBEGIN\n    DBMS_OUTPUT.PUT_LINE('Witaj w świecie PL/SQL!');\nEND;\n/\nKod ten uruchamia blok proceduralny, który wypisuje komunikat.\nBEGIN rozpoczyna blok, END; kończy, a / uruchamia go w SQL*Plus.\n\n\n🔹 Zmienne i typy danych\nPL/SQL pozwala tworzyć zmienne i przypisywać im wartości.\nDECLARE\n    v_imie VARCHAR2(50);\n    v_wiek NUMBER;\nBEGIN\n    v_imie := 'Jan';\n    v_wiek := 25;\n    DBMS_OUTPUT.PUT_LINE('Student: ' || v_imie || ', wiek: ' || v_wiek);\nEND;\n/\nZmienne umożliwiają przechowywanie danych tymczasowo w trakcie wykonywania programu.\n\n\n🔹 Instrukcje warunkowe i pętle\nPL/SQL pozwala na użycie:\n\nIF…THEN…ELSE:\n\nIF v_wiek &gt;= 18 THEN\n    DBMS_OUTPUT.PUT_LINE('Pełnoletni');\nELSE\n    DBMS_OUTPUT.PUT_LINE('Niepełnoletni');\nEND IF;\n\nLOOP, WHILE, FOR – do powtarzania operacji:\n\nFOR i IN 1..5 LOOP\n    DBMS_OUTPUT.PUT_LINE('Liczba: ' || i);\nEND LOOP;\nInstrukcje warunkowe i pętle pozwalają w pełni programować logikę w bazie danych.",
    "crumbs": [
      "Książki",
      "Wykłady",
      "WYKŁAD 4 – Podstawy PL/SQL, transakcje i indeksy"
    ]
  },
  {
    "objectID": "lectures/wyklad4.html#operacje-na-danych-w-plsql",
    "href": "lectures/wyklad4.html#operacje-na-danych-w-plsql",
    "title": "WYKŁAD 4 – Podstawy PL/SQL, transakcje i indeksy",
    "section": "2️⃣ Operacje na danych w PL/SQL",
    "text": "2️⃣ Operacje na danych w PL/SQL\nPL/SQL umożliwia wykonywanie standardowych operacji SQL:\n\nINSERT, UPDATE, DELETE – bezpośrednio w blokach proceduralnych.\n\nPrzykład aktualizacji studenta:\nBEGIN\n    UPDATE Studenci\n    SET Wiek = 26\n    WHERE NrIndeksu = 12345;\nEND;\n/\nmożna grupować wiele operacji w jednym bloku, co ułatwia zarządzanie spójnością danych.",
    "crumbs": [
      "Książki",
      "Wykłady",
      "WYKŁAD 4 – Podstawy PL/SQL, transakcje i indeksy"
    ]
  },
  {
    "objectID": "lectures/wyklad4.html#przetwarzanie-transakcyjne",
    "href": "lectures/wyklad4.html#przetwarzanie-transakcyjne",
    "title": "WYKŁAD 4 – Podstawy PL/SQL, transakcje i indeksy",
    "section": "3️⃣ Przetwarzanie transakcyjne",
    "text": "3️⃣ Przetwarzanie transakcyjne\n\n🔹 Co to jest transakcja?\nTransakcja to jednostka pracy w bazie danych, która:\n\nwykonuje kilka operacji jako całość,\njest atomowa – albo wszystkie operacje się powiodą, albo żadna,\nzapewnia spójność danych (ACID).\n\n\n\n🔹 Polecenia transakcyjne\n\nCOMMIT – zatwierdza wszystkie zmiany wykonane w transakcji.\nROLLBACK – wycofuje wszystkie zmiany od ostatniego commit.\nSAVEPOINT – pozwala ustawić punkt częściowego cofnięcia.\n\nPrzykład użycia transakcji:\nBEGIN\n    INSERT INTO Studenci VALUES(12346, 'Anna', 'Kowalska', 21);\n    UPDATE Kursy SET IloscMiejsc = IloscMiejsc - 1 WHERE KursID = 10;\n    COMMIT;\nEND;\n/\nobie operacje – wstawienie studenta i zmniejszenie liczby miejsc – zostaną zatwierdzone jednocześnie. Jeśli jedna się nie powiedzie, można użyć ROLLBACK, aby przywrócić stan poprzedni.",
    "crumbs": [
      "Książki",
      "Wykłady",
      "WYKŁAD 4 – Podstawy PL/SQL, transakcje i indeksy"
    ]
  },
  {
    "objectID": "lectures/wyklad4.html#indeksy-w-bazie-danych",
    "href": "lectures/wyklad4.html#indeksy-w-bazie-danych",
    "title": "WYKŁAD 4 – Podstawy PL/SQL, transakcje i indeksy",
    "section": "4️⃣ Indeksy w bazie danych",
    "text": "4️⃣ Indeksy w bazie danych\n\n🔹 Co to jest indeks?\n\nIndeks to struktura danych, która przyspiesza wyszukiwanie rekordów w tabeli.\nDziała podobnie jak spis treści w książce.\n\nPrzykład tworzenia indeksu:\nCREATE INDEX idx_studenci_nazwisko\nON Studenci(Nazwisko);\nndeks przyspiesza wyszukiwanie po kolumnie Nazwisko. Nie zawsze każdy indeks jest potrzebny – zbyt wiele indeksów spowalnia operacje INSERT/UPDATE/DELETE.\n\n\n🔹 Rodzaje indeksów\n\nJedno-kolumnowe – indeks na jednej kolumnie.\nWielokolumnowe (composite) – indeks na kilku kolumnach razem.\nUnikalne – zapewniają unikalność wartości w kolumnie.\n\nDobór indeksów wymaga analizy typowych zapytań w systemie, aby zwiększyć wydajność.",
    "crumbs": [
      "Książki",
      "Wykłady",
      "WYKŁAD 4 – Podstawy PL/SQL, transakcje i indeksy"
    ]
  },
  {
    "objectID": "lectures/wyklad3.html",
    "href": "lectures/wyklad3.html",
    "title": "Normalizacja i projektowanie baz danych",
    "section": "",
    "text": "Celem wykładu jest pokazanie, jak unikać błędów podczas projektowania relacyjnych baz danych poprzez stosowanie zasad normalizacji, zrozumienie zależności funkcjonalnych oraz wykorzystanie diagramów ERD (Entity–Relationship Diagram).",
    "crumbs": [
      "Książki",
      "Wykłady",
      "Normalizacja i projektowanie baz danych"
    ]
  },
  {
    "objectID": "lectures/wyklad3.html#temat-jak-uniknąć-błędów-w-projektowaniu",
    "href": "lectures/wyklad3.html#temat-jak-uniknąć-błędów-w-projektowaniu",
    "title": "Normalizacja i projektowanie baz danych",
    "section": "",
    "text": "Celem wykładu jest pokazanie, jak unikać błędów podczas projektowania relacyjnych baz danych poprzez stosowanie zasad normalizacji, zrozumienie zależności funkcjonalnych oraz wykorzystanie diagramów ERD (Entity–Relationship Diagram).",
    "crumbs": [
      "Książki",
      "Wykłady",
      "Normalizacja i projektowanie baz danych"
    ]
  },
  {
    "objectID": "lectures/wyklad3.html#cele-wykładu",
    "href": "lectures/wyklad3.html#cele-wykładu",
    "title": "Normalizacja i projektowanie baz danych",
    "section": "🧠 Cele wykładu",
    "text": "🧠 Cele wykładu\n\nnauczenie zasad normalizacji relacyjnych baz danych,\n\nzrozumienie pojęcia zależności funkcjonalnych,\n\nwprowadzenie do diagramów ERD jako narzędzia modelowania danych.",
    "crumbs": [
      "Książki",
      "Wykłady",
      "Normalizacja i projektowanie baz danych"
    ]
  },
  {
    "objectID": "lectures/wyklad3.html#problemy-złego-projektu-bazy-danych",
    "href": "lectures/wyklad3.html#problemy-złego-projektu-bazy-danych",
    "title": "Normalizacja i projektowanie baz danych",
    "section": "1. Problemy złego projektu bazy danych",
    "text": "1. Problemy złego projektu bazy danych\nZłe zaprojektowanie struktury bazy danych prowadzi do wielu problemów:\n\n🔹 Redundancja danych\nTo powielanie tych samych informacji w różnych miejscach bazy.\nPrzykład: jeśli w każdej tabeli z zamówieniami przechowujemy pełne dane klienta, to zmiana jego adresu wymaga aktualizacji wielu rekordów.\n\n\n🔹 Anomalie danych\nBłędy i niekonsekwencje wynikające z nadmiarowej struktury danych.\n\nAnomalia aktualizacji – zmiana jednej informacji wymaga wielu modyfikacji.\nNp. zmiana nazwiska wykładowcy w kilku wierszach tabeli.\nAnomalia wstawiania – brak możliwości dodania danych bez istnienia innych.\nNp. nie można dodać nowego kursu, dopóki nie zapisze się na niego student.\nAnomalia usuwania – usunięcie rekordu powoduje utratę innych informacji.\nNp. usunięcie ostatniego studenta z kursu powoduje utratę danych o samym kursie.\n\n👉 Wniosek: błędy projektowe utrudniają utrzymanie spójności danych.",
    "crumbs": [
      "Książki",
      "Wykłady",
      "Normalizacja i projektowanie baz danych"
    ]
  },
  {
    "objectID": "lectures/wyklad3.html#zależności-funkcjonalne",
    "href": "lectures/wyklad3.html#zależności-funkcjonalne",
    "title": "Normalizacja i projektowanie baz danych",
    "section": "2. Zależności funkcjonalne",
    "text": "2. Zależności funkcjonalne\n\n🔹 Definicja\nZależność funkcjonalna (ang. functional dependency) opisuje relację między atrybutami w tabeli.\nMówimy, że atrybut B jest funkcyjnie zależny od atrybutu A (zapis:\nA → B), jeśli każdej wartości A odpowiada dokładnie jedna wartość B.\n\n\n🔹 Przykłady\n\nNrIndeksu → Imię, Nazwisko, Kierunek\n(każdy numer indeksu jednoznacznie identyfikuje studenta)\nKurs → Sala, Prowadzący\n(dany kurs odbywa się zawsze w tej samej sali, prowadzony przez tę samą osobę)\n\n\n\n🔹 Klucze\n\nKlucz główny (primary key) – jednoznacznie identyfikuje wiersz tabeli.\n\nKlucz kandydujący (candidate key) – minimalny zestaw atrybutów, który może być kluczem.\n\nKlucz obcy (foreign key) – wskazuje na klucz główny w innej tabeli i tworzy powiązanie między tabelami.\n\n\n\n🔹 Typy zależności\n\nZależność pełna – atrybut zależy od całego klucza złożonego.\n\nZależność częściowa – atrybut zależy tylko od części klucza.\n\nZależność przechodnia – atrybut zależy pośrednio od klucza (A → B → C).",
    "crumbs": [
      "Książki",
      "Wykłady",
      "Normalizacja i projektowanie baz danych"
    ]
  },
  {
    "objectID": "lectures/wyklad3.html#formy-normalne-1nf-3nf-bcnf",
    "href": "lectures/wyklad3.html#formy-normalne-1nf-3nf-bcnf",
    "title": "Normalizacja i projektowanie baz danych",
    "section": "3. Formy normalne (1NF – 3NF, BCNF)",
    "text": "3. Formy normalne (1NF – 3NF, BCNF)\nNormalizacja to proces przekształcania tabel w taki sposób, aby usunąć redundancję i zapobiec anomaliom.\n\n🧩 Pierwsza postać normalna (1NF)\n\nWszystkie wartości w tabeli są atomowe (niepodzielne).\n\nBrak list, zbiorów lub kolumn powtarzających się.\n\n✅ Każda kolumna ma jedną wartość w komórce.\nPrzykład (naruszenie 1NF): | Student | NrIndeksu | Kursy | |———-|————|——–| | Jan Nowak | 12345 | Bazy danych, Programowanie |\n✅ Poprawnie:\nTworzymy osobną tabelę STUDENT_KURS, gdzie każdy kurs to osobny rekord.\n\n\n\n🧩 Druga postać normalna (2NF)\n\nTabela jest w 1NF i wszystkie atrybuty niekluczowe zależą w pełni od całego klucza głównego.\n\nDotyczy tabel z kluczem złożonym.\n\nPrzykład:\nTabela ZAPISY(StudentID, KursID, Sala)\n→ atrybut Sala zależy tylko od KursID, a nie od całego klucza (StudentID, KursID).\nRozwiązanie: wydziel tabelę KURS(KursID, Sala).\n\n\n\n🧩 Trzecia postać normalna (3NF)\n\nTabela jest w 2NF i nie zawiera zależności przechodnich.\n\nKażdy atrybut niekluczowy zależy bezpośrednio od klucza głównego.\n\nPrzykład:\nNrIndeksu → Kierunek, Kierunek → Dziekan\n➡️ Dziekan zależy pośrednio od NrIndeksu.\nRozwiązanie: osobna tabela KIERUNEK(Dziekan, Kierunek).\n\n\n\n🧩 Postać Boyce’a-Codda (BCNF)\n\nDla każdej zależności A → B, zbiór A musi być kluczem kandydującym.\n\nBardziej restrykcyjna niż 3NF – eliminuje wszelkie potencjalne redundancje.",
    "crumbs": [
      "Książki",
      "Wykłady",
      "Normalizacja i projektowanie baz danych"
    ]
  },
  {
    "objectID": "lectures/wyklad3.html#diagramy-erd-entityrelationship-diagram",
    "href": "lectures/wyklad3.html#diagramy-erd-entityrelationship-diagram",
    "title": "Normalizacja i projektowanie baz danych",
    "section": "4. Diagramy ERD (Entity–Relationship Diagram)",
    "text": "4. Diagramy ERD (Entity–Relationship Diagram)\nDiagram ERD jest graficznym sposobem przedstawienia modelu konceptualnego bazy danych.\n\n🔹 Główne elementy ERD\n\nEncja (Entity) – obiekt, o którym przechowujemy dane (np. Student, Kurs).\n\nAtrybut (Attribute) – właściwość encji (np. Imię, Nazwisko, NrIndeksu).\n\nRelacja (Relationship) – powiązanie między encjami (np. Student zapisuje się na Kurs).\n\nKardynalność (Cardinality) – określa liczność relacji:\n\n1:1 (jeden do jednego)\n\n1:N (jeden do wielu)\n\nN:M (wielu do wielu)\n\n\nIdentyfikator (Primary Key) – atrybut jednoznacznie identyfikujący encję.\n\n\n\n🔹 Przykład:\nSTUDENT (NrIndeksu, Imię, Nazwisko, Kierunek)\nKURS (KursID, Nazwa, Prowadzący)\nZAPIS (NrIndeksu, KursID, DataZapisu)\nRelacja między STUDENT a KURS: N:M poprzez encję pośredniczącą ZAPIS.",
    "crumbs": [
      "Książki",
      "Wykłady",
      "Normalizacja i projektowanie baz danych"
    ]
  },
  {
    "objectID": "lectures/wyklad3.html#proces-projektowania-bazy-danych",
    "href": "lectures/wyklad3.html#proces-projektowania-bazy-danych",
    "title": "Normalizacja i projektowanie baz danych",
    "section": "5. Proces projektowania bazy danych",
    "text": "5. Proces projektowania bazy danych\nProjektowanie bazy to proces etapowy:\n\nAnaliza wymagań – zrozumienie, jakie dane są potrzebne i jakie operacje będą wykonywane.\n\nModel konceptualny – opis danych w postaci ERD.\n\nModel logiczny – zamiana modelu ERD na relacyjny schemat tabel.\n\nModel fizyczny – implementacja w konkretnym systemie DBMS (np. PostgreSQL, MySQL).",
    "crumbs": [
      "Książki",
      "Wykłady",
      "Normalizacja i projektowanie baz danych"
    ]
  },
  {
    "objectID": "lectures/wyklad3.html#akcent-praktyczny",
    "href": "lectures/wyklad3.html#akcent-praktyczny",
    "title": "Normalizacja i projektowanie baz danych",
    "section": "6. Akcent praktyczny",
    "text": "6. Akcent praktyczny\nĆwiczenie (do wykonania na zajęciach):\nZaprojektuj model bazy danych dla prostego systemu uczelnianego, obejmującego: - Studentów, - Kursy, - Wykładowców, - Zapis na kursy.\nPrzygotuj: 1. Diagram ERD,\n2. Schemat relacyjny po normalizacji (do 3NF).",
    "crumbs": [
      "Książki",
      "Wykłady",
      "Normalizacja i projektowanie baz danych"
    ]
  },
  {
    "objectID": "lectures/wyklad3.html#efekty-uczenia-się",
    "href": "lectures/wyklad3.html#efekty-uczenia-się",
    "title": "Normalizacja i projektowanie baz danych",
    "section": "🎓 Efekty uczenia się",
    "text": "🎓 Efekty uczenia się\nPo zakończeniu wykładu student: - rozumie pojęcia normalizacji i zależności funkcjonalnych,\n- potrafi rozpoznać błędy projektowe (redundancja, anomalie),\n- potrafi zaprojektować relacyjną bazę danych zgodnie z zasadami normalizacji,\n- zna podstawowe elementy diagramów ERD i proces projektowania bazy danych.\n\n💡 Wskazówka dla studentów:\nW praktyce dążymy do uzyskania trzeciej postaci normalnej (3NF).\nCzasami stosuje się denormalizację dla poprawy wydajności, ale tylko po wcześniejszym zrozumieniu skutków tego działania.",
    "crumbs": [
      "Książki",
      "Wykłady",
      "Normalizacja i projektowanie baz danych"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Informacje ogólne",
    "section": "",
    "text": "Kod:\nSemestr: letni",
    "crumbs": [
      "Książki",
      "Informacje ogólne"
    ]
  },
  {
    "objectID": "index.html#relacyjne-systemy-organizacji-danych",
    "href": "index.html#relacyjne-systemy-organizacji-danych",
    "title": "Informacje ogólne",
    "section": "",
    "text": "Kod:\nSemestr: letni",
    "crumbs": [
      "Książki",
      "Informacje ogólne"
    ]
  },
  {
    "objectID": "index.html#kalendarz",
    "href": "index.html#kalendarz",
    "title": "Informacje ogólne",
    "section": "Kalendarz",
    "text": "Kalendarz\n\nWykład dla grup: WEL23EV1S0, WEL23EA1S0\n\n\n09.10.2025 Czwartek Wykład 1 - b. 61 sala 116 (3-4)\n\n\n14.10.2025 Wtorek Wykład 2 - b. 61 sala 116 (9-10)\n\n\n15.10.2025 Środa Wykład 3 - b. 61 sala 116 (3-4)\n\n29.10.2025 Środa Wykład 4 - b. 61 sala 116 (9-10)\n30.10.2025 Czwartek Wykład 5 - b. 61 sala 116 (5-6)\n\n\n\nLaboratorium grupa WEL23EV1S0:\n\n25.11.2025 Wtorek - b. 61 sala 116\n04.12.2025 czwartek - b. 61 sala 116\n18.12.2025 czwartek - b. 61 sala 116\n08.01.2026 Czwartek - b. 61 sala 116\n22.01.2026 czwartek - b. 61 sala 116\n\n\n\nLaboratorium grupa WEL23EA1S0:\n\n13.11.2025 Czwartek Lab - b. 61 sala 116\n26.11.2025 środa Lab - b. 61 sala 116\n11.12.2025 czwartek - b. 61 sala 116\n15.01.2026 czwartek - b. 61 sala 116\n21.01.2026 środa - b. 61 sala 116",
    "crumbs": [
      "Książki",
      "Informacje ogólne"
    ]
  },
  {
    "objectID": "ksiazki.html",
    "href": "ksiazki.html",
    "title": "Książki i strony WWW",
    "section": "",
    "text": "C.J. Date, An Introduction to Database Systems\nR. Elmasri, S.B. Navathe, Fundamentals of Database Systems\nDokumentacja PostgreSQL: https://www.postgresql.org/docs/"
  },
  {
    "objectID": "ksiazki.html#książki",
    "href": "ksiazki.html#książki",
    "title": "Książki i strony WWW",
    "section": "",
    "text": "C.J. Date, An Introduction to Database Systems\nR. Elmasri, S.B. Navathe, Fundamentals of Database Systems\nDokumentacja PostgreSQL: https://www.postgresql.org/docs/"
  },
  {
    "objectID": "lectures/wyklad2.html",
    "href": "lectures/wyklad2.html",
    "title": "Model relacyjny i podstawy SQL",
    "section": "",
    "text": "Dane przechowywane są w tabelach (ang. relations).\n\nKażdy wiersz (row) to rekord / krotka.\n\nKażda kolumna (column) to atrybut.\n\nDziedzina (domain) to zbiór dopuszczalnych wartości w danej kolumnie.\n\nPrzykład relacji STUDENT:\n\n\n\nid\nimie\nnazwisko\nrok_urodzenia\n\n\n\n\n1\nAdam\nMickiewicz\n1798\n\n\n2\nHenryk\nSienkiewicz\n1846\n\n\n\n\n Schemat relacji: tabela STUDENT z kolumnami i wierszami\n\n\n\n\n\n\n\n\n\nUnikalnie identyfikuje każdy wiersz w tabeli.\n\nNie może przyjmować wartości NULL.\n\nW tabeli może występować tylko jeden klucz główny.\n\n\n\n\n\nTworzy powiązanie z inną tabelą.\n\nWymusza spójność danych – nie można wprowadzić wartości, której nie ma w tabeli nadrzędnej.\n\n\n\n\n\nUNIQUE – zapewnia unikalność wartości w kolumnie.\n\nNOT NULL – kolumna nie może przyjmować wartości pustych.\n\nCHECK – sprawdza warunek logiczny (np. wiek &gt; 0).\n\n\n\n\n\n\n\n\n\nRodzaj klucza\nOpis\nPrzykład\n\n\n\n\nKlucz główny (Primary Key)\njednoznacznie identyfikuje rekord\nNrIndeksu w STUDENT\n\n\nKlucz obcy (Foreign Key)\ntworzy powiązanie między tabelami\nKursID w tabeli ZAPIS\n\n\nKlucz kandydujący (Candidate Key)\natrybut, który może być kluczem głównym\nPESEL, NrIndeksu\n\n\nKlucz złożony (Composite Key)\nskłada się z kilku kolumn\n(StudentID, KursID)\n\n\n\n\n Schemat: klucz główny i klucz obcy między tabelami STUDENT, KURS, ZAPIS\n\n\n\n\n\n\nW relacyjnych bazach danych tabele łączy się przez klucze obce.\nNa tej podstawie tworzą się różne typy relacji:\n\n\n\n\n\n\n\n\nTyp relacji\nOpis\nPrzykład\n\n\n\n\n1:1 (jeden do jednego)\njeden rekord w tabeli A odpowiada dokładnie jednemu rekordowi w tabeli B\nStudent ↔︎️ Legitymacja\n\n\n1:N (jeden do wielu)\njeden rekord w tabeli A może być powiązany z wieloma rekordami w tabeli B\nWykładowca ↔︎️ Kursy\n\n\nN:M (wielu do wielu)\nwiele rekordów w A może być powiązanych z wieloma w B\nStudenci ↔︎️ Kursy\n\n\n\nRelację N:M realizuje się przez tabelę pośredniczącą, np.:\nSTUDENT (NrIndeksu, Imie, Nazwisko)\nKURS (KursID, Nazwa)\nZAPIS (NrIndeksu, KursID, DataZapisu)\nTabela ZAPIS zawiera klucze obce wskazujące na STUDENT i KURS.\n\n## 4️⃣ Wprowadzenie do języka SQL (Structured Query Language)\nSQL to standardowy język do definiowania, modyfikowania i pobierania danych w relacyjnych bazach danych.\n\n\n\n\n\n\n\n\nPodjęzyk\nOpis\nPrzykłady poleceń\n\n\n\n\nDDL (Data Definition Language)\ndefiniuje strukturę bazy\nCREATE TABLE, ALTER TABLE, DROP TABLE\n\n\nDML (Data Manipulation Language)\noperacje na danych\nINSERT, UPDATE, DELETE, SELECT\n\n\nDCL (Data Control Language)\nkontrola dostępu\nGRANT, REVOKE\n\n\nTCL (Transaction Control Language)\nkontrola transakcji\nCOMMIT, ROLLBACK\n\n\n\n\n\n\nPolecenie CREATE TABLE służy do utworzenia nowej tabeli w bazie danych.\nW tym poleceniu definiujemy nazwy kolumn, ich typy danych oraz różne więzy integralności, takie jak PRIMARY KEY, NOT NULL czy FOREIGN KEY.\nKażda tabela powinna mieć kolumnę, która jednoznacznie identyfikuje każdy wiersz – to właśnie klucz główny.\nW przykładzie poniżej tworzymy dwie tabele: Autorzy i Ksiazki, które będą ze sobą powiązane relacją klucz główny–klucz obcy.\n\n\n\n\nCREATE TABLE Autorzy (\n    autor_id     INTEGER PRIMARY KEY,         -- w SQLite automatycznie AUTOINCREMENT\n    imie         TEXT NOT NULL,\n    nazwisko     TEXT NOT NULL\n);\n\nCREATE TABLE Ksiazki (\n    ksiazka_id   SERIAL PRIMARY KEY,          -- PostgreSQL: automatyczna numeracja\n    tytul        VARCHAR(200) NOT NULL,\n    rok          INTEGER CHECK (rok &gt; 0),\n    autor_id     INTEGER,\n    FOREIGN KEY (autor_id) REFERENCES Autorzy(autor_id)\n);\n\nW SQLite INTEGER PRIMARY KEY = alias dla AUTOINCREMENT.\nW PostgreSQL używamy SERIAL lub GENERATED ALWAYS AS IDENTITY.\n\nW powyższym przykładzie:\n\ntabela Autorzy przechowuje dane o autorach,\ntabela Ksiazki przechowuje dane o książkach,\nkolumna autor_id w Ksiazki to klucz obcy, który wskazuje autora.\n\nDzięki więzom integralności baza pilnuje, by każda książka miała poprawnego autora. Takie powiązania są podstawą modelu relacyjnego.\n\n\n\n\n\n\nALTER TABLE Ksiazki ADD COLUMN gatunek TEXT;\n\n\n\nALTER TABLE STUDENT ALTER COLUMN Kierunek TYPE VARCHAR(100);\n\n\n\nALTER TABLE STUDENT DROP COLUMN Email;\n\n\n\nDROP TABLE Ksiazki;\n\n\n\n\nPolecenie INSERT INTO służy do wprowadzania nowych wierszy (rekordów) do tabeli. Wartości muszą być zgodne z typami kolumn oraz ograniczeniami (NOT NULL, CHECK, itp.).\nMożna dodać jeden lub wiele rekordów w jednym poleceniu.\nINSERT INTO Autorzy (imie, nazwisko) VALUES\n('Adam', 'Mickiewicz'),\n('Henryk', 'Sienkiewicz'),\n('Bolesław', 'Prus');\n\nINSERT INTO Ksiazki (tytul, rok, autor_id) VALUES\n('Pan Tadeusz', 1834, 1),\n('Quo Vadis', 1896, 2),\n('Lalka', 1890, 3);\nKażdy rekord reprezentuje jedną pozycję w tabeli. Polecenie INSERT wymaga podania wartości w tej samej kolejności, w jakiej wymieniono kolumny. Jeśli nie podamy jakiejś kolumny, a ma ona zdefiniowaną wartość domyślną (DEFAULT), baza wstawi ją automatycznie.\n\n\n\n\n\nSELECT * FROM Autorzy;\nPowyższe zapytanie zwraca wszystkich autorów z tabeli Autorzy.\n\n\n\n\nSELECT imie, nazwisko FROM Autorzy;\n\n\n\nSELECT imie AS \"Imię\", nazwisko AS \"Nazwisko\" FROM Autorzy;\nAlias (AS) pozwala nadać kolumnom bardziej opisowe nazwy w wynikach.\n\n\n\n\nSELECT * FROM Ksiazki\nWHERE rok &gt; 1850;\n\n\n\n= , &lt;&gt;, &lt;, &gt;, &lt;=, &gt;=\nLIKE ‘Q%’ → zaczyna się na Q\nIN (…)\nBETWEEN 1800 AND 1900\nIS NULL, IS NOT NULL\n\nPrzykład wyszukiwania książek zawierających literę “a” w tytule:\nSELECT tytul FROM Ksiazki WHERE tytul LIKE '%a%';\n\n\n\n\nSELECT * FROM Ksiazki ORDER BY rok DESC;\nSortowanie wyników można wykonać według dowolnej kolumny. Domyślnie ORDER BY sortuje rosnąco (ASC). Dla kilku kolumn można napisać np.:\nSELECT * FROM Ksiazki ORDER BY autor_id ASC, rok DESC;\n\n\n\nSELECT autor_id, COUNT(*) AS liczba_ksiazek\nFROM Ksiazki\nGROUP BY autor_id\nHAVING COUNT(*) &gt; 1;\nKlauzula GROUP BY grupuje dane, a HAVING filtruje grupy po agregacji. Funkcje agregujące: COUNT(), SUM(), AVG(), MIN(), MAX().\n\n\n\n\n\nSELECT k.tytul, a.imie, a.nazwisko\nFROM Ksiazki k\nJOIN Autorzy a ON k.autor_id = a.autor_id;\n\n\n\nSELECT k.tytul, a.imie, a.nazwisko\nFROM Ksiazki k\nLEFT JOIN Autorzy a ON k.autor_id = a.autor_id;\nINNER JOIN zwraca tylko dopasowane rekordy, LEFT JOIN – wszystkie rekordy z lewej tabeli (nawet bez dopasowania).\n\n\n\n\n\n\nUPDATE Ksiazki SET rok = 1836 WHERE tytul = 'Pan Tadeusz';\n\n\n\nDELETE FROM Ksiazki WHERE rok &lt; 1850;\nZawsze należy używać WHERE, aby nie zmodyfikować lub nie usunąć wszystkich rekordów.\n\n\n\n\nSQL jest językiem deklaratywnym – opisujemy co chcemy uzyskać, a nie jak to zrobić. Dzięki temu użytkownik nie musi znać szczegółów działania bazy danych.\nPoznane dziś polecenia:\nCREATE, INSERT, SELECT, UPDATE, DELETE, JOIN, GROUP BY\nto fundament pracy z bazami danych. Opanowanie ich pozwala budować i analizować nawet bardzo złożone systemy informacyjne.\n⸻\n\n\n\n•   Dokumentacja SQLite\n•   Dokumentacja PostgreSQL\n•   A. Silberschatz, H. Korth, S. Sudarshan, Database System Concepts",
    "crumbs": [
      "Książki",
      "Wykłady",
      "Model relacyjny i podstawy SQL"
    ]
  },
  {
    "objectID": "lectures/wyklad2.html#model-relacyjny-przypomnienie-i-pojęcia-podstawowe",
    "href": "lectures/wyklad2.html#model-relacyjny-przypomnienie-i-pojęcia-podstawowe",
    "title": "Model relacyjny i podstawy SQL",
    "section": "",
    "text": "Dane przechowywane są w tabelach (ang. relations).\n\nKażdy wiersz (row) to rekord / krotka.\n\nKażda kolumna (column) to atrybut.\n\nDziedzina (domain) to zbiór dopuszczalnych wartości w danej kolumnie.\n\nPrzykład relacji STUDENT:\n\n\n\nid\nimie\nnazwisko\nrok_urodzenia\n\n\n\n\n1\nAdam\nMickiewicz\n1798\n\n\n2\nHenryk\nSienkiewicz\n1846\n\n\n\n\n Schemat relacji: tabela STUDENT z kolumnami i wierszami",
    "crumbs": [
      "Książki",
      "Wykłady",
      "Model relacyjny i podstawy SQL"
    ]
  },
  {
    "objectID": "lectures/wyklad2.html#klucze-i-więzy-integralności",
    "href": "lectures/wyklad2.html#klucze-i-więzy-integralności",
    "title": "Model relacyjny i podstawy SQL",
    "section": "",
    "text": "Unikalnie identyfikuje każdy wiersz w tabeli.\n\nNie może przyjmować wartości NULL.\n\nW tabeli może występować tylko jeden klucz główny.\n\n\n\n\n\nTworzy powiązanie z inną tabelą.\n\nWymusza spójność danych – nie można wprowadzić wartości, której nie ma w tabeli nadrzędnej.\n\n\n\n\n\nUNIQUE – zapewnia unikalność wartości w kolumnie.\n\nNOT NULL – kolumna nie może przyjmować wartości pustych.\n\nCHECK – sprawdza warunek logiczny (np. wiek &gt; 0).\n\n\n\n\n\n\n\n\n\nRodzaj klucza\nOpis\nPrzykład\n\n\n\n\nKlucz główny (Primary Key)\njednoznacznie identyfikuje rekord\nNrIndeksu w STUDENT\n\n\nKlucz obcy (Foreign Key)\ntworzy powiązanie między tabelami\nKursID w tabeli ZAPIS\n\n\nKlucz kandydujący (Candidate Key)\natrybut, który może być kluczem głównym\nPESEL, NrIndeksu\n\n\nKlucz złożony (Composite Key)\nskłada się z kilku kolumn\n(StudentID, KursID)\n\n\n\n\n Schemat: klucz główny i klucz obcy między tabelami STUDENT, KURS, ZAPIS",
    "crumbs": [
      "Książki",
      "Wykłady",
      "Model relacyjny i podstawy SQL"
    ]
  },
  {
    "objectID": "lectures/wyklad2.html#rodzaje-związków-relacji-między-tabelami",
    "href": "lectures/wyklad2.html#rodzaje-związków-relacji-między-tabelami",
    "title": "Model relacyjny i podstawy SQL",
    "section": "",
    "text": "W relacyjnych bazach danych tabele łączy się przez klucze obce.\nNa tej podstawie tworzą się różne typy relacji:\n\n\n\n\n\n\n\n\nTyp relacji\nOpis\nPrzykład\n\n\n\n\n1:1 (jeden do jednego)\njeden rekord w tabeli A odpowiada dokładnie jednemu rekordowi w tabeli B\nStudent ↔︎️ Legitymacja\n\n\n1:N (jeden do wielu)\njeden rekord w tabeli A może być powiązany z wieloma rekordami w tabeli B\nWykładowca ↔︎️ Kursy\n\n\nN:M (wielu do wielu)\nwiele rekordów w A może być powiązanych z wieloma w B\nStudenci ↔︎️ Kursy\n\n\n\nRelację N:M realizuje się przez tabelę pośredniczącą, np.:\nSTUDENT (NrIndeksu, Imie, Nazwisko)\nKURS (KursID, Nazwa)\nZAPIS (NrIndeksu, KursID, DataZapisu)\nTabela ZAPIS zawiera klucze obce wskazujące na STUDENT i KURS.\n\n## 4️⃣ Wprowadzenie do języka SQL (Structured Query Language)\nSQL to standardowy język do definiowania, modyfikowania i pobierania danych w relacyjnych bazach danych.\n\n\n\n\n\n\n\n\nPodjęzyk\nOpis\nPrzykłady poleceń\n\n\n\n\nDDL (Data Definition Language)\ndefiniuje strukturę bazy\nCREATE TABLE, ALTER TABLE, DROP TABLE\n\n\nDML (Data Manipulation Language)\noperacje na danych\nINSERT, UPDATE, DELETE, SELECT\n\n\nDCL (Data Control Language)\nkontrola dostępu\nGRANT, REVOKE\n\n\nTCL (Transaction Control Language)\nkontrola transakcji\nCOMMIT, ROLLBACK\n\n\n\n\n\n\nPolecenie CREATE TABLE służy do utworzenia nowej tabeli w bazie danych.\nW tym poleceniu definiujemy nazwy kolumn, ich typy danych oraz różne więzy integralności, takie jak PRIMARY KEY, NOT NULL czy FOREIGN KEY.\nKażda tabela powinna mieć kolumnę, która jednoznacznie identyfikuje każdy wiersz – to właśnie klucz główny.\nW przykładzie poniżej tworzymy dwie tabele: Autorzy i Ksiazki, które będą ze sobą powiązane relacją klucz główny–klucz obcy.\n\n\n\n\nCREATE TABLE Autorzy (\n    autor_id     INTEGER PRIMARY KEY,         -- w SQLite automatycznie AUTOINCREMENT\n    imie         TEXT NOT NULL,\n    nazwisko     TEXT NOT NULL\n);\n\nCREATE TABLE Ksiazki (\n    ksiazka_id   SERIAL PRIMARY KEY,          -- PostgreSQL: automatyczna numeracja\n    tytul        VARCHAR(200) NOT NULL,\n    rok          INTEGER CHECK (rok &gt; 0),\n    autor_id     INTEGER,\n    FOREIGN KEY (autor_id) REFERENCES Autorzy(autor_id)\n);\n\nW SQLite INTEGER PRIMARY KEY = alias dla AUTOINCREMENT.\nW PostgreSQL używamy SERIAL lub GENERATED ALWAYS AS IDENTITY.\n\nW powyższym przykładzie:\n\ntabela Autorzy przechowuje dane o autorach,\ntabela Ksiazki przechowuje dane o książkach,\nkolumna autor_id w Ksiazki to klucz obcy, który wskazuje autora.\n\nDzięki więzom integralności baza pilnuje, by każda książka miała poprawnego autora. Takie powiązania są podstawą modelu relacyjnego.",
    "crumbs": [
      "Książki",
      "Wykłady",
      "Model relacyjny i podstawy SQL"
    ]
  },
  {
    "objectID": "lectures/wyklad2.html#modyfikacja-i-usuwanie-tabel",
    "href": "lectures/wyklad2.html#modyfikacja-i-usuwanie-tabel",
    "title": "Model relacyjny i podstawy SQL",
    "section": "",
    "text": "ALTER TABLE Ksiazki ADD COLUMN gatunek TEXT;\n\n\n\nALTER TABLE STUDENT ALTER COLUMN Kierunek TYPE VARCHAR(100);\n\n\n\nALTER TABLE STUDENT DROP COLUMN Email;\n\n\n\nDROP TABLE Ksiazki;",
    "crumbs": [
      "Książki",
      "Wykłady",
      "Model relacyjny i podstawy SQL"
    ]
  },
  {
    "objectID": "lectures/wyklad2.html#wstawianie-danych-dml-data-manipulation-language",
    "href": "lectures/wyklad2.html#wstawianie-danych-dml-data-manipulation-language",
    "title": "Model relacyjny i podstawy SQL",
    "section": "",
    "text": "Polecenie INSERT INTO służy do wprowadzania nowych wierszy (rekordów) do tabeli. Wartości muszą być zgodne z typami kolumn oraz ograniczeniami (NOT NULL, CHECK, itp.).\nMożna dodać jeden lub wiele rekordów w jednym poleceniu.\nINSERT INTO Autorzy (imie, nazwisko) VALUES\n('Adam', 'Mickiewicz'),\n('Henryk', 'Sienkiewicz'),\n('Bolesław', 'Prus');\n\nINSERT INTO Ksiazki (tytul, rok, autor_id) VALUES\n('Pan Tadeusz', 1834, 1),\n('Quo Vadis', 1896, 2),\n('Lalka', 1890, 3);\nKażdy rekord reprezentuje jedną pozycję w tabeli. Polecenie INSERT wymaga podania wartości w tej samej kolejności, w jakiej wymieniono kolumny. Jeśli nie podamy jakiejś kolumny, a ma ona zdefiniowaną wartość domyślną (DEFAULT), baza wstawi ją automatycznie.",
    "crumbs": [
      "Książki",
      "Wykłady",
      "Model relacyjny i podstawy SQL"
    ]
  },
  {
    "objectID": "lectures/wyklad2.html#wybieranie-danych-select",
    "href": "lectures/wyklad2.html#wybieranie-danych-select",
    "title": "Model relacyjny i podstawy SQL",
    "section": "",
    "text": "SELECT * FROM Autorzy;\nPowyższe zapytanie zwraca wszystkich autorów z tabeli Autorzy.\n\n\n\n\nSELECT imie, nazwisko FROM Autorzy;\n\n\n\nSELECT imie AS \"Imię\", nazwisko AS \"Nazwisko\" FROM Autorzy;\nAlias (AS) pozwala nadać kolumnom bardziej opisowe nazwy w wynikach.",
    "crumbs": [
      "Książki",
      "Wykłady",
      "Model relacyjny i podstawy SQL"
    ]
  },
  {
    "objectID": "lectures/wyklad2.html#filtrowanie-where",
    "href": "lectures/wyklad2.html#filtrowanie-where",
    "title": "Model relacyjny i podstawy SQL",
    "section": "",
    "text": "SELECT * FROM Ksiazki\nWHERE rok &gt; 1850;\n\n\n\n= , &lt;&gt;, &lt;, &gt;, &lt;=, &gt;=\nLIKE ‘Q%’ → zaczyna się na Q\nIN (…)\nBETWEEN 1800 AND 1900\nIS NULL, IS NOT NULL\n\nPrzykład wyszukiwania książek zawierających literę “a” w tytule:\nSELECT tytul FROM Ksiazki WHERE tytul LIKE '%a%';",
    "crumbs": [
      "Książki",
      "Wykłady",
      "Model relacyjny i podstawy SQL"
    ]
  },
  {
    "objectID": "lectures/wyklad2.html#sortowanie-order-by",
    "href": "lectures/wyklad2.html#sortowanie-order-by",
    "title": "Model relacyjny i podstawy SQL",
    "section": "",
    "text": "SELECT * FROM Ksiazki ORDER BY rok DESC;\nSortowanie wyników można wykonać według dowolnej kolumny. Domyślnie ORDER BY sortuje rosnąco (ASC). Dla kilku kolumn można napisać np.:\nSELECT * FROM Ksiazki ORDER BY autor_id ASC, rok DESC;",
    "crumbs": [
      "Książki",
      "Wykłady",
      "Model relacyjny i podstawy SQL"
    ]
  },
  {
    "objectID": "lectures/wyklad2.html#grupowanie-i-agregacja-group-by-having",
    "href": "lectures/wyklad2.html#grupowanie-i-agregacja-group-by-having",
    "title": "Model relacyjny i podstawy SQL",
    "section": "",
    "text": "SELECT autor_id, COUNT(*) AS liczba_ksiazek\nFROM Ksiazki\nGROUP BY autor_id\nHAVING COUNT(*) &gt; 1;\nKlauzula GROUP BY grupuje dane, a HAVING filtruje grupy po agregacji. Funkcje agregujące: COUNT(), SUM(), AVG(), MIN(), MAX().",
    "crumbs": [
      "Książki",
      "Wykłady",
      "Model relacyjny i podstawy SQL"
    ]
  },
  {
    "objectID": "lectures/wyklad2.html#łączenie-tabel-join",
    "href": "lectures/wyklad2.html#łączenie-tabel-join",
    "title": "Model relacyjny i podstawy SQL",
    "section": "",
    "text": "SELECT k.tytul, a.imie, a.nazwisko\nFROM Ksiazki k\nJOIN Autorzy a ON k.autor_id = a.autor_id;\n\n\n\nSELECT k.tytul, a.imie, a.nazwisko\nFROM Ksiazki k\nLEFT JOIN Autorzy a ON k.autor_id = a.autor_id;\nINNER JOIN zwraca tylko dopasowane rekordy, LEFT JOIN – wszystkie rekordy z lewej tabeli (nawet bez dopasowania).",
    "crumbs": [
      "Książki",
      "Wykłady",
      "Model relacyjny i podstawy SQL"
    ]
  },
  {
    "objectID": "lectures/wyklad2.html#aktualizacja-i-usuwanie-danych",
    "href": "lectures/wyklad2.html#aktualizacja-i-usuwanie-danych",
    "title": "Model relacyjny i podstawy SQL",
    "section": "",
    "text": "UPDATE Ksiazki SET rok = 1836 WHERE tytul = 'Pan Tadeusz';\n\n\n\nDELETE FROM Ksiazki WHERE rok &lt; 1850;\nZawsze należy używać WHERE, aby nie zmodyfikować lub nie usunąć wszystkich rekordów.",
    "crumbs": [
      "Książki",
      "Wykłady",
      "Model relacyjny i podstawy SQL"
    ]
  },
  {
    "objectID": "lectures/wyklad2.html#podsumowanie",
    "href": "lectures/wyklad2.html#podsumowanie",
    "title": "Model relacyjny i podstawy SQL",
    "section": "",
    "text": "SQL jest językiem deklaratywnym – opisujemy co chcemy uzyskać, a nie jak to zrobić. Dzięki temu użytkownik nie musi znać szczegółów działania bazy danych.\nPoznane dziś polecenia:\nCREATE, INSERT, SELECT, UPDATE, DELETE, JOIN, GROUP BY\nto fundament pracy z bazami danych. Opanowanie ich pozwala budować i analizować nawet bardzo złożone systemy informacyjne.\n⸻",
    "crumbs": [
      "Książki",
      "Wykłady",
      "Model relacyjny i podstawy SQL"
    ]
  },
  {
    "objectID": "lectures/wyklad2.html#źródła-i-literatura",
    "href": "lectures/wyklad2.html#źródła-i-literatura",
    "title": "Model relacyjny i podstawy SQL",
    "section": "",
    "text": "•   Dokumentacja SQLite\n•   Dokumentacja PostgreSQL\n•   A. Silberschatz, H. Korth, S. Sudarshan, Database System Concepts",
    "crumbs": [
      "Książki",
      "Wykłady",
      "Model relacyjny i podstawy SQL"
    ]
  },
  {
    "objectID": "lectures/wyklad1.html",
    "href": "lectures/wyklad1.html",
    "title": "Od pliku do bazy danych",
    "section": "",
    "text": "W tym module poznasz podstawowe pojęcia związane z danymi i bazami danych. Dowiesz się, czym różni się system plikowy od bazy danych, jak wygląda architektura systemu DBMS oraz dlaczego model relacyjny stał się standardem w przechowywaniu informacji.\nNa końcu wprowadzimy Cię w świat języka SQL – narzędzia, które pozwala komunikować się z bazą danych.\n⸻",
    "crumbs": [
      "Książki",
      "Wykłady",
      "Od pliku do bazy danych"
    ]
  },
  {
    "objectID": "lectures/wyklad1.html#cele-wykładu",
    "href": "lectures/wyklad1.html#cele-wykładu",
    "title": "Od pliku do bazy danych",
    "section": "",
    "text": "W tym module poznasz podstawowe pojęcia związane z danymi i bazami danych. Dowiesz się, czym różni się system plikowy od bazy danych, jak wygląda architektura systemu DBMS oraz dlaczego model relacyjny stał się standardem w przechowywaniu informacji.\nNa końcu wprowadzimy Cię w świat języka SQL – narzędzia, które pozwala komunikować się z bazą danych.\n⸻",
    "crumbs": [
      "Książki",
      "Wykłady",
      "Od pliku do bazy danych"
    ]
  },
  {
    "objectID": "lectures/wyklad1.html#dane-informacja-baza-danych",
    "href": "lectures/wyklad1.html#dane-informacja-baza-danych",
    "title": "Od pliku do bazy danych",
    "section": "1️⃣ Dane, informacja, baza danych",
    "text": "1️⃣ Dane, informacja, baza danych\n\n🔹 Dane\nNa początku warto zadać pytanie: czym właściwie są dane?\nDane to surowe fakty – liczby, teksty, symbole – które same w sobie nie mają znaczenia. Przykładowo, zapis:\n12345\nJan Kowalski\nBazy danych\nnie mówi nam jeszcze nic o tym, co oznacza. Może to być numer indeksu, nazwisko klienta albo temat zajęć.\n\n (np. piramida DIKW – Data, Information, Knowledge, Wisdom)\n\n\n\n🔹 Informacja\nInformacja powstaje wtedy, gdy dane zostaną zinterpretowane w określonym kontekście. Jeśli wiemy, że „12345” to numer indeksu studenta Jana Kowalskiego, który zapisał się na kurs Bazy danych, mamy już informację.\nW życiu codziennym często mamy mnóstwo danych (np. z mediów społecznościowych), ale niewiele z nich przekłada się na prawdziwą wiedzę.\n⸻\n\n\n🔹 Baza danych\nBaza danych (ang. database) to uporządkowany zbiór danych, przechowywany w sposób umożliwiający szybkie wyszukiwanie, aktualizację i kontrolę spójności. Można ją porównać do dobrze zorganizowanego archiwum, w którym każdy dokument ma swoje miejsce i jest łatwy do odnalezienia.\nWizualizacja bazy danych – zestaw powiązanych tabel w relacyjnym modelu danych.\n\n\n🔹 System zarządzania bazą danych (DBMS)\nSystem zarządzania bazą danych, czyli DBMS (Database Management System), to oprogramowanie pośredniczące między użytkownikiem a bazą danych.\nTo ono umożliwia:\n\ndefiniowanie struktur (np. tabel),\nprzechowywanie i wyszukiwanie danych,\nzapewnienie bezpieczeństwa i spójności,\nobsługę wielu użytkowników jednocześnie.\n\nDo najpopularniejszych DBMS należą: PostgreSQL, Oracle, MySQL, SQLite, MS SQL Server.",
    "crumbs": [
      "Książki",
      "Wykłady",
      "Od pliku do bazy danych"
    ]
  },
  {
    "objectID": "lectures/wyklad1.html#rodzaje-danych",
    "href": "lectures/wyklad1.html#rodzaje-danych",
    "title": "Od pliku do bazy danych",
    "section": "2️⃣ Rodzaje danych",
    "text": "2️⃣ Rodzaje danych\nW informatyce dane występują w różnych formach. Można je podzielić według stopnia strukturyzacji.\n\n🔸 Dane ustrukturyzowane\nTo dane zapisane w tabelach – każda kolumna ma nazwę i określony typ. Znajdujemy je np. w arkuszach kalkulacyjnych lub relacyjnych bazach danych.\n\n\n\nID\nImię\nNazwisko\nMiasto\n\n\n\n\n1\nAnna\nNowak\nKraków\n\n\n2\nJan\nKowalski\nWarszawa\n\n\n\n\n\n\n🔸 Dane półustrukturyzowane\nMają pewną strukturę, ale nie tak sztywną jak dane tabelaryczne.\nPrzykładem mogą być pliki JSON lub XML:\n{\n  \"imie\": \"Anna\",\n  \"miasto\": \"Kraków\",\n  \"zainteresowania\": [\"sport\", \"muzyka\"]\n}\n\n\n\n🔸 Dane nieustrukturyzowane\nTo dane, które nie mają jasno zdefiniowanej struktury — na przykład obrazy, pliki audio, wideo czy dokumenty PDF. Ich analiza wymaga specjalistycznych narzędzi (np. rozpoznawania obrazów lub przetwarzania języka naturalnego).\n⸻",
    "crumbs": [
      "Książki",
      "Wykłady",
      "Od pliku do bazy danych"
    ]
  },
  {
    "objectID": "lectures/wyklad1.html#pliki-jako-forma-przechowywania-danych",
    "href": "lectures/wyklad1.html#pliki-jako-forma-przechowywania-danych",
    "title": "Od pliku do bazy danych",
    "section": "3️⃣ Pliki jako forma przechowywania danych",
    "text": "3️⃣ Pliki jako forma przechowywania danych\nZanim powstały systemy baz danych, dane przechowywano w prostych plikach tekstowych.\nNa przykład w pliku CSV:\nID,Imię,Nazwisko,Miasto\n1,Anna,Nowak,Kraków\n2,Jan,Kowalski,Warszawa\n3,Piotr,Wiśniewski,Poznań\nChoć taki plik można łatwo otworzyć w Excelu, ma on liczne ograniczenia:\n\nbrak kontroli poprawności danych,\nbrak powiązań między plikami,\nbrak współbieżności przy edycji.\n\n\n## 4️⃣ Problemy pracy z plikami\nSystem plikowy działa poprawnie przy niewielkiej liczbie danych i prostych zastosowaniach. Wraz ze wzrostem ilości informacji i liczbą użytkowników pojawiają się jednak poważne ograniczenia, które utrudniają bezpieczne i efektywne zarządzanie danymi.\n\n⚠️ Typowe problemy\n\n\n\n\n\n\n\nProblem\nOpis\n\n\n\n\n🔁 Redundancja\nTe same dane pojawiają się w wielu miejscach (np. adres klienta powielony w każdym zamówieniu).\n\n\n⚠️ Niespójność\nRóżne wersje tej samej informacji w różnych plikach (np. inny numer telefonu u klienta w dwóch plikach).\n\n\n⛔ Brak współbieżności\nTrudności przy jednoczesnej edycji — ryzyko nadpisania zmian.\n\n\n❌ Brak kontroli dostępu\nBrak ról, uprawnień i mechanizmów audytu.\n\n\n🧩 Słaba integracja\nDane rozproszone po różnych formatach i miejscach, trudne do połączenia.\n\n\n\n\n Schemat: system plików z wieloma niespójnymi plikami vs. centralna baza danych\n\n\nPrzykład (plikowy):\nklienci.txt:\n1;Anna Nowak;Kraków\n2;Jan Kowalski;Warszawa\nzamowienia.txt:\n10;Laptop;1\n11;Monitor;2\n12;Kabel HDMI;1\nDziała to, ale jeśli zmienimy ID klienta lub nazwę produktu, powstaje trudność w utrzymaniu spójności.",
    "crumbs": [
      "Książki",
      "Wykłady",
      "Od pliku do bazy danych"
    ]
  },
  {
    "objectID": "lectures/wyklad1.html#od-pliku-do-bazy-danych",
    "href": "lectures/wyklad1.html#od-pliku-do-bazy-danych",
    "title": "Od pliku do bazy danych",
    "section": "5️⃣ Od pliku do bazy danych",
    "text": "5️⃣ Od pliku do bazy danych\nAby rozwiązać problemy związane z plikami płaskimi, wprowadzono koncepcję systemu zarządzania bazą danych (DBMS). Główne idee to:\n\ncentralne repozytorium danych,\nkontrolowany dostęp i uprawnienia,\nmechanizmy zapewniające spójność i integralność,\nobsługa współbieżności i transakcji,\nmożliwość zapytań (np. SQL) zamiast pełnego skanowania plików.\n\n\nPorównanie: plik CSV vs baza danych (SQL)\n\n\n\n\n\n\n\n\nCecha\nPlik CSV\nBaza danych (SQL)\n\n\n\n\nStruktura danych\nTekstowa, dowolna\nŚciśle zdefiniowana (kolumny, typy)\n\n\nSpójność danych\nNie\nZapewniana przez DBMS\n\n\nWspółbieżność\nBrak\nObsługiwana\n\n\nWyszukiwanie\nPełne skanowanie\nZapytania, indeksy\n\n\nBezpieczeństwo\nBrak\nKontrola dostępu\n\n\n\n\n Diagram: „Od pliku do bazy” – ewolucja sposobu przechowywania danych",
    "crumbs": [
      "Książki",
      "Wykłady",
      "Od pliku do bazy danych"
    ]
  },
  {
    "objectID": "lectures/wyklad1.html#różnice-w-przetwarzaniu-danych-przykład-porównawczy",
    "href": "lectures/wyklad1.html#różnice-w-przetwarzaniu-danych-przykład-porównawczy",
    "title": "Od pliku do bazy danych",
    "section": "6️⃣ Różnice w przetwarzaniu danych – przykład porównawczy",
    "text": "6️⃣ Różnice w przetwarzaniu danych – przykład porównawczy\nRodzaj przetwarzania zależy od typu danych:\n\n\n\n\n\n\n\n\n\nTyp danych\nPrzykład\nNarzędzie przetwarzania\nTypowe operacje\n\n\n\n\nTabelaryczne\nsprzedaż, klienci\nSQL, Excel\nsortowanie, sumowanie, filtracja\n\n\nTekstowe\nartykuły, maile\nwyszukiwanie pełnotekstowe\nindeksowanie, analiza słów\n\n\nObraz\nzdjęcia, wideo\nbiblioteki CV, AI\nklasyfikacja, rozpoznawanie obiektów\n\n\nDźwięk\nnagrania, mowa\nDSP, ML\nfiltracja, transkrypcja\n\n\n\n\nPytanie do dyskusji: Dlaczego dane tabelaryczne łatwo ująć w relacje, a dźwięk czy obraz — już nie?\n\n\n Ilustracja: porównanie przetwarzania danych tabelarycznych i multimedialnych",
    "crumbs": [
      "Książki",
      "Wykłady",
      "Od pliku do bazy danych"
    ]
  },
  {
    "objectID": "lectures/wyklad1.html#architektura-systemów-baz-danych-ansisparc",
    "href": "lectures/wyklad1.html#architektura-systemów-baz-danych-ansisparc",
    "title": "Od pliku do bazy danych",
    "section": "7️⃣ Architektura systemów baz danych (ANSI/SPARC)",
    "text": "7️⃣ Architektura systemów baz danych (ANSI/SPARC)\nAby osiągnąć niezależność danych od aplikacji, wprowadzono model trójwarstwowy ANSI/SPARC:\n\n\n\n\n\n\n\n\nPoziom\nOpis\nPrzykład\n\n\n\n\nZewnętrzny\nWidok użytkownika — sposób, w jaki konkretni użytkownicy widzą dane\nWidok „Studenci z kierunku Informatyka”\n\n\nLogiczny (koncepcyjny)\nGlobalna struktura danych — tabele, relacje, ograniczenia\nSchemat bazy uczelni\n\n\nWewnętrzny (fizyczny)\nFizyczne przechowywanie danych na dysku\nIndeksy, pliki danych, metody dostępu\n\n\n\n\n Schemat trójwarstwowy ANSI/SPARC: użytkownicy ↔︎ DBMS ↔︎ fizyczne dane\n\nKorzyści:\n\nniezależność logiczna danych (zmiana schematu logicznego nie musi wymagać zmian w aplikacjach),\nniezależność fizyczna danych (zmiana sposobu przechowywania nie wpływa na logikę aplikacji).",
    "crumbs": [
      "Książki",
      "Wykłady",
      "Od pliku do bazy danych"
    ]
  },
  {
    "objectID": "lectures/wyklad1.html#typy-baz-danych",
    "href": "lectures/wyklad1.html#typy-baz-danych",
    "title": "Od pliku do bazy danych",
    "section": "8️⃣ Typy baz danych",
    "text": "8️⃣ Typy baz danych\nW zależności od modelu danych i sposobu ich użycia wyróżniamy kilka typów baz:\n\n\n\n\n\n\n\n\nTyp bazy\nOpis\nPrzykład\n\n\n\n\nHierarchiczna\nDane ułożone w strukturę drzewa\nIMS (IBM)\n\n\nSieciowa\nRekordy połączone są w złożone grafy\nIDMS\n\n\nRelacyjna\nDane w tabelach, związki przez klucze\nPostgreSQL, MySQL\n\n\nObiektowa\nDane jako obiekty z metodami\nObjectDB\n\n\nDokumentowa (NoSQL)\nDane w formacie dokumentów (JSON)\nMongoDB, CouchDB\n\n\nGrafowa\nModele relacji jako węzły i krawędzie\nNeo4j\n\n\n\n\n Grafika: schematy — drzewo, sieć, tabela, graf\n\nUwaga: Model relacyjny jest najpowszechniej stosowany z uwagi na prostotę i solidne podstawy teoretyczne (algebra relacji).",
    "crumbs": [
      "Książki",
      "Wykłady",
      "Od pliku do bazy danych"
    ]
  },
  {
    "objectID": "lectures/wyklad1.html#historia-i-ewolucja-baz-danych",
    "href": "lectures/wyklad1.html#historia-i-ewolucja-baz-danych",
    "title": "Od pliku do bazy danych",
    "section": "9️⃣ Historia i ewolucja baz danych",
    "text": "9️⃣ Historia i ewolucja baz danych\nKrótka oś czasu najważniejszych etapów:\n\nSystemy plikowe (lata 50–60) — proste pliki, brak centralnej kontroli.\n\nPierwsze DBMS (lata 60–70) — centralizacja, lepsze zarządzanie danymi.\n\nModele hierarchiczne i sieciowe — stosowane w dużych organizacjach, lecz trudne w utrzymaniu.\n\nModel relacyjny (E. F. Codd, 1970) — rewolucja: tabele, relacje i algebra relacji.\n\nSQL i standaryzacja — język pozwalający na zdefiniowanie i manipulację danymi.\n\nNoSQL i chmura (XXI wiek) — elastyczność, skalowalność, nowe modele danych.\n\n\n Oś czasu: rozwój baz danych od plików do NoSQL i rozwiązań chmurowych",
    "crumbs": [
      "Książki",
      "Wykłady",
      "Od pliku do bazy danych"
    ]
  },
  {
    "objectID": "lectures/wyklad1.html#zalety-podejścia-relacyjnego",
    "href": "lectures/wyklad1.html#zalety-podejścia-relacyjnego",
    "title": "Od pliku do bazy danych",
    "section": "🔟 Zalety podejścia relacyjnego",
    "text": "🔟 Zalety podejścia relacyjnego\n\nredukcja redundancji poprzez normalizację i klucze,\n\nłatwość łączenia danych (JOINy),\n\nkontrola integralności (ograniczenia, klucze obce),\n\nmechanizmy bezpieczeństwa i wielodostępności,\n\nprzewidywalność i zgodność z formalnymi podstawami matematycznymi.\n\n\n Schemat relacji między tabelami: STUDENT → ZAPISY → KURS",
    "crumbs": [
      "Książki",
      "Wykłady",
      "Od pliku do bazy danych"
    ]
  },
  {
    "objectID": "lectures/wyklad1.html#wprowadzenie-do-języka-sql",
    "href": "lectures/wyklad1.html#wprowadzenie-do-języka-sql",
    "title": "Od pliku do bazy danych",
    "section": "1️⃣1️⃣ Wprowadzenie do języka SQL",
    "text": "1️⃣1️⃣ Wprowadzenie do języka SQL\nSQL (Structured Query Language) to standardowy język do komunikacji z relacyjnymi bazami danych. Dzieli się na kilka części:\n\nDDL (Data Definition Language) — definiowanie struktur (CREATE, ALTER, DROP),\n\nDML (Data Manipulation Language) — operacje na danych (SELECT, INSERT, UPDATE, DELETE),\n\nDCL (Data Control Language) — kontrola dostępu (GRANT, REVOKE),\n\nTCL (Transaction Control Language) — kontrola transakcji (COMMIT, ROLLBACK).",
    "crumbs": [
      "Książki",
      "Wykłady",
      "Od pliku do bazy danych"
    ]
  },
  {
    "objectID": "lectures/wyklad5.html",
    "href": "lectures/wyklad5.html",
    "title": "WYKŁAD 5 – Projektowanie interfejsu bazy danych i praktyczne wykorzystanie SQL/PL/SQL",
    "section": "",
    "text": "Celem wykładu jest pokazanie, jak projektować interfejs do bazy danych w środowisku programistycznym, integrować SQL i PL/SQL w aplikacjach oraz wykonywać typowe operacje na danych."
  },
  {
    "objectID": "lectures/wyklad5.html#temat-łączenie-bazy-danych-z-aplikacją-i-praktyczne-operacje",
    "href": "lectures/wyklad5.html#temat-łączenie-bazy-danych-z-aplikacją-i-praktyczne-operacje",
    "title": "WYKŁAD 5 – Projektowanie interfejsu bazy danych i praktyczne wykorzystanie SQL/PL/SQL",
    "section": "",
    "text": "Celem wykładu jest pokazanie, jak projektować interfejs do bazy danych w środowisku programistycznym, integrować SQL i PL/SQL w aplikacjach oraz wykonywać typowe operacje na danych."
  },
  {
    "objectID": "lectures/wyklad5.html#cele-wykładu",
    "href": "lectures/wyklad5.html#cele-wykładu",
    "title": "WYKŁAD 5 – Projektowanie interfejsu bazy danych i praktyczne wykorzystanie SQL/PL/SQL",
    "section": "🧠 Cele wykładu",
    "text": "🧠 Cele wykładu\nStudent po wykładzie będzie potrafił:\n\nprojektować podstawowy interfejs do bazy danych w wybranym środowisku (np. Python, Java, C#),\n\nkorzystać z połączeń bazodanowych (DB connection),\n\nwykonywać zapytania SQL i bloki PL/SQL z poziomu aplikacji,\n\nrozumieć podstawy zabezpieczania danych i transakcji w aplikacjach."
  },
  {
    "objectID": "lectures/wyklad5.html#projektowanie-interfejsu-bazy-danych",
    "href": "lectures/wyklad5.html#projektowanie-interfejsu-bazy-danych",
    "title": "WYKŁAD 5 – Projektowanie interfejsu bazy danych i praktyczne wykorzystanie SQL/PL/SQL",
    "section": "1️⃣ Projektowanie interfejsu bazy danych",
    "text": "1️⃣ Projektowanie interfejsu bazy danych\n\n🔹 Co to jest interfejs bazy danych?\n\nInterfejs to warstwa komunikacji między aplikacją a bazą danych.\n\nPozwala aplikacji wysyłać zapytania SQL, odbierać wyniki i przetwarzać je w logice biznesowej.\n\n\n\n🔹 Główne elementy interfejsu\n\nPołączenie z bazą danych – obiekt, który umożliwia komunikację z serwerem DB.\n\nWysyłanie zapytań – wykonanie SELECT, INSERT, UPDATE, DELETE lub wywołań procedur PL/SQL.\n\nObsługa wyników – pobieranie danych w formie rekordów lub tabel.\n\nZarządzanie transakcjami – commit, rollback.\n\nOpis słowny: interfejs bazy działa jak most między programem a fizyczną bazą danych. Bez niego aplikacja nie „wie”, gdzie i jak przechowywane są dane."
  },
  {
    "objectID": "lectures/wyklad5.html#przykład-połączenie-do-bazy-w-pythonie",
    "href": "lectures/wyklad5.html#przykład-połączenie-do-bazy-w-pythonie",
    "title": "WYKŁAD 5 – Projektowanie interfejsu bazy danych i praktyczne wykorzystanie SQL/PL/SQL",
    "section": "2️⃣ Przykład – połączenie do bazy w Pythonie",
    "text": "2️⃣ Przykład – połączenie do bazy w Pythonie\nimport cx_Oracle\n\n# Nawiązanie połączenia\nconn = cx_Oracle.connect('uzytkownik/haslo@localhost/XE')\ncursor = conn.cursor()\n\n# Wykonanie zapytania SELECT\ncursor.execute(\"SELECT imie, nazwisko FROM Studenci\")\nfor row in cursor:\n    print(f\"Student: {row[0]} {row[1]}\")\n\n# Zamknięcie połączenia\ncursor.close()\nconn.close()\nkod pokazuje, jak w Pythonie połączyć się z bazą Oracle, pobrać dane i je wyświetlić."
  },
  {
    "objectID": "lectures/wyklad5.html#wykonywanie-operacji-sql-i-plsql-w-aplikacji",
    "href": "lectures/wyklad5.html#wykonywanie-operacji-sql-i-plsql-w-aplikacji",
    "title": "WYKŁAD 5 – Projektowanie interfejsu bazy danych i praktyczne wykorzystanie SQL/PL/SQL",
    "section": "3️⃣ Wykonywanie operacji SQL i PL/SQL w aplikacji",
    "text": "3️⃣ Wykonywanie operacji SQL i PL/SQL w aplikacji\n🔹 Operacje SQL\n\nINSERT – dodawanie nowych rekordów.\nUPDATE – modyfikacja istniejących danych.\nDELETE – usuwanie rekordów.\n\nPrzykład:\ncursor.execute(\"INSERT INTO Studenci VALUES (12347, 'Piotr', 'Nowak', 22)\")\nconn.commit()\nconn.commit() zatwierdza zmiany w bazie. Bez commit zmiany nie będą trwałe.\n\n🔹 Wywołanie procedury PL/SQL\ncursor.callproc(\"dodaj_studenta\", [12348, 'Anna', 'Kowalska', 21])\nconn.commit()\ncallproc pozwala wywołać procedury zapisane w bazie, co umożliwia automatyzację logiki biznesowej."
  },
  {
    "objectID": "lectures/wyklad5.html#obsługa-transakcji-w-aplikacjach",
    "href": "lectures/wyklad5.html#obsługa-transakcji-w-aplikacjach",
    "title": "WYKŁAD 5 – Projektowanie interfejsu bazy danych i praktyczne wykorzystanie SQL/PL/SQL",
    "section": "4️⃣ Obsługa transakcji w aplikacjach",
    "text": "4️⃣ Obsługa transakcji w aplikacjach\n\nTransakcje zapewniają spójność danych, nawet gdy aplikacja wykonuje wiele operacji jednocześnie.\nTypowy wzorzec:\n\nRozpocznij transakcję\nWykonaj operacje (INSERT, UPDATE, DELETE)\nW razie powodzenia: commit\nW razie błędu: rollback\n\n\nPrzykład w Pythonie:\ntry:\n    cursor.execute(\"UPDATE Kursy SET IloscMiejsc = IloscMiejsc - 1 WHERE KursID = 10\")\n    cursor.execute(\"INSERT INTO Studenci VALUES (12349, 'Kasia', 'Wiśniewska', 20)\")\n    conn.commit()\nexcept:\n    conn.rollback()\n    print(\"Wystąpił błąd, transakcja wycofana\")\nzięki transakcji zmiany są atomowe – albo wszystkie operacje się powiodą, albo żadna."
  },
  {
    "objectID": "lectures/wyklad5.html#indeksy-i-optymalizacja-zapytań-w-aplikacji",
    "href": "lectures/wyklad5.html#indeksy-i-optymalizacja-zapytań-w-aplikacji",
    "title": "WYKŁAD 5 – Projektowanie interfejsu bazy danych i praktyczne wykorzystanie SQL/PL/SQL",
    "section": "6️⃣ Indeksy i optymalizacja zapytań w aplikacji",
    "text": "6️⃣ Indeksy i optymalizacja zapytań w aplikacji\n\nIndeksy przyspieszają wyszukiwanie i filtrowanie danych w tabelach.\nW aplikacji warto zwracać uwagę na kolumny, po których najczęściej wyszukujemy.\n\nPrzykład w SQL:\nCREATE INDEX idx_student_nazwisko ON Studenci(Nazwisko);\nindeks może znacząco przyspieszyć SELECT w aplikacjach o dużych zbiorach danych, ale spowalnia INSERT/UPDATE."
  },
  {
    "objectID": "lectures/wyklad5.html#podsumowanie-wykładu",
    "href": "lectures/wyklad5.html#podsumowanie-wykładu",
    "title": "WYKŁAD 5 – Projektowanie interfejsu bazy danych i praktyczne wykorzystanie SQL/PL/SQL",
    "section": "7️⃣ Podsumowanie wykładu",
    "text": "7️⃣ Podsumowanie wykładu\n\n🔑 Kluczowe pojęcia:\n\nInterfejs bazy danych – połączenie między aplikacją a DBMS\nOperacje SQL i PL/SQL z poziomu aplikacji\nZarządzanie transakcjami dla spójności danych\nIndeksy i podstawowe zasady optymalizacji\n\n\n\n💡 Wskazówka:\nW praktyce projektowanie interfejsu wymaga zarówno znajomości bazy danych, jak i języka programowania. Dobrze zaprojektowana komunikacja z bazą zmniejsza liczbę błędów i zwiększa wydajność aplikacji."
  }
]