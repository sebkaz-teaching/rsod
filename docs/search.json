[
  {
    "objectID": "lectures/plan.html",
    "href": "lectures/plan.html",
    "title": "Relacyjne Systemy Organizacji Danych",
    "section": "",
    "text": "📙 WYKŁAD 3 – NORMALIZACJA I PROJEKTOWANIE BAZ DANYCH Temat: Jak uniknąć błędów w projektowaniu? Cele: nauczenie zasad normalizacji, zrozumienie zależności funkcjonalnych, wprowadzenie do diagramów ERD. Zakres treści: Problemy złego projektu: redundancja, anomalie aktualizacji, usuwania. Pojęcie zależności funkcjonalnych. Formy normalne (1NF–3NF, BCNF): przykłady i zastosowania. Diagramy ERD (Entity–Relationship Diagram): encje, atrybuty, relacje, kardynalności, identyfikatory. Proces projektowania bazy: analiza wymagań → model konceptualny → model logiczny → model fizyczny. Akcent praktyczny: ćwiczenie – model bazy danych dla systemu uczelnianego. Efekty uczenia się: potrafi projektować relacyjną bazę danych zgodnie z zasadami normalizacji. 📒 WYKŁAD 4 – TRANSAKCJE, WSPÓŁBIEŻNOŚĆ I WIDOKI Temat: Mechanizmy zapewniania spójności danych Cele: poznanie zasad transakcyjności, zrozumienie współbieżności i izolacji, wprowadzenie do widoków i ich zastosowań. Zakres treści: Pojęcie transakcji i właściwości ACID: atomicity, consistency, isolation, durability. Problemy współbieżności: utracone aktualizacje, odczyty brudnych danych, blokady. Poziomy izolacji transakcji. Widoki (Views): definicja, zalety (abstrakcja, bezpieczeństwo), przykłady CREATE VIEW, WITH CHECK OPTION. Przykład – transakcje w PostgreSQL (BEGIN/COMMIT/ROLLBACK). Akcent praktyczny: analiza równoczesnych transakcji na tej samej tabeli. Efekty uczenia się: rozumie zasady transakcyjności i umie zastosować widoki. 📕 WYKŁAD 5 – ADMINISTRACJA, BEZPIECZEŃSTWO I KOPIE ZAPASOWE Temat: Utrzymanie i ochrona baz danych Cele: poznanie zasad administrowania bazami danych, zrozumienie bezpieczeństwa i odporności systemów bazodanowych. Zakres treści: Role i uprawnienia użytkowników: GRANT, REVOKE, zarządzanie kontami. Bezpieczeństwo danych: szyfrowanie, kontrola dostępu, logowanie zdarzeń. Backup i odzyskiwanie: kopie pełne, przyrostowe, różnicowe, replikacja i wysokie dostępności (HA). Monitorowanie i optymalizacja: indeksy, analiza planów zapytań. Przegląd systemów bazodanowych: PostgreSQL, MySQL, SQLite, MS SQL, Oracle. Efekty uczenia się: zna metody ochrony i zarządzania bazami danych, potrafi wskazać strategie kopii zapasowych. 💡 PROJEKT ZALICZENIOWY (do realizacji na ćwiczeniach) Temat: Projekt i implementacja relacyjnej bazy danych wspierającej wybrany proces organizacyjny. Etapy projektu: Analiza problemu i identyfikacja wymagań. (np. system rezerwacji sal, ewidencja sprzętu, biblioteka, wypożyczalnia, rejestr studentów) Model konceptualny (ERD) i logiczny bazy danych. Implementacja bazy w wybranym systemie (np. PostgreSQL). Wypełnienie przykładowymi danymi, przygotowanie zapytań SQL. Demonstracja transakcji, widoków i podstawowych mechanizmów bezpieczeństwa. Efekty projektu: integracja wiedzy z zakresu modelowania, SQL i zarządzania, praktyczne umiejętności tworzenia bazy danych od podstaw, doświadczenie w pracy zespołowej i prezentacji wyników. 📈 POWIĄZANIE Z EFEKTAMI UCZENIA SIĘ Efekt uczenia się Odniesienie do wykładów / projektu Zna i rozumie algorytmy i metody w systemach BD Wykłady 2–5 Ma wiedzę z zakresu przetwarzania danych Wykład 1, 2 Zna standardy stosowane w BD Wykłady 2, 5 Potrafi przygotować prezentację i prowadzić dyskusję Projekt zespołowy Umie wykorzystać modele w realizacji projektów BD Wykład 3 + projekt Integruje wiedzę techniczną i pozatechniczną Projekt (analiza potrzeb użytkownika) Określa priorytety w realizacji zadań Projekt – planowanie etapów\nnowe elementy"
  },
  {
    "objectID": "lectures/wyklad4.html",
    "href": "lectures/wyklad4.html",
    "title": "WYKŁAD 4 – Podstawy PL/SQL, transakcje i indeksy",
    "section": "",
    "text": "Celem wykładu jest wprowadzenie do języka proceduralnego PL/SQL, pokazanie zasad przetwarzania transakcyjnego w bazach danych oraz omówienie roli indeksów w przyspieszaniu wyszukiwania danych."
  },
  {
    "objectID": "lectures/wyklad4.html#temat-programowanie-w-plsql-i-podstawy-optymalizacji",
    "href": "lectures/wyklad4.html#temat-programowanie-w-plsql-i-podstawy-optymalizacji",
    "title": "WYKŁAD 4 – Podstawy PL/SQL, transakcje i indeksy",
    "section": "",
    "text": "Celem wykładu jest wprowadzenie do języka proceduralnego PL/SQL, pokazanie zasad przetwarzania transakcyjnego w bazach danych oraz omówienie roli indeksów w przyspieszaniu wyszukiwania danych."
  },
  {
    "objectID": "lectures/wyklad4.html#cele-wykładu",
    "href": "lectures/wyklad4.html#cele-wykładu",
    "title": "WYKŁAD 4 – Podstawy PL/SQL, transakcje i indeksy",
    "section": "🧠 Cele wykładu",
    "text": "🧠 Cele wykładu\nStudent po wykładzie będzie potrafił:\n\nzrozumieć różnice między SQL a PL/SQL,\n\npisać proste bloki PL/SQL do operowania na danych,\n\nzarządzać transakcjami (commit, rollback),\n\nrozumieć rolę i zasady tworzenia indeksów w bazie danych."
  },
  {
    "objectID": "lectures/wyklad4.html#wprowadzenie-do-plsql",
    "href": "lectures/wyklad4.html#wprowadzenie-do-plsql",
    "title": "WYKŁAD 4 – Podstawy PL/SQL, transakcje i indeksy",
    "section": "1️⃣ Wprowadzenie do PL/SQL",
    "text": "1️⃣ Wprowadzenie do PL/SQL\n\n🔹 Czym jest PL/SQL?\n\nPL/SQL to proceduralny język rozszerzający SQL w systemach Oracle i kompatybilnych.\n\nUmożliwia użycie instrukcji warunkowych, pętli, zmiennych i procedur, czego SQL nie oferuje w formie deklaratywnej.\n\nPrzykład prostego bloku PL/SQL:\nBEGIN\n    DBMS_OUTPUT.PUT_LINE('Witaj w świecie PL/SQL!');\nEND;\n/\nKod ten uruchamia blok proceduralny, który wypisuje komunikat.\nBEGIN rozpoczyna blok, END; kończy, a / uruchamia go w SQL*Plus.\n\n\n🔹 Zmienne i typy danych\nPL/SQL pozwala tworzyć zmienne i przypisywać im wartości.\nDECLARE\n    v_imie VARCHAR2(50);\n    v_wiek NUMBER;\nBEGIN\n    v_imie := 'Jan';\n    v_wiek := 25;\n    DBMS_OUTPUT.PUT_LINE('Student: ' || v_imie || ', wiek: ' || v_wiek);\nEND;\n/\nZmienne umożliwiają przechowywanie danych tymczasowo w trakcie wykonywania programu.\n\n\n🔹 Instrukcje warunkowe i pętle\nPL/SQL pozwala na użycie:\n\nIF…THEN…ELSE:\n\nIF v_wiek &gt;= 18 THEN\n    DBMS_OUTPUT.PUT_LINE('Pełnoletni');\nELSE\n    DBMS_OUTPUT.PUT_LINE('Niepełnoletni');\nEND IF;\n\nLOOP, WHILE, FOR – do powtarzania operacji:\n\nFOR i IN 1..5 LOOP\n    DBMS_OUTPUT.PUT_LINE('Liczba: ' || i);\nEND LOOP;\nInstrukcje warunkowe i pętle pozwalają w pełni programować logikę w bazie danych."
  },
  {
    "objectID": "lectures/wyklad4.html#operacje-na-danych-w-plsql",
    "href": "lectures/wyklad4.html#operacje-na-danych-w-plsql",
    "title": "WYKŁAD 4 – Podstawy PL/SQL, transakcje i indeksy",
    "section": "2️⃣ Operacje na danych w PL/SQL",
    "text": "2️⃣ Operacje na danych w PL/SQL\nPL/SQL umożliwia wykonywanie standardowych operacji SQL:\n\nINSERT, UPDATE, DELETE – bezpośrednio w blokach proceduralnych.\n\nPrzykład aktualizacji studenta:\nBEGIN\n    UPDATE Studenci\n    SET Wiek = 26\n    WHERE NrIndeksu = 12345;\nEND;\n/\nmożna grupować wiele operacji w jednym bloku, co ułatwia zarządzanie spójnością danych."
  },
  {
    "objectID": "lectures/wyklad4.html#przetwarzanie-transakcyjne",
    "href": "lectures/wyklad4.html#przetwarzanie-transakcyjne",
    "title": "WYKŁAD 4 – Podstawy PL/SQL, transakcje i indeksy",
    "section": "3️⃣ Przetwarzanie transakcyjne",
    "text": "3️⃣ Przetwarzanie transakcyjne\n\n🔹 Co to jest transakcja?\nTransakcja to jednostka pracy w bazie danych, która:\n\nwykonuje kilka operacji jako całość,\njest atomowa – albo wszystkie operacje się powiodą, albo żadna,\nzapewnia spójność danych (ACID).\n\n\n\n🔹 Polecenia transakcyjne\n\nCOMMIT – zatwierdza wszystkie zmiany wykonane w transakcji.\nROLLBACK – wycofuje wszystkie zmiany od ostatniego commit.\nSAVEPOINT – pozwala ustawić punkt częściowego cofnięcia.\n\nPrzykład użycia transakcji:\nBEGIN\n    INSERT INTO Studenci VALUES(12346, 'Anna', 'Kowalska', 21);\n    UPDATE Kursy SET IloscMiejsc = IloscMiejsc - 1 WHERE KursID = 10;\n    COMMIT;\nEND;\n/\nobie operacje – wstawienie studenta i zmniejszenie liczby miejsc – zostaną zatwierdzone jednocześnie. Jeśli jedna się nie powiedzie, można użyć ROLLBACK, aby przywrócić stan poprzedni."
  },
  {
    "objectID": "lectures/wyklad4.html#indeksy-w-bazie-danych",
    "href": "lectures/wyklad4.html#indeksy-w-bazie-danych",
    "title": "WYKŁAD 4 – Podstawy PL/SQL, transakcje i indeksy",
    "section": "4️⃣ Indeksy w bazie danych",
    "text": "4️⃣ Indeksy w bazie danych\n\n🔹 Co to jest indeks?\n\nIndeks to struktura danych, która przyspiesza wyszukiwanie rekordów w tabeli.\nDziała podobnie jak spis treści w książce.\n\nPrzykład tworzenia indeksu:\nCREATE INDEX idx_studenci_nazwisko\nON Studenci(Nazwisko);\nndeks przyspiesza wyszukiwanie po kolumnie Nazwisko. Nie zawsze każdy indeks jest potrzebny – zbyt wiele indeksów spowalnia operacje INSERT/UPDATE/DELETE.\n\n\n🔹 Rodzaje indeksów\n\nJedno-kolumnowe – indeks na jednej kolumnie.\nWielokolumnowe (composite) – indeks na kilku kolumnach razem.\nUnikalne – zapewniają unikalność wartości w kolumnie.\n\nDobór indeksów wymaga analizy typowych zapytań w systemie, aby zwiększyć wydajność."
  },
  {
    "objectID": "lectures/wyklad3.html",
    "href": "lectures/wyklad3.html",
    "title": "Normalizacja i projektowanie baz danych",
    "section": "",
    "text": "Celem wykładu jest pokazanie, jak unikać błędów podczas projektowania relacyjnych baz danych poprzez stosowanie zasad normalizacji, zrozumienie zależności funkcjonalnych oraz wykorzystanie diagramów ERD (Entity–Relationship Diagram).",
    "crumbs": [
      "Książki",
      "Wykłady",
      "Normalizacja i projektowanie baz danych"
    ]
  },
  {
    "objectID": "lectures/wyklad3.html#temat-jak-uniknąć-błędów-w-projektowaniu",
    "href": "lectures/wyklad3.html#temat-jak-uniknąć-błędów-w-projektowaniu",
    "title": "Normalizacja i projektowanie baz danych",
    "section": "",
    "text": "Celem wykładu jest pokazanie, jak unikać błędów podczas projektowania relacyjnych baz danych poprzez stosowanie zasad normalizacji, zrozumienie zależności funkcjonalnych oraz wykorzystanie diagramów ERD (Entity–Relationship Diagram).",
    "crumbs": [
      "Książki",
      "Wykłady",
      "Normalizacja i projektowanie baz danych"
    ]
  },
  {
    "objectID": "lectures/wyklad3.html#cele-wykładu",
    "href": "lectures/wyklad3.html#cele-wykładu",
    "title": "Normalizacja i projektowanie baz danych",
    "section": "🧠 Cele wykładu",
    "text": "🧠 Cele wykładu\n\nnauczenie zasad normalizacji relacyjnych baz danych,\n\nzrozumienie pojęcia zależności funkcjonalnych,\n\nwprowadzenie do diagramów ERD jako narzędzia modelowania danych.",
    "crumbs": [
      "Książki",
      "Wykłady",
      "Normalizacja i projektowanie baz danych"
    ]
  },
  {
    "objectID": "lectures/wyklad3.html#problemy-złego-projektu-bazy-danych",
    "href": "lectures/wyklad3.html#problemy-złego-projektu-bazy-danych",
    "title": "Normalizacja i projektowanie baz danych",
    "section": "1. Problemy złego projektu bazy danych",
    "text": "1. Problemy złego projektu bazy danych\nZłe zaprojektowanie struktury bazy danych prowadzi do wielu problemów:\n\n🔹 Redundancja danych\nTo powielanie tych samych informacji w różnych miejscach bazy.\nPrzykład: jeśli w każdej tabeli z zamówieniami przechowujemy pełne dane klienta, to zmiana jego adresu wymaga aktualizacji wielu rekordów.\n\n\n🔹 Anomalie danych\nBłędy i niekonsekwencje wynikające z nadmiarowej struktury danych.\n\nAnomalia aktualizacji – zmiana jednej informacji wymaga wielu modyfikacji.\nNp. zmiana nazwiska wykładowcy w kilku wierszach tabeli.\nAnomalia wstawiania – brak możliwości dodania danych bez istnienia innych.\nNp. nie można dodać nowego kursu, dopóki nie zapisze się na niego student.\nAnomalia usuwania – usunięcie rekordu powoduje utratę innych informacji.\nNp. usunięcie ostatniego studenta z kursu powoduje utratę danych o samym kursie.\n\n👉 Wniosek: błędy projektowe utrudniają utrzymanie spójności danych.",
    "crumbs": [
      "Książki",
      "Wykłady",
      "Normalizacja i projektowanie baz danych"
    ]
  },
  {
    "objectID": "lectures/wyklad3.html#zależności-funkcjonalne",
    "href": "lectures/wyklad3.html#zależności-funkcjonalne",
    "title": "Normalizacja i projektowanie baz danych",
    "section": "2. Zależności funkcjonalne",
    "text": "2. Zależności funkcjonalne\n\n🔹 Definicja\nZależność funkcjonalna (ang. functional dependency) opisuje relację między atrybutami w tabeli.\nMówimy, że atrybut B jest funkcyjnie zależny od atrybutu A (zapis:\nA → B), jeśli każdej wartości A odpowiada dokładnie jedna wartość B.\n\n\n🔹 Przykłady\n\nNrIndeksu → Imię, Nazwisko, Kierunek\n(każdy numer indeksu jednoznacznie identyfikuje studenta)\nKurs → Sala, Prowadzący\n(dany kurs odbywa się zawsze w tej samej sali, prowadzony przez tę samą osobę)\n\n\n\n🔹 Klucze\n\nKlucz główny (primary key) – jednoznacznie identyfikuje wiersz tabeli.\n\nKlucz kandydujący (candidate key) – minimalny zestaw atrybutów, który może być kluczem.\n\nKlucz obcy (foreign key) – wskazuje na klucz główny w innej tabeli i tworzy powiązanie między tabelami.\n\n\n\n🔹 Typy zależności\n\nZależność pełna – atrybut zależy od całego klucza złożonego.\n\nZależność częściowa – atrybut zależy tylko od części klucza.\n\nZależność przechodnia – atrybut zależy pośrednio od klucza (A → B → C).",
    "crumbs": [
      "Książki",
      "Wykłady",
      "Normalizacja i projektowanie baz danych"
    ]
  },
  {
    "objectID": "lectures/wyklad3.html#formy-normalne-1nf-3nf-bcnf",
    "href": "lectures/wyklad3.html#formy-normalne-1nf-3nf-bcnf",
    "title": "Normalizacja i projektowanie baz danych",
    "section": "3. Formy normalne (1NF – 3NF, BCNF)",
    "text": "3. Formy normalne (1NF – 3NF, BCNF)\nNormalizacja to proces przekształcania tabel w taki sposób, aby usunąć redundancję i zapobiec anomaliom.\n\n🧩 Pierwsza postać normalna (1NF)\n\nWszystkie wartości w tabeli są atomowe (niepodzielne).\n\nBrak list, zbiorów lub kolumn powtarzających się.\n\n✅ Każda kolumna ma jedną wartość w komórce.\nPrzykład (naruszenie 1NF): | Student | NrIndeksu | Kursy | |———-|————|——–| | Jan Nowak | 12345 | Bazy danych, Programowanie |\n✅ Poprawnie:\nTworzymy osobną tabelę STUDENT_KURS, gdzie każdy kurs to osobny rekord.\n\n\n\n🧩 Druga postać normalna (2NF)\n\nTabela jest w 1NF i wszystkie atrybuty niekluczowe zależą w pełni od całego klucza głównego.\n\nDotyczy tabel z kluczem złożonym.\n\nPrzykład:\nTabela ZAPISY(StudentID, KursID, Sala)\n→ atrybut Sala zależy tylko od KursID, a nie od całego klucza (StudentID, KursID).\nRozwiązanie: wydziel tabelę KURS(KursID, Sala).\n\n\n\n🧩 Trzecia postać normalna (3NF)\n\nTabela jest w 2NF i nie zawiera zależności przechodnich.\n\nKażdy atrybut niekluczowy zależy bezpośrednio od klucza głównego.\n\nPrzykład:\nNrIndeksu → Kierunek, Kierunek → Dziekan\n➡️ Dziekan zależy pośrednio od NrIndeksu.\nRozwiązanie: osobna tabela KIERUNEK(Dziekan, Kierunek).\n\n\n\n🧩 Postać Boyce’a-Codda (BCNF)\n\nDla każdej zależności A → B, zbiór A musi być kluczem kandydującym.\n\nBardziej restrykcyjna niż 3NF – eliminuje wszelkie potencjalne redundancje.",
    "crumbs": [
      "Książki",
      "Wykłady",
      "Normalizacja i projektowanie baz danych"
    ]
  },
  {
    "objectID": "lectures/wyklad3.html#diagramy-erd-entityrelationship-diagram",
    "href": "lectures/wyklad3.html#diagramy-erd-entityrelationship-diagram",
    "title": "Normalizacja i projektowanie baz danych",
    "section": "4. Diagramy ERD (Entity–Relationship Diagram)",
    "text": "4. Diagramy ERD (Entity–Relationship Diagram)\nDiagram ERD jest graficznym sposobem przedstawienia modelu konceptualnego bazy danych.\n\n🔹 Główne elementy ERD\n\nEncja (Entity) – obiekt, o którym przechowujemy dane (np. Student, Kurs).\n\nAtrybut (Attribute) – właściwość encji (np. Imię, Nazwisko, NrIndeksu).\n\nRelacja (Relationship) – powiązanie między encjami (np. Student zapisuje się na Kurs).\n\nKardynalność (Cardinality) – określa liczność relacji:\n\n1:1 (jeden do jednego)\n\n1:N (jeden do wielu)\n\nN:M (wielu do wielu)\n\n\nIdentyfikator (Primary Key) – atrybut jednoznacznie identyfikujący encję.\n\n\n\n🔹 Przykład:\nSTUDENT (NrIndeksu, Imię, Nazwisko, Kierunek)\nKURS (KursID, Nazwa, Prowadzący)\nZAPIS (NrIndeksu, KursID, DataZapisu)\nRelacja między STUDENT a KURS: N:M poprzez encję pośredniczącą ZAPIS.",
    "crumbs": [
      "Książki",
      "Wykłady",
      "Normalizacja i projektowanie baz danych"
    ]
  },
  {
    "objectID": "lectures/wyklad3.html#proces-projektowania-bazy-danych",
    "href": "lectures/wyklad3.html#proces-projektowania-bazy-danych",
    "title": "Normalizacja i projektowanie baz danych",
    "section": "5. Proces projektowania bazy danych",
    "text": "5. Proces projektowania bazy danych\nProjektowanie bazy to proces etapowy:\n\nAnaliza wymagań – zrozumienie, jakie dane są potrzebne i jakie operacje będą wykonywane.\n\nModel konceptualny – opis danych w postaci ERD.\n\nModel logiczny – zamiana modelu ERD na relacyjny schemat tabel.\n\nModel fizyczny – implementacja w konkretnym systemie DBMS (np. PostgreSQL, MySQL).",
    "crumbs": [
      "Książki",
      "Wykłady",
      "Normalizacja i projektowanie baz danych"
    ]
  },
  {
    "objectID": "lectures/wyklad3.html#akcent-praktyczny",
    "href": "lectures/wyklad3.html#akcent-praktyczny",
    "title": "Normalizacja i projektowanie baz danych",
    "section": "6. Akcent praktyczny",
    "text": "6. Akcent praktyczny\nĆwiczenie (do wykonania na zajęciach):\nZaprojektuj model bazy danych dla prostego systemu uczelnianego, obejmującego: - Studentów, - Kursy, - Wykładowców, - Zapis na kursy.\nPrzygotuj: 1. Diagram ERD,\n2. Schemat relacyjny po normalizacji (do 3NF).",
    "crumbs": [
      "Książki",
      "Wykłady",
      "Normalizacja i projektowanie baz danych"
    ]
  },
  {
    "objectID": "lectures/wyklad3.html#efekty-uczenia-się",
    "href": "lectures/wyklad3.html#efekty-uczenia-się",
    "title": "Normalizacja i projektowanie baz danych",
    "section": "🎓 Efekty uczenia się",
    "text": "🎓 Efekty uczenia się\nPo zakończeniu wykładu student: - rozumie pojęcia normalizacji i zależności funkcjonalnych,\n- potrafi rozpoznać błędy projektowe (redundancja, anomalie),\n- potrafi zaprojektować relacyjną bazę danych zgodnie z zasadami normalizacji,\n- zna podstawowe elementy diagramów ERD i proces projektowania bazy danych.\n\n💡 Wskazówka dla studentów:\nW praktyce dążymy do uzyskania trzeciej postaci normalnej (3NF).\nCzasami stosuje się denormalizację dla poprawy wydajności, ale tylko po wcześniejszym zrozumieniu skutków tego działania.",
    "crumbs": [
      "Książki",
      "Wykłady",
      "Normalizacja i projektowanie baz danych"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Informacje ogólne",
    "section": "",
    "text": "Kod:\nSemestr: letni",
    "crumbs": [
      "Książki",
      "Informacje ogólne"
    ]
  },
  {
    "objectID": "index.html#relacyjne-systemy-organizacji-danych",
    "href": "index.html#relacyjne-systemy-organizacji-danych",
    "title": "Informacje ogólne",
    "section": "",
    "text": "Kod:\nSemestr: letni",
    "crumbs": [
      "Książki",
      "Informacje ogólne"
    ]
  },
  {
    "objectID": "index.html#kalendarz",
    "href": "index.html#kalendarz",
    "title": "Informacje ogólne",
    "section": "Kalendarz",
    "text": "Kalendarz\n\nWykład dla grup: WEL23EV1S0, WEL23EA1S0\n\n09.10.2025 Czwartek Wykład 1 - b. 61 sala 116 (3-4)\n14.10.2025 Wtorek Wykład 2 - b. 61 sala 116 (9-10)\n15.10.2025 Środa Wykład 3 - b. 61 sala 116 (3-4)\n29.10.2025 Środa Wykład 4 - b. 61 sala 116 (9-10)\n30.10.2025 Czwartek Wykład 5 - b. 61 sala 116 (5-6)\n\n\n\nLaboratorium grupa WEL23EV1S0:\n\n25.11.2025 Wtorek - b. 61 sala 116\n04.12.2025 czwartek - b. 61 sala 116\n18.12.2025 czwartek - b. 61 sala 116\n08.01.2026 Czwartek - b. 61 sala 116\n22.01.2026 czwartek - b. 61 sala 116\n\n\n\nLaboratorium grupa WEL23EA1S0:\n\n13.11.2025 Czwartek Lab - b. 61 sala 116\n26.11.2025 środa Lab - b. 61 sala 116\n11.12.2025 czwartek - b. 61 sala 116\n15.01.2026 czwartek - b. 61 sala 116\n21.01.2026 środa - b. 61 sala 116",
    "crumbs": [
      "Książki",
      "Informacje ogólne"
    ]
  },
  {
    "objectID": "ksiazki.html",
    "href": "ksiazki.html",
    "title": "Książki i strony WWW",
    "section": "",
    "text": "C.J. Date, An Introduction to Database Systems\nR. Elmasri, S.B. Navathe, Fundamentals of Database Systems\nDokumentacja PostgreSQL: https://www.postgresql.org/docs/"
  },
  {
    "objectID": "ksiazki.html#książki",
    "href": "ksiazki.html#książki",
    "title": "Książki i strony WWW",
    "section": "",
    "text": "C.J. Date, An Introduction to Database Systems\nR. Elmasri, S.B. Navathe, Fundamentals of Database Systems\nDokumentacja PostgreSQL: https://www.postgresql.org/docs/"
  },
  {
    "objectID": "lectures/wyklad2.html",
    "href": "lectures/wyklad2.html",
    "title": "MODEL RELACYJNY I PODSTAWY SQL",
    "section": "",
    "text": "Dane przechowywane w tabelach (relations)\nKażdy wiersz (row) = rekord / krotka\n\nKażda kolumna (column) = atrybut\n\nDziedzina (domain) = zbiór dopuszczalnych wartości w kolumnie\n\nPrzykład relacji STUDENT:\n\n\n\nid\nimie\nnazwisko\nrok_urodzenia\n\n\n\n\n1\nAdam\nMickiewicz\n1798\n\n\n2\nHenryk\nSienkiewicz\n1846",
    "crumbs": [
      "Książki",
      "Wykłady",
      "MODEL RELACYJNY I PODSTAWY SQL"
    ]
  },
  {
    "objectID": "lectures/wyklad2.html#model-relacyjny-przypomnienie-i-pojęcia-podstawowe",
    "href": "lectures/wyklad2.html#model-relacyjny-przypomnienie-i-pojęcia-podstawowe",
    "title": "MODEL RELACYJNY I PODSTAWY SQL",
    "section": "",
    "text": "Dane przechowywane w tabelach (relations)\nKażdy wiersz (row) = rekord / krotka\n\nKażda kolumna (column) = atrybut\n\nDziedzina (domain) = zbiór dopuszczalnych wartości w kolumnie\n\nPrzykład relacji STUDENT:\n\n\n\nid\nimie\nnazwisko\nrok_urodzenia\n\n\n\n\n1\nAdam\nMickiewicz\n1798\n\n\n2\nHenryk\nSienkiewicz\n1846",
    "crumbs": [
      "Książki",
      "Wykłady",
      "MODEL RELACYJNY I PODSTAWY SQL"
    ]
  },
  {
    "objectID": "lectures/wyklad2.html#klucze-i-więzy-integralności",
    "href": "lectures/wyklad2.html#klucze-i-więzy-integralności",
    "title": "MODEL RELACYJNY I PODSTAWY SQL",
    "section": "2️⃣ Klucze i więzy integralności",
    "text": "2️⃣ Klucze i więzy integralności\n\n🔸 Klucz główny (PRIMARY KEY)\n\nUnikalnie identyfikuje każdy wiersz w tabeli.\nNie może być NULL.\n\n\n\n🔸 Klucz obcy (FOREIGN KEY)\n\nOdwołuje się do innej tabeli (relacja między tabelami).\n\n\n\n🔸 Inne więzy:\n\nUNIQUE – unikalność wartości w kolumnie.\nNOT NULL – kolumna nie może mieć wartości pustej.\nCHECK – warunek logiczny na wartość kolumny.\n\n\n\n\n\n\n\n\n\nRodzaj klucza\nOpis\nPrzykład\n\n\n\n\nKlucz główny (Primary Key)\njednoznacznie identyfikuje rekord\nNrIndeksu w STUDENT\n\n\nKlucz obcy (Foreign Key)\ntworzy powiązanie między tabelami\nKursID w tabeli ZAPIS\n\n\nKlucz kandydujący (Candidate Key)\natrybut lub zestaw atrybutów, który może pełnić rolę klucza głównego\n(PESEL), (NrIndeksu)\n\n\nKlucz złożony (Composite Key)\nskłada się z kilku kolumn\n(StudentID, KursID)",
    "crumbs": [
      "Książki",
      "Wykłady",
      "MODEL RELACYJNY I PODSTAWY SQL"
    ]
  },
  {
    "objectID": "lectures/wyklad2.html#rodzaje-związków-relacji-między-tabelami",
    "href": "lectures/wyklad2.html#rodzaje-związków-relacji-między-tabelami",
    "title": "MODEL RELACYJNY I PODSTAWY SQL",
    "section": "2️⃣ Rodzaje związków (relacji) między tabelami",
    "text": "2️⃣ Rodzaje związków (relacji) między tabelami\nW relacyjnej bazie danych tabele mogą być ze sobą połączone przez klucze obce, które tworzą różne typy relacji:\n\n\n\n\n\n\n\n\nTyp relacji\nOpis\nPrzykład\n\n\n\n\n1:1 (jeden do jednego)\njeden rekord w tabeli A odpowiada dokładnie jednemu rekordowi w tabeli B\nStudent ↔︎️ Legitymacja\n\n\n1:N (jeden do wielu)\njeden rekord w tabeli A może być powiązany z wieloma rekordami w tabeli B\nWykładowca ↔︎️ Kursy\n\n\nN:M (wielu do wielu)\nwiele rekordów w A może być powiązanych z wieloma w B\nStudenci ↔︎️ Kursy\n\n\n\nRelację N:M realizujemy przez tabelę pośredniczącą (łączącą), np.:\nSTUDENT (NrIndeksu, Imie, Nazwisko)\nKURS (KursID, Nazwa)\nZAPIS (NrIndeksu, KursID, DataZapisu)\n\nTABELA ZAPIS zawiera klucze obce wskazujące na STUDENT i KURS.\n\n## 3️⃣ Schemat bazy danych – przykład „Biblioteka”\n\n### Tabele:\n- **Autorzy** (`autor_id`, `imie`, `nazwisko`)\n- **Ksiazki** (`ksiazka_id`, `tytul`, `rok`, `autor_id`)\n\n### Relacja:\n- `Ksiazki.autor_id` $\\to$ `Autorzy.autor_id` (klucz obcy)\n\n## 4️⃣ Wprowadzenie do języka SQL (Structured Query Language)\n\nSQL to standardowy język do definiowania, modyfikowania i pobierania danych w relacyjnych bazach danych.\n\n| DDL (Data Definition Language) | definiuje strukturę bazy |CREATE TABLE, ALTER TABLE, DROP TABLE |\n|---------------------------------------------------------------------------------------|\n| DML (Data Manipulation Language) | operacje na danych | INSERT, UPDATE, DELETE, SELECT |\n|----------------------------------------------------------------------------------------|\n| DCL (Data Control Language) | kontrola dostępu | GRANT, REVOKE|\n|----------------------------------------------------------------------------------------|\n| TCL (Transaction Control Language) | kontrola transakcji |COMMIT, ROLLBACK |\n\n\n🔹 Składnia SQL – podział na podjęzyki:\n\n### Tworzenie tabel (DDL – Data Definition Language)\n\nPolecenie `CREATE TABLE` służy do utworzenia nowej tabeli w bazie danych.  \nW tym poleceniu definiujemy nazwy kolumn, ich typy danych oraz różne więzy integralności, takie jak `PRIMARY KEY`, `NOT NULL` czy `FOREIGN KEY`.  \nKażda tabela powinna mieć kolumnę, która jednoznacznie identyfikuje każdy wiersz – to właśnie klucz główny.  \nW przykładzie poniżej tworzymy dwie tabele: **Autorzy** i **Ksiazki**, które będą ze sobą powiązane relacją klucz główny–klucz obcy.\n\n\n\n### Przykład w **SQLite** i **PostgreSQL**\n\n```sql\nCREATE TABLE Autorzy (\n    autor_id     INTEGER PRIMARY KEY,         -- w SQLite automatycznie AUTOINCREMENT\n    imie         TEXT NOT NULL,\n    nazwisko     TEXT NOT NULL\n);\n\nCREATE TABLE Ksiazki (\n    ksiazka_id   SERIAL PRIMARY KEY,          -- PostgreSQL: automatyczna numeracja\n    tytul        VARCHAR(200) NOT NULL,\n    rok          INTEGER CHECK (rok &gt; 0),\n    autor_id     INTEGER,\n    FOREIGN KEY (autor_id) REFERENCES Autorzy(autor_id)\n);\n\nW SQLite INTEGER PRIMARY KEY = alias dla AUTOINCREMENT.\nW PostgreSQL SERIAL lub GENERATED ALWAYS AS IDENTITY.\n\nW powyższym przykładzie tabela Autorzy przechowuje dane o autorach, a tabela Ksiazki – dane o książkach. Kolumna autor_id w tabeli Ksiazki jest kluczem obcym i wskazuje, który autor napisał daną książkę. Dzięki więzom integralności baza pilnuje, aby każda książka miała poprawnego autora. Takie powiązania są podstawą modelu relacyjnego.",
    "crumbs": [
      "Książki",
      "Wykłady",
      "MODEL RELACYJNY I PODSTAWY SQL"
    ]
  },
  {
    "objectID": "lectures/wyklad2.html#modyfikacja-i-usuwanie-tabel",
    "href": "lectures/wyklad2.html#modyfikacja-i-usuwanie-tabel",
    "title": "MODEL RELACYJNY I PODSTAWY SQL",
    "section": "5️⃣ Modyfikacja i usuwanie tabel",
    "text": "5️⃣ Modyfikacja i usuwanie tabel\n\n🔹 Dodawanie kolumn\nALTER TABLE Ksiazki ADD COLUMN gatunek TEXT;\n\n\n🔹 Zmiana typu kolumny\nALTER TABLE STUDENT ALTER COLUMN Kierunek TYPE VARCHAR(100);\n\n\n🔹 Usuwanie kolumny\nALTER TABLE STUDENT DROP COLUMN Email;\n\n\n🔹 Usuwanie tabeli\nDROP TABLE Ksiazki;",
    "crumbs": [
      "Książki",
      "Wykłady",
      "MODEL RELACYJNY I PODSTAWY SQL"
    ]
  },
  {
    "objectID": "lectures/wyklad2.html#wstawianie-danych-dml-data-manipulation-language",
    "href": "lectures/wyklad2.html#wstawianie-danych-dml-data-manipulation-language",
    "title": "MODEL RELACYJNY I PODSTAWY SQL",
    "section": "6️⃣ Wstawianie danych (DML – Data Manipulation Language)",
    "text": "6️⃣ Wstawianie danych (DML – Data Manipulation Language)\nPolecenie INSERT INTO służy do wprowadzania nowych wierszy (rekordów) do tabeli. Wartości muszą być zgodne z typami kolumn oraz ograniczeniami (NOT NULL, CHECK, itp.). Można dodać jeden lub wiele rekordów w jednym poleceniu. Poniżej wstawiamy kilku autorów oraz ich książki do utworzonych wcześniej tabel.\nINSERT INTO Autorzy (imie, nazwisko) VALUES\n('Adam', 'Mickiewicz'),\n('Henryk', 'Sienkiewicz'),\n('Bolesław', 'Prus');\n\nINSERT INTO Ksiazki (tytul, rok, autor_id) VALUES\n('Pan Tadeusz', 1834, 1),\n('Quo Vadis', 1896, 2),\n('Lalka', 1890, 3);\nKażdy rekord reprezentuje jedną pozycję w tabeli. Polecenie INSERT wymaga podania wartości w tej samej kolejności, w jakiej wymieniono kolumny. Jeśli nie podamy jakiejś kolumny, a ma ona zdefiniowaną wartość domyślną (DEFAULT), baza wstawi ją automatycznie. Dzięki temu możemy stopniowo budować zawartość naszej bazy danych.",
    "crumbs": [
      "Książki",
      "Wykłady",
      "MODEL RELACYJNY I PODSTAWY SQL"
    ]
  },
  {
    "objectID": "lectures/wyklad2.html#wybieranie-danych-select",
    "href": "lectures/wyklad2.html#wybieranie-danych-select",
    "title": "MODEL RELACYJNY I PODSTAWY SQL",
    "section": "7️⃣ Wybieranie danych – SELECT",
    "text": "7️⃣ Wybieranie danych – SELECT\n\n🧩 Podstawowy SELECT\nPolecenie SELECT jest najczęściej używanym poleceniem SQL i służy do pobierania danych z tabel. Pozwala określić, które kolumny chcemy zobaczyć i z których tabel dane mają pochodzić. Jeśli użyjemy gwiazdki *, oznacza to, że wybieramy wszystkie kolumny. Poniższe zapytanie zwraca wszystkich autorów z tabeli Autorzy.\nSELECT * FROM Autorzy;\n\n\n🧩 Wybór konkretnych kolumn\nSELECT imie, nazwisko FROM Autorzy;\nWynik to pełna tabela z kolumnami autor_id, imie i nazwisko. Często jednak potrzebujemy tylko części danych, np. imienia i nazwiska – wtedy podajemy konkretne kolumny:\n\n\n🧩 Nadawanie aliasów\nSELECT imie AS \"Imię\", nazwisko AS \"Nazwisko\" FROM Autorzy;\nTakie zapytania pomagają ograniczyć ilość danych i zwiększyć czytelność wyników. Warto też nadawać aliasy (AS), które pozwalają zmienić nazwę kolumn w wynikach i nadać im bardziej opisowy wygląd.",
    "crumbs": [
      "Książki",
      "Wykłady",
      "MODEL RELACYJNY I PODSTAWY SQL"
    ]
  },
  {
    "objectID": "lectures/wyklad2.html#filtrowanie-where",
    "href": "lectures/wyklad2.html#filtrowanie-where",
    "title": "MODEL RELACYJNY I PODSTAWY SQL",
    "section": "8️⃣ Filtrowanie – WHERE",
    "text": "8️⃣ Filtrowanie – WHERE\nKiedy chcemy wybrać tylko część danych, używamy klauzuli WHERE. Dzięki niej możemy ustawić warunki, jakie muszą spełniać rekordy, by pojawiły się w wyniku. To bardzo potężne narzędzie, które pozwala np. wyszukiwać książki z konkretnego roku lub autora. W poniższym przykładzie wybieramy książki wydane po roku 1850.\nSELECT * FROM Ksiazki\nWHERE rok &gt; 1850;\n\n🧠 Operatory:\nMożemy też stosować inne operatory:\n\n=, &lt;&gt;, &lt;, &gt;, &lt;=, &gt;=\nLIKE ‘Q%’ → zaczyna się na Q\nIN (…)\nBETWEEN 1800 AND 1900\nIS NULL, IS NOT NULL\n\nNa przykład, aby znaleźć wszystkie książki, których tytuł zawiera literę „a”, używamy wzorca z LIKE:\nSELECT tytul FROM Ksiazki WHERE tytul LIKE '%a%';\nKlauzula WHERE pozwala więc filtrować dane na wiele sposobów, co czyni zapytania SQL bardzo elastycznymi.",
    "crumbs": [
      "Książki",
      "Wykłady",
      "MODEL RELACYJNY I PODSTAWY SQL"
    ]
  },
  {
    "objectID": "lectures/wyklad2.html#sortowanie-order-by",
    "href": "lectures/wyklad2.html#sortowanie-order-by",
    "title": "MODEL RELACYJNY I PODSTAWY SQL",
    "section": "9️⃣ Sortowanie – ORDER BY",
    "text": "9️⃣ Sortowanie – ORDER BY\nPo pobraniu danych często chcemy uporządkować je według określonego kryterium. Do tego służy klauzula ORDER BY, dzięki której możemy sortować rosnąco (ASC) lub malejąco (DESC). Sortowanie działa na dowolnej kolumnie, także tych, które nie są wyświetlane w wyniku. W przykładzie poniżej porządkujemy książki według roku wydania od najnowszej do najstarszej.\nSELECT * FROM Ksiazki ORDER BY rok DESC;\nJeśli nie podamy kierunku sortowania, domyślnie jest to ASC (rosnąco). Można też sortować według kilku kolumn jednocześnie, np. najpierw po autorze, a potem po roku. Sortowanie poprawia czytelność wyników i pozwala szybciej analizować dane.",
    "crumbs": [
      "Książki",
      "Wykłady",
      "MODEL RELACYJNY I PODSTAWY SQL"
    ]
  },
  {
    "objectID": "lectures/wyklad2.html#grupowanie-i-agregacja-group-by-having",
    "href": "lectures/wyklad2.html#grupowanie-i-agregacja-group-by-having",
    "title": "MODEL RELACYJNY I PODSTAWY SQL",
    "section": "🔟 Grupowanie i agregacja – GROUP BY, HAVING",
    "text": "🔟 Grupowanie i agregacja – GROUP BY, HAVING\nCzasem chcemy policzyć, ile danych należy do danej kategorii – np. ilu autorów napisało więcej niż jedną książkę. Do tego służy GROUP BY, które grupuje dane według wybranej kolumny. W połączeniu z funkcjami agregującymi, takimi jak COUNT(), AVG(), SUM(), MIN() czy MAX(), daje duże możliwości analizy. Klauzula HAVING pozwala odfiltrować grupy po obliczeniu agregacji.\nSELECT autor_id, COUNT(*) AS liczba_ksiazek\nFROM Ksiazki\nGROUP BY autor_id\nHAVING COUNT(*) &gt; 1;\nTo zapytanie zwraca tylko tych autorów, którzy mają więcej niż jedną książkę. Różnica między WHERE a HAVING polega na tym, że WHERE filtruje pojedyncze wiersze przed grupowaniem, a HAVING filtruje całe grupy po agregacji. Wyniki można potem łączyć z innymi tabelami, by uzyskać bardziej opisowe raporty.",
    "crumbs": [
      "Książki",
      "Wykłady",
      "MODEL RELACYJNY I PODSTAWY SQL"
    ]
  },
  {
    "objectID": "lectures/wyklad2.html#łączenie-tabel-join",
    "href": "lectures/wyklad2.html#łączenie-tabel-join",
    "title": "MODEL RELACYJNY I PODSTAWY SQL",
    "section": "1️⃣1️⃣ Łączenie tabel – JOIN",
    "text": "1️⃣1️⃣ Łączenie tabel – JOIN\nW relacyjnym modelu danych informacje są rozproszone w różnych tabelach, które łączy się przy pomocy kluczy obcych. Polecenie JOIN pozwala zestawić dane z kilku tabel na podstawie wspólnej kolumny. Najczęściej używany jest INNER JOIN, który zwraca tylko rekordy, dla których istnieje dopasowanie w obu tabelach. W przykładzie łączymy tabelę Ksiazki z Autorzy, aby zobaczyć tytuł książki i jej autora.\n\n🔹 INNER JOIN\nSELECT k.tytul, a.imie, a.nazwisko\nFROM Ksiazki k\nJOIN Autorzy a ON k.autor_id = a.autor_id;\nWynikiem będzie lista książek wraz z imieniem i nazwiskiem autora. Jeśli chcemy, aby w wynikach pojawiły się także książki bez autora (lub autorzy bez książek), używamy odpowiednio LEFT JOIN lub RIGHT JOIN. Łączenie tabel to fundament relacyjnych baz danych – dzięki niemu dane są spójne i nie trzeba ich powielać.\n\n\n🔹 LEFT JOIN\nSELECT k.tytul, a.imie, a.nazwisko\nFROM Ksiazki k\nLEFT JOIN Autorzy a ON k.autor_id = a.autor_id;",
    "crumbs": [
      "Książki",
      "Wykłady",
      "MODEL RELACYJNY I PODSTAWY SQL"
    ]
  },
  {
    "objectID": "lectures/wyklad2.html#aktualizacja-i-usuwanie-danych",
    "href": "lectures/wyklad2.html#aktualizacja-i-usuwanie-danych",
    "title": "MODEL RELACYJNY I PODSTAWY SQL",
    "section": "1️⃣2️⃣ Aktualizacja i usuwanie danych",
    "text": "1️⃣2️⃣ Aktualizacja i usuwanie danych\nPolecenie UPDATE pozwala modyfikować dane już istniejące w tabeli. Zawsze należy używać klauzuli WHERE, aby zmiana nie objęła wszystkich rekordów. Z kolei DELETE służy do usuwania rekordów – również z warunkiem, by nie usunąć wszystkiego przez pomyłkę. Przykład poniżej pokazuje, jak zmienić rok wydania książki i usunąć starsze pozycje.\nUPDATE Ksiazki SET rok = 1836 WHERE tytul = 'Pan Tadeusz';\n\nDELETE FROM Ksiazki WHERE rok &lt; 1850;\nUPDATE pozwala też aktualizować wiele kolumn naraz, a nawet wykonywać obliczenia. Z kolei DELETE usuwa rekordy z tabeli, ale nie zmienia struktury bazy. Warto zawsze testować warunek WHERE wcześniej przy pomocy SELECT, by uniknąć niechcianych usunięć.",
    "crumbs": [
      "Książki",
      "Wykłady",
      "MODEL RELACYJNY I PODSTAWY SQL"
    ]
  },
  {
    "objectID": "lectures/wyklad2.html#podsumowanie",
    "href": "lectures/wyklad2.html#podsumowanie",
    "title": "MODEL RELACYJNY I PODSTAWY SQL",
    "section": "Podsumowanie",
    "text": "Podsumowanie\nSQL jest językiem deklaratywnym – opisujemy co chcemy uzyskać, a nie jak to zrobić. Dzięki temu użytkownik nie musi znać szczegółów działania bazy danych, wystarczy, że opisze warunki i strukturę zapytania. Poznane dziś polecenia (CREATE, INSERT, SELECT, UPDATE, DELETE, JOIN, GROUP BY) to fundament pracy z bazami danych. Opanowanie ich pozwala budować i analizować nawet bardzo złożone systemy informacyjne.\n\nDokumentacja SQLite\nDokumentacja PostgreSQL\nA. Silberschatz, H. Korth, S. Sudarshan, Database System Concepts",
    "crumbs": [
      "Książki",
      "Wykłady",
      "MODEL RELACYJNY I PODSTAWY SQL"
    ]
  },
  {
    "objectID": "lectures/wyklad1.html",
    "href": "lectures/wyklad1.html",
    "title": "Od pliku do bazy danych",
    "section": "",
    "text": "poznanie podstawowych pojęć: dane, informacja, baza danych, DBMS,\n\nzrozumienie różnicy między systemem plikowym a bazą danych,\n\npoznanie architektury systemu baz danych (ANSI/SPARC),\n\nwprowadzenie do modelu relacyjnego i idei organizacji danych w tabelach.",
    "crumbs": [
      "Książki",
      "Wykłady",
      "Od pliku do bazy danych"
    ]
  },
  {
    "objectID": "lectures/wyklad1.html#dane-informacja-baza-danych",
    "href": "lectures/wyklad1.html#dane-informacja-baza-danych",
    "title": "Od pliku do bazy danych",
    "section": "1️⃣ Dane, informacja, baza danych",
    "text": "1️⃣ Dane, informacja, baza danych\n\n🔹 Dane\n\nZacznijmy od podstawowego pytania: czym właściwie są dane?\n\nDane to surowe fakty, liczby, teksty, symbole — same w sobie nie mają jeszcze znaczenia.\nPrzykład: 12345, Jan Kowalski, Bazy danych.\n\n\n🔹 Informacja\nTo dane zinterpretowane w kontekście.\nPrzykład:\n\n„12345” to numer indeksu studenta Jana Kowalskiego zapisującego się na kurs Bazy danych.\n\n\n\nCzy można mieć dużo danych i żadnej wiedzy? Jakie są przykłady z życia codziennego?\n\n\n\n\n🔹 Baza danych (ang. Database)\nTo uporządkowany zbiór danych, przechowywany w sposób umożliwiający łatwe wyszukiwanie, aktualizację i kontrolę spójności.\n\n\n🔹 System zarządzania bazą danych (DBMS)\nDBMS (Database Management System) to oprogramowanie pośredniczące między użytkownikiem a bazą danych.\nOdpowiada za:\n\ndefiniowanie struktury danych (tworzenie tabel, relacji),\nprzechowywanie i wyszukiwanie danych,\nbezpieczeństwo i kontrolę dostępu,\nobsługę wielu użytkowników,\nzapewnienie spójności transakcji.\n\nPrzykłady DBMS: PostgreSQL, Oracle, MySQL, SQLite, MS SQL Server.",
    "crumbs": [
      "Książki",
      "Wykłady",
      "Od pliku do bazy danych"
    ]
  },
  {
    "objectID": "lectures/wyklad1.html#rodzaje-danych",
    "href": "lectures/wyklad1.html#rodzaje-danych",
    "title": "Od pliku do bazy danych",
    "section": "💾 2. Rodzaje danych",
    "text": "💾 2. Rodzaje danych\n🗣\nW świecie informatyki dane występują w różnych formach. Warto je uporządkować według stopnia strukturyzacji.\n\n📚 Klasyfikacja danych:\n\nUstrukturyzowane\n\nDane w tabelach, arkuszach, bazach. Każdy wiersz ma taki sam zestaw kolumn.\nPrzykład: tabela klientów w Excelu lub SQL.\n\n\n\nID\nImię\nNazwisko\nMiasto\n\n\n\n\n1\nAnna\nNowak\nKraków\n\n\n2\nJan\nKowalski\nWarszawa\n\n\n\n\nPółustrukturyzowane\n\nZawierają strukturę, ale nie jest ona sztywna.\nPrzykład: pliki JSON, XML.\n{\n  \"imie\": \"Anna\",\n  \"miasto\": \"Kraków\",\n  \"zainteresowania\": [\"sport\", \"muzyka\"]\n}\n\nNieustrukturyzowane\n\nBrak jasno określonej struktury danych.\nPrzykład: obraz, dźwięk, wideo, dokument PDF.\nTakie dane trudno przeszukiwać klasycznymi metodami SQL.\n\n\n💬 Pytanie:\n\nJakie dane generujemy codziennie jako użytkownicy internetu? Które z nich są ustrukturyzowane?",
    "crumbs": [
      "Książki",
      "Wykłady",
      "Od pliku do bazy danych"
    ]
  },
  {
    "objectID": "lectures/wyklad1.html#pliki-jako-forma-przechowywania-danych",
    "href": "lectures/wyklad1.html#pliki-jako-forma-przechowywania-danych",
    "title": "Od pliku do bazy danych",
    "section": "🗂️ 3. Pliki jako forma przechowywania danych",
    "text": "🗂️ 3. Pliki jako forma przechowywania danych\nZanim powstały bazy danych, dane przechowywano w plikach płaskich (flat files).\nTo po prostu zbiory rekordów w postaci tekstowej lub binarnej, np. plik .csv lub .txt.\n📄 Przykład pliku płaskiego (CSV):\nID,Imię,Nazwisko,Miasto\n1,Anna,Nowak,Kraków\n2,Jan,Kowalski,Warszawa\n3,Piotr,Wiśniewski,Poznań\n\n🗃 Co można zauważyć:\nDane są łatwe do odczytania – można otworzyć w Excelu lub notatniku.\nAle… brak:\n\nkontroli nad poprawnością (np. można wpisać błędny numer ID),\nrelacji między danymi (osobna lista klientów i zamówień się nie łączy),\nspójności przy równoczesnym dostępie.\n\n\n\n💬 Pytanie:\n\nCo się stanie, gdy dwie osoby jednocześnie edytują ten sam plik CSV?",
    "crumbs": [
      "Książki",
      "Wykłady",
      "Od pliku do bazy danych"
    ]
  },
  {
    "objectID": "lectures/wyklad1.html#problemy-pracy-z-plikami",
    "href": "lectures/wyklad1.html#problemy-pracy-z-plikami",
    "title": "Od pliku do bazy danych",
    "section": "🧱 4. Problemy pracy z plikami",
    "text": "🧱 4. Problemy pracy z plikami\n🗣\nWraz ze wzrostem ilości danych zaczynają się problemy.\nSystemy plikowe mają ograniczenia, których nie da się przeskoczyć bez bazy danych.\n\n⚠️ Typowe problemy:\n\nRedundancja danych – powielanie informacji. np. imię i adres klienta wpisywany przy każdym zamówieniu.\nNiespójność danych – różne wersje tych samych danych w wielu plikach.\nTrudność w aktualizacji – brak jednego miejsca prawdy.\nBrak współbieżności – tylko jeden użytkownik może bezpiecznie edytować.\nBrak bezpieczeństwa i kontroli dostępu.\n\n\n\n🧠 Przykład:\nPlik klienci.txt i zamowienia.txt – brak połączenia między nimi.\nTrudno ustalić, które zamówienie należy do którego klienta.\nklienci.txt:\n1;Anna Nowak;Kraków\n2;Jan Kowalski;Warszawa\n\nzamowienia.txt:\n10;Laptop;1\n11;Monitor;2\n12;Kabel HDMI;1\nTo działa, ale co jeśli zmienimy ID klienta lub nazwę produktu? Powstaje chaos.\n\n\n\n\n\n\n\nProblem\nOpis\n\n\n\n\n🔁 Redundancja\nTe same dane powielane w wielu plikach\n\n\n⚠️ Brak spójności\nAktualizacja w jednym pliku nie zmienia danych w innych\n\n\n⛔ Brak współbieżności\nTylko jedna osoba mogła modyfikować dane naraz\n\n\n❌ Trudna kontrola dostępu\nBrak ról i uprawnień\n\n\n🧩 Słaba integracja\nDane rozproszone po różnych plikach i formatach\n\n\n\nSystem bazodanowy rozwiązuje te problemy, centralizując dane i zarządzając nimi przez DBMS.",
    "crumbs": [
      "Książki",
      "Wykłady",
      "Od pliku do bazy danych"
    ]
  },
  {
    "objectID": "lectures/wyklad1.html#od-pliku-do-bazy-danych",
    "href": "lectures/wyklad1.html#od-pliku-do-bazy-danych",
    "title": "Od pliku do bazy danych",
    "section": "🧮 5. Od pliku do bazy danych",
    "text": "🧮 5. Od pliku do bazy danych\n🗣\nAby rozwiązać te problemy, w latach 70. pojawiła się koncepcja systemu bazodanowego.\nPomysł był prosty, ale rewolucyjny:\n\ndane przechowywane są w jednym centralnym repozytorium,\ndostęp do nich odbywa się przez język zapytań (SQL),\nkontrolowana jest spójność, współbieżność, bezpieczeństwo.\n\n\n📚 Pojęcia podstawowe:\n\nBaza danych – zbiór danych o określonej strukturze.\nSystem zarządzania bazą danych (DBMS) – oprogramowanie do tworzenia, przechowywania, udostępniania danych.\nUżytkownicy – aplikacje, programiści, analitycy, którzy korzystają z danych.\n\n\n\n📊 Przykład:\nPorównanie pliku CSV z tabelą SQL:\n\n\n\n\n\n\n\n\nCecha\nPlik CSV\nBaza danych (SQL)\n\n\n\n\nStruktura danych\nTekstowa, dowolna\nŚciśle zdefiniowana (kolumny, typy)\n\n\nSpójność danych\nNie\nZapewnia DBMS\n\n\nWspółbieżność\nBrak\nObsługiwana\n\n\nWyszukiwanie\nPełne skanowanie\nZapytania, indeksy\n\n\nBezpieczeństwo\nBrak\nKontrola dostępu",
    "crumbs": [
      "Książki",
      "Wykłady",
      "Od pliku do bazy danych"
    ]
  },
  {
    "objectID": "lectures/wyklad1.html#różnice-w-przetwarzaniu-danych-przykład-porównawczy",
    "href": "lectures/wyklad1.html#różnice-w-przetwarzaniu-danych-przykład-porównawczy",
    "title": "Od pliku do bazy danych",
    "section": "🧠 6. Różnice w przetwarzaniu danych – przykład porównawczy",
    "text": "🧠 6. Różnice w przetwarzaniu danych – przykład porównawczy\n🗣\nZanim przejdziemy do SQL, warto zrozumieć, że rodzaj danych determinuje sposób ich przetwarzania.\n\n\n\n\n\n\n\n\n\nTyp danych\nPrzykład\nNarzędzie przetwarzania\nTypowe operacje\n\n\n\n\nTabelaryczne\nsprzedaż, klienci\nSQL, Excel\nsortowanie, sumowanie, filtracja\n\n\nTekstowe\nartykuły, maile\nwyszukiwanie pełnotekstowe\nindeksowanie, analiza słów\n\n\nObraz\nzdjęcia, wideo\nbiblioteki CV, AI\nklasyfikacja, rozpoznawanie obiektów\n\n\nDźwięk\nnagrania, mowa\nDSP, ML\nfiltracja, transkrypcja\n\n\n\n\n💬 Pytanie:\n\nDlaczego dane tabelaryczne można łatwo ująć w relacje, a dźwięk czy obraz – już nie?",
    "crumbs": [
      "Książki",
      "Wykłady",
      "Od pliku do bazy danych"
    ]
  },
  {
    "objectID": "lectures/wyklad1.html#architektura-systemów-baz-danych-ansisparc",
    "href": "lectures/wyklad1.html#architektura-systemów-baz-danych-ansisparc",
    "title": "Od pliku do bazy danych",
    "section": "3️⃣ Architektura systemów baz danych (ANSI/SPARC)",
    "text": "3️⃣ Architektura systemów baz danych (ANSI/SPARC)\nAby zapewnić niezależność danych od aplikacji, opracowano model trójwarstwowy ANSI/SPARC:\n\n\n\n\n\n\n\n\nPoziom\nOpis\nPrzykład\n\n\n\n\nZewnętrzny\nPunkt widzenia użytkownika – wybrane dane w określonym formacie\nWidok „Studenci z kierunku Informatyka”\n\n\nLogiczny (koncepcyjny)\nGlobalny model danych – struktura tabel, relacje, ograniczenia\nSchemat bazy uczelni\n\n\nWewnętrzny (fizyczny)\nSposób przechowywania danych na dysku\nIndeksy, pliki, metody dostępu\n\n\n\nTen model umożliwia: - niezależność logiczną danych (zmiany struktury nie psują aplikacji), - niezależność fizyczną danych (zmiany sposobu zapisu nie wpływają na logikę).",
    "crumbs": [
      "Książki",
      "Wykłady",
      "Od pliku do bazy danych"
    ]
  },
  {
    "objectID": "lectures/wyklad1.html#typy-baz-danych",
    "href": "lectures/wyklad1.html#typy-baz-danych",
    "title": "Od pliku do bazy danych",
    "section": "4️⃣ Typy baz danych",
    "text": "4️⃣ Typy baz danych\nW zależności od sposobu przechowywania i powiązań danych wyróżniamy:\n\n\n\n\n\n\n\n\nTyp bazy danych\nOpis\nPrzykład\n\n\n\n\nHierarchiczna\nDane ułożone w strukturę drzewa\nIMS, stary system IBM\n\n\nSieciowa\nWiele połączeń między rekordami (graf zależności)\nIDMS\n\n\nRelacyjna\nDane w tabelach (relacjach) – klucze, związki\nPostgreSQL, MySQL\n\n\nObiektowa\nDane jako obiekty (z metodami)\nObjectDB, db4o\n\n\nDokumentowa / NoSQL\nDane w formacie JSON, brak stałego schematu\nMongoDB, CouchDB\n\n\nGrafowa\nDane w formie węzłów i krawędzi\nNeo4j\n\n\n\nNajczęściej używanym modelem jest model relacyjny, ponieważ łączy prostotę, spójność i matematyczne podstawy (algebra relacji).\n\n🧭 Wniosek:\n\nBazy danych powstały nie dlatego, że ktoś lubił tabele, ale dlatego, że pliki przestały wystarczać do utrzymania spójnych, współdzielonych informacji.",
    "crumbs": [
      "Książki",
      "Wykłady",
      "Od pliku do bazy danych"
    ]
  },
  {
    "objectID": "lectures/wyklad1.html#historia-i-ewolucja-baz-danych",
    "href": "lectures/wyklad1.html#historia-i-ewolucja-baz-danych",
    "title": "Od pliku do bazy danych",
    "section": "Historia i ewolucja baz danych",
    "text": "Historia i ewolucja baz danych\nBazy danych nie są wynalazkiem XXI wieku — ich początki sięgają lat 60. XX wieku, gdy organizacje zaczęły gromadzić coraz większe ilości danych.\n\n🔹 Systemy plikowe\nPierwsze systemy przechowywały dane w plikach na dyskach. Choć były proste, miały poważne ograniczenia:\n\nBrak centralnej kontroli nad danymi\nTrudność w utrzymaniu spójności\nBrak uniwersalnych narzędzi do wyszukiwania\n\n💡 Zadanie: Na jakich innych obiektach, oprócz plików, można pracować w systemach operacyjnych?\n\n\n🔹 Wczesne systemy DBMS\nW latach 60. i 70. pojawiły się pierwsze systemy zarządzania bazami danych (DBMS). Zapewniały:\n\ncentralną kontrolę danych,\nintegralność i bezpieczeństwo,\nwydajne przetwarzanie i wyszukiwanie.\n\n\n\n🔹 Modele hierarchiczne i sieciowe\nWczesne systemy wykorzystywały struktury drzewiaste lub grafowe. Były skuteczne, ale trudne w modyfikacji i rozwoju.\n\n\n🔹 Przełom: model relacyjny\nW 1970 roku Edgar F. Codd zaproponował model relacyjny danych, w którym:\n\ndane są przechowywane w tabelach (relacjach),\nkażda tabela ma kolumny (atrybuty) i wiersze (krotki).\n\nZalety:\n\nprostota i przejrzystość,\nelastyczność (łatwo dodawać nowe tabele),\nbezpieczeństwo i spójność danych.\n\n\n\n🔹 SQL – język pracy z danymi\nWraz z rozwojem modelu relacyjnego powstał SQL (Structured Query Language) – język do tworzenia, modyfikowania i pobierania danych.\nDziś SQL jest fundamentem większości systemów: od aplikacji biurowych po duże systemy korporacyjne. Nawet współczesne rozwiązania NoSQL często nawiązują do idei relacyjnych.",
    "crumbs": [
      "Książki",
      "Wykłady",
      "Od pliku do bazy danych"
    ]
  },
  {
    "objectID": "lectures/wyklad1.html#zalety-podejścia-relacyjnego",
    "href": "lectures/wyklad1.html#zalety-podejścia-relacyjnego",
    "title": "Od pliku do bazy danych",
    "section": "6️⃣ Zalety podejścia relacyjnego",
    "text": "6️⃣ Zalety podejścia relacyjnego\n\nbrak redundancji danych (dzięki kluczom i relacjom),\nłatwe wyszukiwanie i łączenie informacji (język SQL),\nkontrola spójności i integralności,\nbezpieczeństwo i wielodostępność,\nniezależność logiczna od aplikacji.",
    "crumbs": [
      "Książki",
      "Wykłady",
      "Od pliku do bazy danych"
    ]
  },
  {
    "objectID": "lectures/wyklad1.html#od-modelu-do-języka-wprowadzenie-do-sql",
    "href": "lectures/wyklad1.html#od-modelu-do-języka-wprowadzenie-do-sql",
    "title": "Od pliku do bazy danych",
    "section": "7️⃣ Od modelu do języka – wprowadzenie do SQL",
    "text": "7️⃣ Od modelu do języka – wprowadzenie do SQL\nJęzyk SQL (Structured Query Language) został stworzony, by umożliwić: - definiowanie struktur danych (DDL – Data Definition Language), - manipulowanie danymi (DML – Data Manipulation Language), - kontrolę dostępu i transakcji (DCL, TCL).\nPrzykład: ```sql CREATE TABLE STUDENT ( NrIndeksu INT PRIMARY KEY, Imie VARCHAR(30), Nazwisko VARCHAR(30), Kierunek VARCHAR(50) );",
    "crumbs": [
      "Książki",
      "Wykłady",
      "Od pliku do bazy danych"
    ]
  },
  {
    "objectID": "lectures/wyklad1.html#materiały-do-dalszej-lektury",
    "href": "lectures/wyklad1.html#materiały-do-dalszej-lektury",
    "title": "Od pliku do bazy danych",
    "section": "📚 Materiały do dalszej lektury",
    "text": "📚 Materiały do dalszej lektury\n\nC.J. Date, An Introduction to Database Systems\nR. Elmasri, S.B. Navathe, Fundamentals of Database Systems\nDokumentacja PostgreSQL: https://www.postgresql.org/docs/",
    "crumbs": [
      "Książki",
      "Wykłady",
      "Od pliku do bazy danych"
    ]
  },
  {
    "objectID": "lectures/wyklad5.html",
    "href": "lectures/wyklad5.html",
    "title": "WYKŁAD 5 – Projektowanie interfejsu bazy danych i praktyczne wykorzystanie SQL/PL/SQL",
    "section": "",
    "text": "Celem wykładu jest pokazanie, jak projektować interfejs do bazy danych w środowisku programistycznym, integrować SQL i PL/SQL w aplikacjach oraz wykonywać typowe operacje na danych."
  },
  {
    "objectID": "lectures/wyklad5.html#temat-łączenie-bazy-danych-z-aplikacją-i-praktyczne-operacje",
    "href": "lectures/wyklad5.html#temat-łączenie-bazy-danych-z-aplikacją-i-praktyczne-operacje",
    "title": "WYKŁAD 5 – Projektowanie interfejsu bazy danych i praktyczne wykorzystanie SQL/PL/SQL",
    "section": "",
    "text": "Celem wykładu jest pokazanie, jak projektować interfejs do bazy danych w środowisku programistycznym, integrować SQL i PL/SQL w aplikacjach oraz wykonywać typowe operacje na danych."
  },
  {
    "objectID": "lectures/wyklad5.html#cele-wykładu",
    "href": "lectures/wyklad5.html#cele-wykładu",
    "title": "WYKŁAD 5 – Projektowanie interfejsu bazy danych i praktyczne wykorzystanie SQL/PL/SQL",
    "section": "🧠 Cele wykładu",
    "text": "🧠 Cele wykładu\nStudent po wykładzie będzie potrafił:\n\nprojektować podstawowy interfejs do bazy danych w wybranym środowisku (np. Python, Java, C#),\n\nkorzystać z połączeń bazodanowych (DB connection),\n\nwykonywać zapytania SQL i bloki PL/SQL z poziomu aplikacji,\n\nrozumieć podstawy zabezpieczania danych i transakcji w aplikacjach."
  },
  {
    "objectID": "lectures/wyklad5.html#projektowanie-interfejsu-bazy-danych",
    "href": "lectures/wyklad5.html#projektowanie-interfejsu-bazy-danych",
    "title": "WYKŁAD 5 – Projektowanie interfejsu bazy danych i praktyczne wykorzystanie SQL/PL/SQL",
    "section": "1️⃣ Projektowanie interfejsu bazy danych",
    "text": "1️⃣ Projektowanie interfejsu bazy danych\n\n🔹 Co to jest interfejs bazy danych?\n\nInterfejs to warstwa komunikacji między aplikacją a bazą danych.\n\nPozwala aplikacji wysyłać zapytania SQL, odbierać wyniki i przetwarzać je w logice biznesowej.\n\n\n\n🔹 Główne elementy interfejsu\n\nPołączenie z bazą danych – obiekt, który umożliwia komunikację z serwerem DB.\n\nWysyłanie zapytań – wykonanie SELECT, INSERT, UPDATE, DELETE lub wywołań procedur PL/SQL.\n\nObsługa wyników – pobieranie danych w formie rekordów lub tabel.\n\nZarządzanie transakcjami – commit, rollback.\n\nOpis słowny: interfejs bazy działa jak most między programem a fizyczną bazą danych. Bez niego aplikacja nie „wie”, gdzie i jak przechowywane są dane."
  },
  {
    "objectID": "lectures/wyklad5.html#przykład-połączenie-do-bazy-w-pythonie",
    "href": "lectures/wyklad5.html#przykład-połączenie-do-bazy-w-pythonie",
    "title": "WYKŁAD 5 – Projektowanie interfejsu bazy danych i praktyczne wykorzystanie SQL/PL/SQL",
    "section": "2️⃣ Przykład – połączenie do bazy w Pythonie",
    "text": "2️⃣ Przykład – połączenie do bazy w Pythonie\nimport cx_Oracle\n\n# Nawiązanie połączenia\nconn = cx_Oracle.connect('uzytkownik/haslo@localhost/XE')\ncursor = conn.cursor()\n\n# Wykonanie zapytania SELECT\ncursor.execute(\"SELECT imie, nazwisko FROM Studenci\")\nfor row in cursor:\n    print(f\"Student: {row[0]} {row[1]}\")\n\n# Zamknięcie połączenia\ncursor.close()\nconn.close()\nkod pokazuje, jak w Pythonie połączyć się z bazą Oracle, pobrać dane i je wyświetlić."
  },
  {
    "objectID": "lectures/wyklad5.html#wykonywanie-operacji-sql-i-plsql-w-aplikacji",
    "href": "lectures/wyklad5.html#wykonywanie-operacji-sql-i-plsql-w-aplikacji",
    "title": "WYKŁAD 5 – Projektowanie interfejsu bazy danych i praktyczne wykorzystanie SQL/PL/SQL",
    "section": "3️⃣ Wykonywanie operacji SQL i PL/SQL w aplikacji",
    "text": "3️⃣ Wykonywanie operacji SQL i PL/SQL w aplikacji\n🔹 Operacje SQL\n\nINSERT – dodawanie nowych rekordów.\nUPDATE – modyfikacja istniejących danych.\nDELETE – usuwanie rekordów.\n\nPrzykład:\ncursor.execute(\"INSERT INTO Studenci VALUES (12347, 'Piotr', 'Nowak', 22)\")\nconn.commit()\nconn.commit() zatwierdza zmiany w bazie. Bez commit zmiany nie będą trwałe.\n\n🔹 Wywołanie procedury PL/SQL\ncursor.callproc(\"dodaj_studenta\", [12348, 'Anna', 'Kowalska', 21])\nconn.commit()\ncallproc pozwala wywołać procedury zapisane w bazie, co umożliwia automatyzację logiki biznesowej."
  },
  {
    "objectID": "lectures/wyklad5.html#obsługa-transakcji-w-aplikacjach",
    "href": "lectures/wyklad5.html#obsługa-transakcji-w-aplikacjach",
    "title": "WYKŁAD 5 – Projektowanie interfejsu bazy danych i praktyczne wykorzystanie SQL/PL/SQL",
    "section": "4️⃣ Obsługa transakcji w aplikacjach",
    "text": "4️⃣ Obsługa transakcji w aplikacjach\n\nTransakcje zapewniają spójność danych, nawet gdy aplikacja wykonuje wiele operacji jednocześnie.\nTypowy wzorzec:\n\nRozpocznij transakcję\nWykonaj operacje (INSERT, UPDATE, DELETE)\nW razie powodzenia: commit\nW razie błędu: rollback\n\n\nPrzykład w Pythonie:\ntry:\n    cursor.execute(\"UPDATE Kursy SET IloscMiejsc = IloscMiejsc - 1 WHERE KursID = 10\")\n    cursor.execute(\"INSERT INTO Studenci VALUES (12349, 'Kasia', 'Wiśniewska', 20)\")\n    conn.commit()\nexcept:\n    conn.rollback()\n    print(\"Wystąpił błąd, transakcja wycofana\")\nzięki transakcji zmiany są atomowe – albo wszystkie operacje się powiodą, albo żadna."
  },
  {
    "objectID": "lectures/wyklad5.html#indeksy-i-optymalizacja-zapytań-w-aplikacji",
    "href": "lectures/wyklad5.html#indeksy-i-optymalizacja-zapytań-w-aplikacji",
    "title": "WYKŁAD 5 – Projektowanie interfejsu bazy danych i praktyczne wykorzystanie SQL/PL/SQL",
    "section": "6️⃣ Indeksy i optymalizacja zapytań w aplikacji",
    "text": "6️⃣ Indeksy i optymalizacja zapytań w aplikacji\n\nIndeksy przyspieszają wyszukiwanie i filtrowanie danych w tabelach.\nW aplikacji warto zwracać uwagę na kolumny, po których najczęściej wyszukujemy.\n\nPrzykład w SQL:\nCREATE INDEX idx_student_nazwisko ON Studenci(Nazwisko);\nindeks może znacząco przyspieszyć SELECT w aplikacjach o dużych zbiorach danych, ale spowalnia INSERT/UPDATE."
  },
  {
    "objectID": "lectures/wyklad5.html#podsumowanie-wykładu",
    "href": "lectures/wyklad5.html#podsumowanie-wykładu",
    "title": "WYKŁAD 5 – Projektowanie interfejsu bazy danych i praktyczne wykorzystanie SQL/PL/SQL",
    "section": "7️⃣ Podsumowanie wykładu",
    "text": "7️⃣ Podsumowanie wykładu\n\n🔑 Kluczowe pojęcia:\n\nInterfejs bazy danych – połączenie między aplikacją a DBMS\nOperacje SQL i PL/SQL z poziomu aplikacji\nZarządzanie transakcjami dla spójności danych\nIndeksy i podstawowe zasady optymalizacji\n\n\n\n💡 Wskazówka:\nW praktyce projektowanie interfejsu wymaga zarówno znajomości bazy danych, jak i języka programowania. Dobrze zaprojektowana komunikacja z bazą zmniejsza liczbę błędów i zwiększa wydajność aplikacji."
  }
]