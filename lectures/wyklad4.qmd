---
title: "Podstawy PL/SQL, transakcje i indeksy"
---

## 1ï¸âƒ£ Wprowadzenie do PL/SQL

### ğŸ”¹ Czym jest PL/SQL?

- PL/SQL to **proceduralny jÄ™zyk rozszerzajÄ…cy SQL** w systemach Oracle i kompatybilnych.  
- UmoÅ¼liwia uÅ¼ycie **instrukcji warunkowych, pÄ™tli, zmiennych i procedur**, czego SQL nie oferuje w formie deklaratywnej.  

**PrzykÅ‚ad prostego bloku PL/SQL:**

```sql
BEGIN
    DBMS_OUTPUT.PUT_LINE('Witaj w Å›wiecie PL/SQL!');
END;
/
```

Kod ten uruchamia blok proceduralny, ktÃ³ry wypisuje komunikat. 

`BEGIN` rozpoczyna blok, `END;` koÅ„czy, a `/` uruchamia go w SQL*Plus.

### ğŸ”¹ Zmienne i typy danych

PL/SQL pozwala tworzyÄ‡ zmienne i przypisywaÄ‡ im wartoÅ›ci.

```sql
DECLARE
    v_imie VARCHAR2(50);
    v_wiek NUMBER;
BEGIN
    v_imie := 'Jan';
    v_wiek := 25;
    DBMS_OUTPUT.PUT_LINE('Student: ' || v_imie || ', wiek: ' || v_wiek);
END;
/
```

Zmienne umoÅ¼liwiajÄ… przechowywanie danych tymczasowo w trakcie wykonywania programu.

### ğŸ”¹ Instrukcje warunkowe i pÄ™tle

PL/SQL pozwala na uÅ¼ycie:

> IFâ€¦THENâ€¦ELSE:

```sql
IF v_wiek >= 18 THEN
    DBMS_OUTPUT.PUT_LINE('PeÅ‚noletni');
ELSE
    DBMS_OUTPUT.PUT_LINE('NiepeÅ‚noletni');
END IF;
```

> LOOP, WHILE, FOR â€“ do powtarzania operacji:
  
```sql
FOR i IN 1..5 LOOP
    DBMS_OUTPUT.PUT_LINE('Liczba: ' || i);
END LOOP;
```

Instrukcje warunkowe i pÄ™tle pozwalajÄ… w peÅ‚ni programowaÄ‡ logikÄ™ w bazie danych.

## 2ï¸âƒ£ Operacje na danych w PL/SQL

PL/SQL umoÅ¼liwia wykonywanie standardowych operacji SQL:

> INSERT, UPDATE, DELETE â€“ bezpoÅ›rednio w blokach proceduralnych.

PrzykÅ‚ad aktualizacji danych:

```sql
BEGIN
    UPDATE Studenci
    SET Wiek = 26
    WHERE NrIndeksu = 12345;
END;
/
```

moÅ¼na grupowaÄ‡ wiele operacji w jednym bloku, co uÅ‚atwia zarzÄ…dzanie spÃ³jnoÅ›ciÄ… danych.


## ğŸ’¡ Dlaczego optymalizacja jest waÅ¼na?

Optymalizacja zapytaÅ„ SQL to jeden z najwaÅ¼niejszych elementÃ³w pracy z bazami danych.  
Dotyczy zarÃ³wno programistÃ³w aplikacji, jak i administratorÃ³w baz danych (DBA).  
Celem jest takie przygotowanie zapytaÅ„, struktur danych i indeksÃ³w, aby **uzyskaÄ‡ maksymalnÄ… wydajnoÅ›Ä‡ przy minimalnym obciÄ…Å¼eniu systemu**.

KaÅ¼de zapytanie SQL, nawet najprostsze, wymaga od silnika bazy danych wykonania okreÅ›lonych operacji: odczytu danych z dysku, przetworzenia warunkÃ³w `WHERE`, wykonania `JOIN`, `GROUP BY`, `ORDER BY`, a nastÄ™pnie zwrÃ³cenia wynikÃ³w uÅ¼ytkownikowi.

JeÅ›li baza danych zawiera **miliony rekordÃ³w**, to nawet niewielkie rÃ³Å¼nice w sposobie wykonania zapytania mogÄ… oznaczaÄ‡:

- rÃ³Å¼nicÄ™ miÄ™dzy **milisekundami a sekundami**,  
- obciÄ…Å¼enie **jednego wÄ…tku** zamiast caÅ‚ego serwera,  
- lub zuÅ¼ycie **gigabajtÃ³w pamiÄ™ci i I/O** bez potrzeby.

> ğŸ§  *â€Optymalizacja zapytaÅ„ SQL to nie sztuka pisania krÃ³tszego kodu,  
> lecz umiejÄ™tnoÅ›Ä‡ zmuszenia silnika bazy danych do pracy mÄ…drze, a nie ciÄ™Å¼ko.â€*


## âš™ï¸ Jak dziaÅ‚a zapytanie w silniku bazy danych?

Aby zrozumieÄ‡ optymalizacjÄ™, musimy wiedzieÄ‡, **co dzieje siÄ™ z zapytaniem od momentu jego wysÅ‚ania do bazy danych**.  
Silnik SQL analizuje skÅ‚adniÄ™ zapytania, przepisuje je logicznie, wybiera najtaÅ„szy plan wykonania i dopiero wtedy odczytuje dane.  


## ğŸ§© Co wpÅ‚ywa na wydajnoÅ›Ä‡ zapytaÅ„ SQL?

WydajnoÅ›Ä‡ zapytaÅ„ zaleÅ¼y zarÃ³wno od **tego, jak zapytanie jest napisane**, jak i **od tego, jak zorganizowane sÄ… dane w bazie**:

### ğŸ”¹ Struktura zapytania

- ZÅ‚oÅ¼onoÅ›Ä‡ klauzul `WHERE`, `JOIN`, `ORDER BY`
- ZagnieÅ¼dÅ¼one podzapytania (`subqueries`)
- UÅ¼ycie funkcji agregujÄ…cych (`COUNT`, `SUM`, `AVG`)

### ğŸ”¹ Architektura danych

- IloÅ›Ä‡ danych w tabelach  
- Indeksy (ich liczba, rodzaj i aktualnoÅ›Ä‡)  
- Klucze gÅ‚Ã³wne i obce (`PRIMARY KEY`, `FOREIGN KEY`)  
- StopieÅ„ normalizacji lub denormalizacji danych  

### ğŸ”¹ Stan Å›rodowiska bazy

- DostÄ™pna pamiÄ™Ä‡ RAM  
- Buforowanie i cache dyskowy  
- Statystyki tabel (`ANALYZE`, `UPDATE STATISTICS`)  
- ObciÄ…Å¼enie serwera (inne procesy, sesje, transakcje)

---

## ğŸ“Š PrzykÅ‚ad znaczenia optymalizacji

WyobraÅºmy sobie tabelÄ™ **`orders`** z 10 milionami zamÃ³wieÅ„.  
Chcemy znaleÅºÄ‡ wszystkie zamÃ³wienia z ostatnich 30 dni:

```sql
SELECT * FROM orders WHERE order_date >= CURRENT_DATE - INTERVAL '30 days';
```

### Scenariusz A â€“ brak indeksu

Silnik musi przeskanowaÄ‡ caÅ‚Ä… tabelÄ™ (tzw. **Seq Scan**).
KaÅ¼dy wiersz jest sprawdzany, czy speÅ‚nia warunek `order_date >= ...`.

- â±ï¸ Czas wykonania: ~3.2 s  
- ğŸ’¾ Operacje I/O: wysokie  

### Scenariusz B â€“ z indeksem

Dodajemy indeks:
```sql
CREATE INDEX idx_orders_date ON orders(order_date);
```

Silnik teraz korzysta z **Index Scan**, czyli odczytu tylko fragmentu danych pasujÄ…cych do warunku.

- â±ï¸ Czas wykonania: ~0.03 s  
- ğŸ’¾ Operacje I/O: minimalne  

â¡ï¸ **100Ã— szybsze zapytanie** â€“ bez zmiany jednej linijki logiki, tylko dziÄ™ki optymalizacji struktury danych.


## âš™ï¸ Jak dziaÅ‚a optymalizator zapytaÅ„ SQL

KaÅ¼de zapytanie SQL, ktÃ³re wysyÅ‚asz do bazy danych, przechodzi **proces planowania i wykonania**.  
Silnik SQL **nie wykonuje zapytania dokÅ‚adnie tak, jak je napisaÅ‚eÅ›** â€” najpierw szuka **najbardziej efektywnego sposobu** uzyskania tego samego wyniku.

Tym wÅ‚aÅ›nie zajmuje siÄ™ **optymalizator zapytaÅ„ (Query Optimizer)**.


## ğŸ§  Czym jest optymalizator zapytaÅ„?

Optymalizator analizuje zapytanie i decyduje, **w jaki sposÃ³b najlepiej pobraÄ‡ dane**.  
Nie zmienia logiki zapytania, ale moÅ¼e caÅ‚kowicie zmieniÄ‡:

- kolejnoÅ›Ä‡ operacji,  
- sposÃ³b Å‚Ä…czenia tabel (`JOIN order`),  
- wybÃ³r indeksÃ³w,  
- metodÄ™ sortowania lub agregacji.

> ğŸ’¡ *Optymalizator to planista â€” nie wykonuje zapytania sam,  
> ale ukÅ‚ada plan dziaÅ‚ania tak, by wynik uzyskaÄ‡ jak najszybciej i najtaniej.*


## ğŸ”„ Etapy przetwarzania zapytania

Dla przykÅ‚adu:

```sql
SELECT name, salary 
FROM employees 
WHERE department_id = 10 AND salary > 5000;
```

Silnik przechodzi przez kilka logicznych etapÃ³w:

### 1. Parsing (analiza skÅ‚adniowa)

- sprawdza poprawnoÅ›Ä‡ skÅ‚adni SQL,  
- weryfikuje istnienie tabel i kolumn,  
- tworzy drzewo zapytania (*parse tree*).

### 2. Rewriting (przepisanie logiczne)

- upraszcza warunki (`WHERE TRUE`, podwÃ³jne filtry),  
- zamienia `IN` na `EXISTS`,  
- Å‚Ä…czy filtry logiczne (`AND`, `OR`),  
- moÅ¼e przenosiÄ‡ warunki do podzapytaÅ„ (*predicate pushdown*).

### 3. Optimization (planowanie kosztowe)

Optymalizator analizuje rÃ³Å¼ne plany wykonania:

- ktÃ³ry indeks uÅ¼yÄ‡,  
- w jakiej kolejnoÅ›ci Å‚Ä…czyÄ‡ tabele,  
- jakiego algorytmu uÅ¼yÄ‡ (`hash join`, `merge join`, `nested loop`).

KaÅ¼dy plan ma przypisany **koszt (cost estimate)** oparty na:

- liczbie wierszy,  
- selektywnoÅ›ci warunkÃ³w,  
- dostÄ™pnych indeksach,  
- statystykach i kosztach I/O oraz CPU.

> ğŸ§® Optymalizator nie wykonuje zapytaÅ„ â€” **symuluje scenariusze** i wybiera ten o najniÅ¼szym koszcie.

### 4. Execution Plan (plan wykonania)

Po wyborze najlepszego planu, optymalizator przekazuje go do moduÅ‚u wykonawczego.  
Plan opisuje krok po kroku, jak dane zostanÄ… pobrane i przetworzone.

MoÅ¼emy go podejrzeÄ‡ poleceniem:

```sql
EXPLAIN SELECT ...
```
lub
```sql
EXPLAIN ANALYZE SELECT ...
```

# ğŸ” Analiza planu zapytania (EXPLAIN)

Jednym z najwaÅ¼niejszych narzÄ™dzi w optymalizacji SQL jest komenda **`EXPLAIN`**.  
Pozwala â€zajrzeÄ‡ do Å›rodkaâ€ silnika bazy danych i zobaczyÄ‡, **jak zapytanie zostaÅ‚o zaplanowane i wykonane**.

DziÄ™ki niej moÅ¼emy:

- zrozumieÄ‡, dlaczego zapytanie dziaÅ‚a wolno,  
- sprawdziÄ‡, czy uÅ¼ywany jest indeks,  
- oceniÄ‡, ile operacji baza musi wykonaÄ‡, by uzyskaÄ‡ wynik.

> ğŸ§  *Nie zgaduj, dlaczego Twoje zapytanie jest wolne â€” zobacz plan wykonania i sprawdÅº, co naprawdÄ™ robi baza.*


## âš™ï¸ Co to jest plan zapytania?

Plan zapytania to **opis krokÃ³w**, jakie silnik bazy danych musi wykonaÄ‡, by uzyskaÄ‡ wynik.  
KaÅ¼dy krok reprezentuje konkretnÄ… operacjÄ™ â€” np.:

- **Scan** (odczyt danych z tabeli lub indeksu),
- **Join** (Å‚Ä…czenie danych z kilku tabel),
- **Sort** (sortowanie wynikÃ³w),
- **Aggregate** (sumowanie, grupowanie, liczenie).

KaÅ¼dy z tych krokÃ³w ma przypisany **szacowany koszt** â€” liczbowÄ… wartoÅ›Ä‡ okreÅ›lajÄ…cÄ…, ile operacji CPU, I/O lub pamiÄ™ci wymaga jego wykonanie.


## ğŸ§© SkÅ‚adnia polecenia `EXPLAIN`

W wiÄ™kszoÅ›ci systemÃ³w baz danych moÅ¼na uÅ¼yÄ‡ `EXPLAIN` na poczÄ…tku dowolnego zapytania:

```sql
EXPLAIN SELECT * FROM employees WHERE department_id = 10;
```

Aby uzyskaÄ‡ wiÄ™cej szczegÃ³Å‚Ã³w, moÅ¼na dodaÄ‡:
```sql
EXPLAIN ANALYZE SELECT * FROM employees WHERE department_id = 10;
```

ğŸ“Š RÃ³Å¼nica:

- EXPLAIN â€” pokazuje plan teoretyczny (na podstawie statystyk i kosztÃ³w),
- EXPLAIN ANALYZE â€” faktycznie wykonuje zapytanie i pokazuje rzeczywisty czas oraz liczbÄ™ przetworzonych wierszy.

### ğŸ§  PrzykÅ‚ad w PostgreSQL

ZaÅ‚Ã³Å¼my, Å¼e mamy tabelÄ™:
```sql
CREATE TABLE orders (
  id SERIAL PRIMARY KEY,
  customer_id INTEGER,
  order_date DATE,
  total DECIMAL
);

CREATE INDEX idx_orders_customer ON orders(customer_id);

```
i wykonujemy zapytanie:
```sql
EXPLAIN ANALYZE
SELECT * FROM orders WHERE customer_id = 42;
```
### ğŸ”¹ Wynik (plan zapytania):

```sql
Index Scan using idx_orders_customer on orders  (cost=0.29..8.50 rows=3 width=48)
  Index Cond: (customer_id = 42)
Planning Time: 0.100 ms
Execution Time: 0.030 ms
```


| Element              | Znaczenie                                                                 |
|-----------------------|---------------------------------------------------------------------------|
| **Index Scan**        | Baza odczytuje dane przy uÅ¼yciu indeksu (nie peÅ‚ny skan tabeli).          |
| **idx_orders_customer** | Nazwa uÅ¼ytego indeksu.                                                   |
| **cost=0.29..8.50**   | Szacowany koszt (startowy i caÅ‚kowity). Im mniejszy, tym lepiej.         |
| **rows=3**            | Szacowana liczba wierszy, ktÃ³re speÅ‚niÄ… warunek.                         |
| **width=48**          | Åšredni rozmiar jednego wiersza (w bajtach).                              |
| **Index Cond**        | Warunek, ktÃ³ry zostaÅ‚ uÅ¼yty do przeszukania indeksu.                     |
| **Execution Time**    | Faktyczny czas wykonania (tylko w `EXPLAIN ANALYZE`).   


### ğŸ” PorÃ³wnanie: brak indeksu

JeÅ›li usuniemy indeks i uruchomimy to samo zapytanie:

```sql
EXPLAIN ANALYZE
SELECT * FROM orders WHERE customer_id = 42;
```

otrzymamy:

```sql
Seq Scan on orders  (cost=0.00..450.00 rows=3 width=48)
  Filter: (customer_id = 42)
Execution Time: 22.5 ms
```

ğŸ“‰ RÃ³Å¼nica:

- Baza musi przeskanowaÄ‡ caÅ‚Ä… tabelÄ™ (Seq Scan),
- Pomimo tego, Å¼e wynik jest ten sam, wykonanie jest znacznie wolniejsze.

ğŸ’¬ EXPLAIN pokazuje, Å¼e problemem nie jest zapytanie, lecz brak indeksu.

<!-- 
### ğŸª¶ PrzykÅ‚ad w SQLite

SQLite rÃ³wnieÅ¼ wspiera EXPLAIN QUERY PLAN, choÄ‡ w uproszczonej formie.

```sql
CREATE TABLE users (
  id INTEGER PRIMARY KEY,
  name TEXT,
  email TEXT
);

CREATE INDEX idx_users_email ON users(email);

EXPLAIN QUERY PLAN
SELECT * FROM users WHERE email = 'john@example.com';
```
### ğŸ”¹ Wynik:

```sql
SEARCH users USING INDEX idx_users_email (email=?)
```

Lub â€” jeÅ›li nie ma indeksu:

```sql
SCAN users
```


Proste, ale bardzo czytelne:

- SCAN oznacza peÅ‚ne przeszukiwanie tabeli,
- SEARCH ... USING INDEX oznacza, Å¼e baza uÅ¼yÅ‚a indeksu. -->

## ğŸ§® Jak korzystaÄ‡ z EXPLAIN w praktyce

1. Sprawdzaj, czy uÅ¼ywany jest indeks

JeÅ›li widzisz Seq Scan lub SCAN TABLE, to znak, Å¼e indeks nie jest wykorzystywany.

2. Zwracaj uwagÄ™ na kolejnoÅ›Ä‡ JOINÃ³w

Czasami odwrÃ³cenie kolejnoÅ›ci tabel w zapytaniu moÅ¼e daÄ‡ inny plan i lepszy czas.

3. Analizuj koszty (cost=...)

PorÃ³wnuj plany z rÃ³Å¼nymi indeksami i filtrami â€” wybieraj ten o niÅ¼szym koszcie.

4. UÅ¼ywaj EXPLAIN ANALYZE tylko testowo

W Å›rodowisku produkcyjnym EXPLAIN ANALYZE faktycznie wykonuje zapytanie, wiÄ™c moÅ¼e byÄ‡ kosztowne.

5. PorÃ³wnuj teoretyczny i rzeczywisty plan

JeÅ›li szacunki (rows, cost) mocno rÃ³Å¼niÄ… siÄ™ od rzeczywistego czasu, oznacza to:

- brak aktualnych statystyk,
- zÅ‚y indeks,
- lub bÅ‚Ä™dne zaÅ‚oÅ¼enia optymalizatora.


## ğŸ—‚ï¸ Indeksy w SQL

Indeksy to **podstawowe narzÄ™dzie optymalizacji zapytaÅ„**, ktÃ³re pozwala bazie danych szybko znaleÅºÄ‡ potrzebne wiersze, bez koniecznoÅ›ci skanowania caÅ‚ej tabeli.  
MoÅ¼na je porÃ³wnaÄ‡ do **spisu treÅ›ci w ksiÄ…Å¼ce** â€” zamiast czytaÄ‡ kaÅ¼dy rozdziaÅ‚, patrzymy od razu na wÅ‚aÅ›ciwÄ… stronÄ™.

### ğŸ”¹ Dlaczego indeksy sÄ… waÅ¼ne?

Bez indeksu baza danych musi sprawdziÄ‡ kaÅ¼dy wiersz tabeli, by znaleÅºÄ‡ pasujÄ…ce rekordy (**sequential scan**).  
Z indeksem, silnik moÅ¼e odczytaÄ‡ **tylko te dane**, ktÃ³re speÅ‚niajÄ… warunek â€” znacznie szybciej i przy mniejszym zuÅ¼yciu zasobÃ³w.

KorzyÅ›ci z indeksÃ³w:

- â±ï¸ **Szybsze wyszukiwanie** danych, szczegÃ³lnie w duÅ¼ych tabelach  
- ğŸ’¾ **Ograniczenie operacji I/O**, bo baza czyta mniej blokÃ³w z dysku  
- ğŸ”„ **Przyspieszenie sortowania i Å‚Ä…czenia tabel** (`JOIN`), jeÅ›li indeks obejmuje kolumny uÅ¼ywane w warunkach

### ğŸ”¹ Rodzaje indeksÃ³w

NajczÄ™Å›ciej spotykane:

1. **B-Tree (balanced tree)** â€“ najpopularniejszy typ, sprawdza siÄ™ w wiÄ™kszoÅ›ci wyszukiwaÅ„, zakresÃ³w i sortowaÅ„  
2. **Hash** â€“ szybki dostÄ™p po dokÅ‚adnej wartoÅ›ci (nie obsÅ‚uguje zakresÃ³w)  
3. **Bitmap** â€“ efektywny dla kolumn o maÅ‚ej liczbie unikalnych wartoÅ›ci, np. pÅ‚eÄ‡ lub status  
4. **Kompozytowe** â€“ obejmujÄ… kilka kolumn, przydatne przy filtrach i sortowaniach wielokolumnowych

### ğŸ”¹ Co indeksuje?

- **Kolumny uÅ¼ywane w WHERE** â€“ aby szybciej wyszukaÄ‡ dane  
- **Kolumny uÅ¼ywane w JOIN** â€“ przyspiesza Å‚Ä…czenie tabel  
- **Kolumny w ORDER BY lub GROUP BY** â€“ pomaga szybciej sortowaÄ‡ i grupowaÄ‡ wyniki  
- **Kolumny unikalne lub klucze gÅ‚Ã³wne** â€“ zapewnia integralnoÅ›Ä‡ danych i przyspiesza wyszukiwanie

### ğŸ”¹ Wady nadmiaru indeksÃ³w

Indeksy przyspieszajÄ… odczyt, ale majÄ… teÅ¼ koszty:

- ğŸ”„ **Spowolnienie operacji INSERT/UPDATE/DELETE**, bo indeksy trzeba aktualizowaÄ‡  
- ğŸ’¾ **ZwiÄ™kszone zuÅ¼ycie pamiÄ™ci i przestrzeni dyskowej**  
- âš–ï¸ Trzeba wybraÄ‡ **optymalny zestaw indeksÃ³w**, Å¼eby nie pogorszyÄ‡ ogÃ³lnej wydajnoÅ›ci

## Praktyczne aspekty uÅ¼ycia indeksÃ³w

W tej sekcji rozszerzamy temat indeksÃ³w, unikajÄ…c powtÃ³rzenia wczeÅ›niejszych przykÅ‚adÃ³w z SELECT po `customer_id`.

Przy Å‚Ä…czeniu tabel indeksy znaczÄ…co przyspieszajÄ… zapytania:

```sql
SELECT o.id, c.name
FROM orders o
JOIN customers c ON o.customer_id = c.id
WHERE c.region = 'Europe';
```

- Indeks na customers.id i orders.customer_id przyspiesza JOIN
- Indeks na customers.region przyspiesza filtrowanie po regionie


## Indeksy a sortowanie i grupowanie

Indeksy na kolumnach uÅ¼ywanych w ORDER BY lub GROUP BY pozwalajÄ… uniknÄ…Ä‡ kosztownych operacji sortowania w pamiÄ™ci:
```sql
SELECT customer_id, SUM(total) 
FROM orders 
GROUP BY customer_id 
ORDER BY SUM(total) DESC;
```

- Indeks na customer_id moÅ¼e przyspieszyÄ‡ agregacjÄ™
- Indeks kompozytowy z kolumnÄ… uÅ¼ywanÄ… w ORDER BY moÅ¼e wyeliminowaÄ‡ dodatkowe sortowanie

### ğŸ”¹ WpÅ‚yw indeksÃ³w na modyfikacje danych

- Operacje INSERT, UPDATE, DELETE wymagajÄ… aktualizacji indeksÃ³w
- Zbyt wiele indeksÃ³w moÅ¼e spowolniÄ‡ zapis danych
- W praktyce wybieramy najbardziej potrzebne indeksy i monitorujemy ich wpÅ‚yw

### ğŸ”¹ WskazÃ³wki praktyczne

- TwÃ³rz indeksy tylko na kolumnach czÄ™sto filtrowanych lub sortowanych
- Analizuj plany wykonania (EXPLAIN, EXPLAIN ANALYZE)
- Zwracaj uwagÄ™ na koszt operacji (cost=â€¦) i liczbÄ™ wierszy (rows=...)
- RÃ³wnowaÅ¼ czas odczytu i zapis danych â€“ nie kaÅ¼dy indeks jest opÅ‚acalny

