[
  {
    "objectID": "lectures/plan.html",
    "href": "lectures/plan.html",
    "title": "Relacyjne Systemy Organizacji Danych",
    "section": "",
    "text": "ğŸ“™ WYKÅAD 3 â€“ NORMALIZACJA I PROJEKTOWANIE BAZ DANYCH Temat: Jak uniknÄ…Ä‡ bÅ‚Ä™dÃ³w w projektowaniu? Cele: nauczenie zasad normalizacji, zrozumienie zaleÅ¼noÅ›ci funkcjonalnych, wprowadzenie do diagramÃ³w ERD. Zakres treÅ›ci: Problemy zÅ‚ego projektu: redundancja, anomalie aktualizacji, usuwania. PojÄ™cie zaleÅ¼noÅ›ci funkcjonalnych. Formy normalne (1NFâ€“3NF, BCNF): przykÅ‚ady i zastosowania. Diagramy ERD (Entityâ€“Relationship Diagram): encje, atrybuty, relacje, kardynalnoÅ›ci, identyfikatory. Proces projektowania bazy: analiza wymagaÅ„ â†’ model konceptualny â†’ model logiczny â†’ model fizyczny. Akcent praktyczny: Ä‡wiczenie â€“ model bazy danych dla systemu uczelnianego. Efekty uczenia siÄ™: potrafi projektowaÄ‡ relacyjnÄ… bazÄ™ danych zgodnie z zasadami normalizacji. ğŸ“’ WYKÅAD 4 â€“ TRANSAKCJE, WSPÃ“ÅBIEÅ»NOÅšÄ† I WIDOKI Temat: Mechanizmy zapewniania spÃ³jnoÅ›ci danych Cele: poznanie zasad transakcyjnoÅ›ci, zrozumienie wspÃ³Å‚bieÅ¼noÅ›ci i izolacji, wprowadzenie do widokÃ³w i ich zastosowaÅ„. Zakres treÅ›ci: PojÄ™cie transakcji i wÅ‚aÅ›ciwoÅ›ci ACID: atomicity, consistency, isolation, durability. Problemy wspÃ³Å‚bieÅ¼noÅ›ci: utracone aktualizacje, odczyty brudnych danych, blokady. Poziomy izolacji transakcji. Widoki (Views): definicja, zalety (abstrakcja, bezpieczeÅ„stwo), przykÅ‚ady CREATE VIEW, WITH CHECK OPTION. PrzykÅ‚ad â€“ transakcje w PostgreSQL (BEGIN/COMMIT/ROLLBACK). Akcent praktyczny: analiza rÃ³wnoczesnych transakcji na tej samej tabeli. Efekty uczenia siÄ™: rozumie zasady transakcyjnoÅ›ci i umie zastosowaÄ‡ widoki. ğŸ“• WYKÅAD 5 â€“ ADMINISTRACJA, BEZPIECZEÅƒSTWO I KOPIE ZAPASOWE Temat: Utrzymanie i ochrona baz danych Cele: poznanie zasad administrowania bazami danych, zrozumienie bezpieczeÅ„stwa i odpornoÅ›ci systemÃ³w bazodanowych. Zakres treÅ›ci: Role i uprawnienia uÅ¼ytkownikÃ³w: GRANT, REVOKE, zarzÄ…dzanie kontami. BezpieczeÅ„stwo danych: szyfrowanie, kontrola dostÄ™pu, logowanie zdarzeÅ„. Backup i odzyskiwanie: kopie peÅ‚ne, przyrostowe, rÃ³Å¼nicowe, replikacja i wysokie dostÄ™pnoÅ›ci (HA). Monitorowanie i optymalizacja: indeksy, analiza planÃ³w zapytaÅ„. PrzeglÄ…d systemÃ³w bazodanowych: PostgreSQL, MySQL, SQLite, MS SQL, Oracle. Efekty uczenia siÄ™: zna metody ochrony i zarzÄ…dzania bazami danych, potrafi wskazaÄ‡ strategie kopii zapasowych. ğŸ’¡ PROJEKT ZALICZENIOWY (do realizacji na Ä‡wiczeniach) Temat: Projekt i implementacja relacyjnej bazy danych wspierajÄ…cej wybrany proces organizacyjny. Etapy projektu: Analiza problemu i identyfikacja wymagaÅ„. (np. system rezerwacji sal, ewidencja sprzÄ™tu, biblioteka, wypoÅ¼yczalnia, rejestr studentÃ³w) Model konceptualny (ERD) i logiczny bazy danych. Implementacja bazy w wybranym systemie (np. PostgreSQL). WypeÅ‚nienie przykÅ‚adowymi danymi, przygotowanie zapytaÅ„ SQL. Demonstracja transakcji, widokÃ³w i podstawowych mechanizmÃ³w bezpieczeÅ„stwa. Efekty projektu: integracja wiedzy z zakresu modelowania, SQL i zarzÄ…dzania, praktyczne umiejÄ™tnoÅ›ci tworzenia bazy danych od podstaw, doÅ›wiadczenie w pracy zespoÅ‚owej i prezentacji wynikÃ³w. ğŸ“ˆ POWIÄ„ZANIE Z EFEKTAMI UCZENIA SIÄ˜ Efekt uczenia siÄ™ Odniesienie do wykÅ‚adÃ³w / projektu Zna i rozumie algorytmy i metody w systemach BD WykÅ‚ady 2â€“5 Ma wiedzÄ™ z zakresu przetwarzania danych WykÅ‚ad 1, 2 Zna standardy stosowane w BD WykÅ‚ady 2, 5 Potrafi przygotowaÄ‡ prezentacjÄ™ i prowadziÄ‡ dyskusjÄ™ Projekt zespoÅ‚owy Umie wykorzystaÄ‡ modele w realizacji projektÃ³w BD WykÅ‚ad 3 + projekt Integruje wiedzÄ™ technicznÄ… i pozatechnicznÄ… Projekt (analiza potrzeb uÅ¼ytkownika) OkreÅ›la priorytety w realizacji zadaÅ„ Projekt â€“ planowanie etapÃ³w\nnowe elementy"
  },
  {
    "objectID": "lectures/wyklad4.html",
    "href": "lectures/wyklad4.html",
    "title": "Podstawy PL/SQL, transakcje i indeksy",
    "section": "",
    "text": "PL/SQL to proceduralny jÄ™zyk rozszerzajÄ…cy SQL w systemach Oracle i kompatybilnych.\n\nUmoÅ¼liwia uÅ¼ycie instrukcji warunkowych, pÄ™tli, zmiennych i procedur, czego SQL nie oferuje w formie deklaratywnej.\n\nPrzykÅ‚ad prostego bloku PL/SQL:\nBEGIN\n    DBMS_OUTPUT.PUT_LINE('Witaj w Å›wiecie PL/SQL!');\nEND;\n/\nKod ten uruchamia blok proceduralny, ktÃ³ry wypisuje komunikat.\nBEGIN rozpoczyna blok, END; koÅ„czy, a / uruchamia go w SQL*Plus.\n\n\n\nPL/SQL pozwala tworzyÄ‡ zmienne i przypisywaÄ‡ im wartoÅ›ci.\nDECLARE\n    v_imie VARCHAR2(50);\n    v_wiek NUMBER;\nBEGIN\n    v_imie := 'Jan';\n    v_wiek := 25;\n    DBMS_OUTPUT.PUT_LINE('Student: ' || v_imie || ', wiek: ' || v_wiek);\nEND;\n/\nZmienne umoÅ¼liwiajÄ… przechowywanie danych tymczasowo w trakcie wykonywania programu.\n\n\n\nPL/SQL pozwala na uÅ¼ycie:\n\nIFâ€¦THENâ€¦ELSE:\n\nIF v_wiek &gt;= 18 THEN\n    DBMS_OUTPUT.PUT_LINE('PeÅ‚noletni');\nELSE\n    DBMS_OUTPUT.PUT_LINE('NiepeÅ‚noletni');\nEND IF;\n\nLOOP, WHILE, FOR â€“ do powtarzania operacji:\n\nFOR i IN 1..5 LOOP\n    DBMS_OUTPUT.PUT_LINE('Liczba: ' || i);\nEND LOOP;\nInstrukcje warunkowe i pÄ™tle pozwalajÄ… w peÅ‚ni programowaÄ‡ logikÄ™ w bazie danych.",
    "crumbs": [
      "KsiÄ…Å¼ki",
      "WykÅ‚ady",
      "Podstawy PL/SQL, transakcje i indeksy"
    ]
  },
  {
    "objectID": "lectures/wyklad4.html#wprowadzenie-do-plsql",
    "href": "lectures/wyklad4.html#wprowadzenie-do-plsql",
    "title": "Podstawy PL/SQL, transakcje i indeksy",
    "section": "",
    "text": "PL/SQL to proceduralny jÄ™zyk rozszerzajÄ…cy SQL w systemach Oracle i kompatybilnych.\n\nUmoÅ¼liwia uÅ¼ycie instrukcji warunkowych, pÄ™tli, zmiennych i procedur, czego SQL nie oferuje w formie deklaratywnej.\n\nPrzykÅ‚ad prostego bloku PL/SQL:\nBEGIN\n    DBMS_OUTPUT.PUT_LINE('Witaj w Å›wiecie PL/SQL!');\nEND;\n/\nKod ten uruchamia blok proceduralny, ktÃ³ry wypisuje komunikat.\nBEGIN rozpoczyna blok, END; koÅ„czy, a / uruchamia go w SQL*Plus.\n\n\n\nPL/SQL pozwala tworzyÄ‡ zmienne i przypisywaÄ‡ im wartoÅ›ci.\nDECLARE\n    v_imie VARCHAR2(50);\n    v_wiek NUMBER;\nBEGIN\n    v_imie := 'Jan';\n    v_wiek := 25;\n    DBMS_OUTPUT.PUT_LINE('Student: ' || v_imie || ', wiek: ' || v_wiek);\nEND;\n/\nZmienne umoÅ¼liwiajÄ… przechowywanie danych tymczasowo w trakcie wykonywania programu.\n\n\n\nPL/SQL pozwala na uÅ¼ycie:\n\nIFâ€¦THENâ€¦ELSE:\n\nIF v_wiek &gt;= 18 THEN\n    DBMS_OUTPUT.PUT_LINE('PeÅ‚noletni');\nELSE\n    DBMS_OUTPUT.PUT_LINE('NiepeÅ‚noletni');\nEND IF;\n\nLOOP, WHILE, FOR â€“ do powtarzania operacji:\n\nFOR i IN 1..5 LOOP\n    DBMS_OUTPUT.PUT_LINE('Liczba: ' || i);\nEND LOOP;\nInstrukcje warunkowe i pÄ™tle pozwalajÄ… w peÅ‚ni programowaÄ‡ logikÄ™ w bazie danych.",
    "crumbs": [
      "KsiÄ…Å¼ki",
      "WykÅ‚ady",
      "Podstawy PL/SQL, transakcje i indeksy"
    ]
  },
  {
    "objectID": "lectures/wyklad4.html#operacje-na-danych-w-plsql",
    "href": "lectures/wyklad4.html#operacje-na-danych-w-plsql",
    "title": "Podstawy PL/SQL, transakcje i indeksy",
    "section": "2ï¸âƒ£ Operacje na danych w PL/SQL",
    "text": "2ï¸âƒ£ Operacje na danych w PL/SQL\nPL/SQL umoÅ¼liwia wykonywanie standardowych operacji SQL:\n\nINSERT, UPDATE, DELETE â€“ bezpoÅ›rednio w blokach proceduralnych.\n\nPrzykÅ‚ad aktualizacji danych:\nBEGIN\n    UPDATE Studenci\n    SET Wiek = 26\n    WHERE NrIndeksu = 12345;\nEND;\n/\nmoÅ¼na grupowaÄ‡ wiele operacji w jednym bloku, co uÅ‚atwia zarzÄ…dzanie spÃ³jnoÅ›ciÄ… danych.",
    "crumbs": [
      "KsiÄ…Å¼ki",
      "WykÅ‚ady",
      "Podstawy PL/SQL, transakcje i indeksy"
    ]
  },
  {
    "objectID": "lectures/wyklad4.html#dlaczego-optymalizacja-jest-waÅ¼na",
    "href": "lectures/wyklad4.html#dlaczego-optymalizacja-jest-waÅ¼na",
    "title": "Podstawy PL/SQL, transakcje i indeksy",
    "section": "ğŸ’¡ Dlaczego optymalizacja jest waÅ¼na?",
    "text": "ğŸ’¡ Dlaczego optymalizacja jest waÅ¼na?\nOptymalizacja zapytaÅ„ SQL to jeden z najwaÅ¼niejszych elementÃ³w pracy z bazami danych.\nDotyczy zarÃ³wno programistÃ³w aplikacji, jak i administratorÃ³w baz danych (DBA).\nCelem jest takie przygotowanie zapytaÅ„, struktur danych i indeksÃ³w, aby uzyskaÄ‡ maksymalnÄ… wydajnoÅ›Ä‡ przy minimalnym obciÄ…Å¼eniu systemu.\nKaÅ¼de zapytanie SQL, nawet najprostsze, wymaga od silnika bazy danych wykonania okreÅ›lonych operacji: odczytu danych z dysku, przetworzenia warunkÃ³w WHERE, wykonania JOIN, GROUP BY, ORDER BY, a nastÄ™pnie zwrÃ³cenia wynikÃ³w uÅ¼ytkownikowi.\nJeÅ›li baza danych zawiera miliony rekordÃ³w, to nawet niewielkie rÃ³Å¼nice w sposobie wykonania zapytania mogÄ… oznaczaÄ‡:\n\nrÃ³Å¼nicÄ™ miÄ™dzy milisekundami a sekundami,\n\nobciÄ…Å¼enie jednego wÄ…tku zamiast caÅ‚ego serwera,\n\nlub zuÅ¼ycie gigabajtÃ³w pamiÄ™ci i I/O bez potrzeby.\n\n\nğŸ§  â€Optymalizacja zapytaÅ„ SQL to nie sztuka pisania krÃ³tszego kodu,\nlecz umiejÄ™tnoÅ›Ä‡ zmuszenia silnika bazy danych do pracy mÄ…drze, a nie ciÄ™Å¼ko.â€",
    "crumbs": [
      "KsiÄ…Å¼ki",
      "WykÅ‚ady",
      "Podstawy PL/SQL, transakcje i indeksy"
    ]
  },
  {
    "objectID": "lectures/wyklad4.html#jak-dziaÅ‚a-zapytanie-w-silniku-bazy-danych",
    "href": "lectures/wyklad4.html#jak-dziaÅ‚a-zapytanie-w-silniku-bazy-danych",
    "title": "Podstawy PL/SQL, transakcje i indeksy",
    "section": "âš™ï¸ Jak dziaÅ‚a zapytanie w silniku bazy danych?",
    "text": "âš™ï¸ Jak dziaÅ‚a zapytanie w silniku bazy danych?\nAby zrozumieÄ‡ optymalizacjÄ™, musimy wiedzieÄ‡, co dzieje siÄ™ z zapytaniem od momentu jego wysÅ‚ania do bazy danych.\nSilnik SQL analizuje skÅ‚adniÄ™ zapytania, przepisuje je logicznie, wybiera najtaÅ„szy plan wykonania i dopiero wtedy odczytuje dane.",
    "crumbs": [
      "KsiÄ…Å¼ki",
      "WykÅ‚ady",
      "Podstawy PL/SQL, transakcje i indeksy"
    ]
  },
  {
    "objectID": "lectures/wyklad4.html#co-wpÅ‚ywa-na-wydajnoÅ›Ä‡-zapytaÅ„-sql",
    "href": "lectures/wyklad4.html#co-wpÅ‚ywa-na-wydajnoÅ›Ä‡-zapytaÅ„-sql",
    "title": "Podstawy PL/SQL, transakcje i indeksy",
    "section": "ğŸ§© Co wpÅ‚ywa na wydajnoÅ›Ä‡ zapytaÅ„ SQL?",
    "text": "ğŸ§© Co wpÅ‚ywa na wydajnoÅ›Ä‡ zapytaÅ„ SQL?\nWydajnoÅ›Ä‡ zapytaÅ„ zaleÅ¼y zarÃ³wno od tego, jak zapytanie jest napisane, jak i od tego, jak zorganizowane sÄ… dane w bazie:\n\nğŸ”¹ Struktura zapytania\n\nZÅ‚oÅ¼onoÅ›Ä‡ klauzul WHERE, JOIN, ORDER BY\nZagnieÅ¼dÅ¼one podzapytania (subqueries)\nUÅ¼ycie funkcji agregujÄ…cych (COUNT, SUM, AVG)\n\n\n\nğŸ”¹ Architektura danych\n\nIloÅ›Ä‡ danych w tabelach\n\nIndeksy (ich liczba, rodzaj i aktualnoÅ›Ä‡)\n\nKlucze gÅ‚Ã³wne i obce (PRIMARY KEY, FOREIGN KEY)\n\nStopieÅ„ normalizacji lub denormalizacji danych\n\n\n\nğŸ”¹ Stan Å›rodowiska bazy\n\nDostÄ™pna pamiÄ™Ä‡ RAM\n\nBuforowanie i cache dyskowy\n\nStatystyki tabel (ANALYZE, UPDATE STATISTICS)\n\nObciÄ…Å¼enie serwera (inne procesy, sesje, transakcje)",
    "crumbs": [
      "KsiÄ…Å¼ki",
      "WykÅ‚ady",
      "Podstawy PL/SQL, transakcje i indeksy"
    ]
  },
  {
    "objectID": "lectures/wyklad4.html#przykÅ‚ad-znaczenia-optymalizacji",
    "href": "lectures/wyklad4.html#przykÅ‚ad-znaczenia-optymalizacji",
    "title": "Podstawy PL/SQL, transakcje i indeksy",
    "section": "ğŸ“Š PrzykÅ‚ad znaczenia optymalizacji",
    "text": "ğŸ“Š PrzykÅ‚ad znaczenia optymalizacji\nWyobraÅºmy sobie tabelÄ™ orders z 10 milionami zamÃ³wieÅ„.\nChcemy znaleÅºÄ‡ wszystkie zamÃ³wienia z ostatnich 30 dni:\nSELECT * FROM orders WHERE order_date &gt;= CURRENT_DATE - INTERVAL '30 days';\n\nScenariusz A â€“ brak indeksu\nSilnik musi przeskanowaÄ‡ caÅ‚Ä… tabelÄ™ (tzw. Seq Scan). KaÅ¼dy wiersz jest sprawdzany, czy speÅ‚nia warunek order_date &gt;= ....\n\nâ±ï¸ Czas wykonania: ~3.2 s\n\nğŸ’¾ Operacje I/O: wysokie\n\n\n\nScenariusz B â€“ z indeksem\nDodajemy indeks:\nCREATE INDEX idx_orders_date ON orders(order_date);\nSilnik teraz korzysta z Index Scan, czyli odczytu tylko fragmentu danych pasujÄ…cych do warunku.\n\nâ±ï¸ Czas wykonania: ~0.03 s\n\nğŸ’¾ Operacje I/O: minimalne\n\nâ¡ï¸ 100Ã— szybsze zapytanie â€“ bez zmiany jednej linijki logiki, tylko dziÄ™ki optymalizacji struktury danych.",
    "crumbs": [
      "KsiÄ…Å¼ki",
      "WykÅ‚ady",
      "Podstawy PL/SQL, transakcje i indeksy"
    ]
  },
  {
    "objectID": "lectures/wyklad4.html#jak-dziaÅ‚a-optymalizator-zapytaÅ„-sql",
    "href": "lectures/wyklad4.html#jak-dziaÅ‚a-optymalizator-zapytaÅ„-sql",
    "title": "Podstawy PL/SQL, transakcje i indeksy",
    "section": "âš™ï¸ Jak dziaÅ‚a optymalizator zapytaÅ„ SQL",
    "text": "âš™ï¸ Jak dziaÅ‚a optymalizator zapytaÅ„ SQL\nKaÅ¼de zapytanie SQL, ktÃ³re wysyÅ‚asz do bazy danych, przechodzi proces planowania i wykonania.\nSilnik SQL nie wykonuje zapytania dokÅ‚adnie tak, jak je napisaÅ‚eÅ› â€” najpierw szuka najbardziej efektywnego sposobu uzyskania tego samego wyniku.\nTym wÅ‚aÅ›nie zajmuje siÄ™ optymalizator zapytaÅ„ (Query Optimizer).",
    "crumbs": [
      "KsiÄ…Å¼ki",
      "WykÅ‚ady",
      "Podstawy PL/SQL, transakcje i indeksy"
    ]
  },
  {
    "objectID": "lectures/wyklad4.html#czym-jest-optymalizator-zapytaÅ„",
    "href": "lectures/wyklad4.html#czym-jest-optymalizator-zapytaÅ„",
    "title": "Podstawy PL/SQL, transakcje i indeksy",
    "section": "ğŸ§  Czym jest optymalizator zapytaÅ„?",
    "text": "ğŸ§  Czym jest optymalizator zapytaÅ„?\nOptymalizator analizuje zapytanie i decyduje, w jaki sposÃ³b najlepiej pobraÄ‡ dane.\nNie zmienia logiki zapytania, ale moÅ¼e caÅ‚kowicie zmieniÄ‡:\n\nkolejnoÅ›Ä‡ operacji,\n\nsposÃ³b Å‚Ä…czenia tabel (JOIN order),\n\nwybÃ³r indeksÃ³w,\n\nmetodÄ™ sortowania lub agregacji.\n\n\nğŸ’¡ Optymalizator to planista â€” nie wykonuje zapytania sam,\nale ukÅ‚ada plan dziaÅ‚ania tak, by wynik uzyskaÄ‡ jak najszybciej i najtaniej.",
    "crumbs": [
      "KsiÄ…Å¼ki",
      "WykÅ‚ady",
      "Podstawy PL/SQL, transakcje i indeksy"
    ]
  },
  {
    "objectID": "lectures/wyklad4.html#etapy-przetwarzania-zapytania",
    "href": "lectures/wyklad4.html#etapy-przetwarzania-zapytania",
    "title": "Podstawy PL/SQL, transakcje i indeksy",
    "section": "ğŸ”„ Etapy przetwarzania zapytania",
    "text": "ğŸ”„ Etapy przetwarzania zapytania\nDla przykÅ‚adu:\nSELECT name, salary \nFROM employees \nWHERE department_id = 10 AND salary &gt; 5000;\nSilnik przechodzi przez kilka logicznych etapÃ³w:\n\n1. Parsing (analiza skÅ‚adniowa)\n\nsprawdza poprawnoÅ›Ä‡ skÅ‚adni SQL,\n\nweryfikuje istnienie tabel i kolumn,\n\ntworzy drzewo zapytania (parse tree).\n\n\n\n2. Rewriting (przepisanie logiczne)\n\nupraszcza warunki (WHERE TRUE, podwÃ³jne filtry),\n\nzamienia IN na EXISTS,\n\nÅ‚Ä…czy filtry logiczne (AND, OR),\n\nmoÅ¼e przenosiÄ‡ warunki do podzapytaÅ„ (predicate pushdown).\n\n\n\n3. Optimization (planowanie kosztowe)\nOptymalizator analizuje rÃ³Å¼ne plany wykonania:\n\nktÃ³ry indeks uÅ¼yÄ‡,\n\nw jakiej kolejnoÅ›ci Å‚Ä…czyÄ‡ tabele,\n\njakiego algorytmu uÅ¼yÄ‡ (hash join, merge join, nested loop).\n\nKaÅ¼dy plan ma przypisany koszt (cost estimate) oparty na:\n\nliczbie wierszy,\n\nselektywnoÅ›ci warunkÃ³w,\n\ndostÄ™pnych indeksach,\n\nstatystykach i kosztach I/O oraz CPU.\n\n\nğŸ§® Optymalizator nie wykonuje zapytaÅ„ â€” symuluje scenariusze i wybiera ten o najniÅ¼szym koszcie.\n\n\n\n4. Execution Plan (plan wykonania)\nPo wyborze najlepszego planu, optymalizator przekazuje go do moduÅ‚u wykonawczego.\nPlan opisuje krok po kroku, jak dane zostanÄ… pobrane i przetworzone.\nMoÅ¼emy go podejrzeÄ‡ poleceniem:\nEXPLAIN SELECT ...\nlub\nEXPLAIN ANALYZE SELECT ...",
    "crumbs": [
      "KsiÄ…Å¼ki",
      "WykÅ‚ady",
      "Podstawy PL/SQL, transakcje i indeksy"
    ]
  },
  {
    "objectID": "lectures/wyklad4.html#co-to-jest-plan-zapytania",
    "href": "lectures/wyklad4.html#co-to-jest-plan-zapytania",
    "title": "Podstawy PL/SQL, transakcje i indeksy",
    "section": "âš™ï¸ Co to jest plan zapytania?",
    "text": "âš™ï¸ Co to jest plan zapytania?\nPlan zapytania to opis krokÃ³w, jakie silnik bazy danych musi wykonaÄ‡, by uzyskaÄ‡ wynik.\nKaÅ¼dy krok reprezentuje konkretnÄ… operacjÄ™ â€” np.:\n\nScan (odczyt danych z tabeli lub indeksu),\nJoin (Å‚Ä…czenie danych z kilku tabel),\nSort (sortowanie wynikÃ³w),\nAggregate (sumowanie, grupowanie, liczenie).\n\nKaÅ¼dy z tych krokÃ³w ma przypisany szacowany koszt â€” liczbowÄ… wartoÅ›Ä‡ okreÅ›lajÄ…cÄ…, ile operacji CPU, I/O lub pamiÄ™ci wymaga jego wykonanie.",
    "crumbs": [
      "KsiÄ…Å¼ki",
      "WykÅ‚ady",
      "Podstawy PL/SQL, transakcje i indeksy"
    ]
  },
  {
    "objectID": "lectures/wyklad4.html#skÅ‚adnia-polecenia-explain",
    "href": "lectures/wyklad4.html#skÅ‚adnia-polecenia-explain",
    "title": "Podstawy PL/SQL, transakcje i indeksy",
    "section": "ğŸ§© SkÅ‚adnia polecenia EXPLAIN",
    "text": "ğŸ§© SkÅ‚adnia polecenia EXPLAIN\nW wiÄ™kszoÅ›ci systemÃ³w baz danych moÅ¼na uÅ¼yÄ‡ EXPLAIN na poczÄ…tku dowolnego zapytania:\nEXPLAIN SELECT * FROM employees WHERE department_id = 10;\nAby uzyskaÄ‡ wiÄ™cej szczegÃ³Å‚Ã³w, moÅ¼na dodaÄ‡:\nEXPLAIN ANALYZE SELECT * FROM employees WHERE department_id = 10;\nğŸ“Š RÃ³Å¼nica:\n\nEXPLAIN â€” pokazuje plan teoretyczny (na podstawie statystyk i kosztÃ³w),\nEXPLAIN ANALYZE â€” faktycznie wykonuje zapytanie i pokazuje rzeczywisty czas oraz liczbÄ™ przetworzonych wierszy.\n\n\nğŸ§  PrzykÅ‚ad w PostgreSQL\nZaÅ‚Ã³Å¼my, Å¼e mamy tabelÄ™:\nCREATE TABLE orders (\n  id SERIAL PRIMARY KEY,\n  customer_id INTEGER,\n  order_date DATE,\n  total DECIMAL\n);\n\nCREATE INDEX idx_orders_customer ON orders(customer_id);\ni wykonujemy zapytanie:\nEXPLAIN ANALYZE\nSELECT * FROM orders WHERE customer_id = 42;\n\n\nğŸ”¹ Wynik (plan zapytania):\nIndex Scan using idx_orders_customer on orders  (cost=0.29..8.50 rows=3 width=48)\n  Index Cond: (customer_id = 42)\nPlanning Time: 0.100 ms\nExecution Time: 0.030 ms\n\n\n\n\n\n\n\nElement\nZnaczenie\n\n\n\n\nIndex Scan\nBaza odczytuje dane przy uÅ¼yciu indeksu (nie peÅ‚ny skan tabeli).\n\n\nidx_orders_customer\nNazwa uÅ¼ytego indeksu.\n\n\ncost=0.29..8.50\nSzacowany koszt (startowy i caÅ‚kowity). Im mniejszy, tym lepiej.\n\n\nrows=3\nSzacowana liczba wierszy, ktÃ³re speÅ‚niÄ… warunek.\n\n\nwidth=48\nÅšredni rozmiar jednego wiersza (w bajtach).\n\n\nIndex Cond\nWarunek, ktÃ³ry zostaÅ‚ uÅ¼yty do przeszukania indeksu.\n\n\nExecution Time\nFaktyczny czas wykonania (tylko w EXPLAIN ANALYZE).\n\n\n\n\n\nğŸ” PorÃ³wnanie: brak indeksu\nJeÅ›li usuniemy indeks i uruchomimy to samo zapytanie:\nEXPLAIN ANALYZE\nSELECT * FROM orders WHERE customer_id = 42;\notrzymamy:\nSeq Scan on orders  (cost=0.00..450.00 rows=3 width=48)\n  Filter: (customer_id = 42)\nExecution Time: 22.5 ms\nğŸ“‰ RÃ³Å¼nica:\n\nBaza musi przeskanowaÄ‡ caÅ‚Ä… tabelÄ™ (Seq Scan),\nPomimo tego, Å¼e wynik jest ten sam, wykonanie jest znacznie wolniejsze.\n\nğŸ’¬ EXPLAIN pokazuje, Å¼e problemem nie jest zapytanie, lecz brak indeksu.",
    "crumbs": [
      "KsiÄ…Å¼ki",
      "WykÅ‚ady",
      "Podstawy PL/SQL, transakcje i indeksy"
    ]
  },
  {
    "objectID": "lectures/wyklad4.html#jak-korzystaÄ‡-z-explain-w-praktyce",
    "href": "lectures/wyklad4.html#jak-korzystaÄ‡-z-explain-w-praktyce",
    "title": "Podstawy PL/SQL, transakcje i indeksy",
    "section": "ğŸ§® Jak korzystaÄ‡ z EXPLAIN w praktyce",
    "text": "ğŸ§® Jak korzystaÄ‡ z EXPLAIN w praktyce\n\nSprawdzaj, czy uÅ¼ywany jest indeks\n\nJeÅ›li widzisz Seq Scan lub SCAN TABLE, to znak, Å¼e indeks nie jest wykorzystywany.\n\nZwracaj uwagÄ™ na kolejnoÅ›Ä‡ JOINÃ³w\n\nCzasami odwrÃ³cenie kolejnoÅ›ci tabel w zapytaniu moÅ¼e daÄ‡ inny plan i lepszy czas.\n\nAnalizuj koszty (cost=â€¦)\n\nPorÃ³wnuj plany z rÃ³Å¼nymi indeksami i filtrami â€” wybieraj ten o niÅ¼szym koszcie.\n\nUÅ¼ywaj EXPLAIN ANALYZE tylko testowo\n\nW Å›rodowisku produkcyjnym EXPLAIN ANALYZE faktycznie wykonuje zapytanie, wiÄ™c moÅ¼e byÄ‡ kosztowne.\n\nPorÃ³wnuj teoretyczny i rzeczywisty plan\n\nJeÅ›li szacunki (rows, cost) mocno rÃ³Å¼niÄ… siÄ™ od rzeczywistego czasu, oznacza to:\n\nbrak aktualnych statystyk,\nzÅ‚y indeks,\nlub bÅ‚Ä™dne zaÅ‚oÅ¼enia optymalizatora.",
    "crumbs": [
      "KsiÄ…Å¼ki",
      "WykÅ‚ady",
      "Podstawy PL/SQL, transakcje i indeksy"
    ]
  },
  {
    "objectID": "lectures/wyklad4.html#indeksy-w-sql",
    "href": "lectures/wyklad4.html#indeksy-w-sql",
    "title": "Podstawy PL/SQL, transakcje i indeksy",
    "section": "ğŸ—‚ï¸ Indeksy w SQL",
    "text": "ğŸ—‚ï¸ Indeksy w SQL\nIndeksy to podstawowe narzÄ™dzie optymalizacji zapytaÅ„, ktÃ³re pozwala bazie danych szybko znaleÅºÄ‡ potrzebne wiersze, bez koniecznoÅ›ci skanowania caÅ‚ej tabeli.\nMoÅ¼na je porÃ³wnaÄ‡ do spisu treÅ›ci w ksiÄ…Å¼ce â€” zamiast czytaÄ‡ kaÅ¼dy rozdziaÅ‚, patrzymy od razu na wÅ‚aÅ›ciwÄ… stronÄ™.\n\nğŸ”¹ Dlaczego indeksy sÄ… waÅ¼ne?\nBez indeksu baza danych musi sprawdziÄ‡ kaÅ¼dy wiersz tabeli, by znaleÅºÄ‡ pasujÄ…ce rekordy (sequential scan).\nZ indeksem, silnik moÅ¼e odczytaÄ‡ tylko te dane, ktÃ³re speÅ‚niajÄ… warunek â€” znacznie szybciej i przy mniejszym zuÅ¼yciu zasobÃ³w.\nKorzyÅ›ci z indeksÃ³w:\n\nâ±ï¸ Szybsze wyszukiwanie danych, szczegÃ³lnie w duÅ¼ych tabelach\n\nğŸ’¾ Ograniczenie operacji I/O, bo baza czyta mniej blokÃ³w z dysku\n\nğŸ”„ Przyspieszenie sortowania i Å‚Ä…czenia tabel (JOIN), jeÅ›li indeks obejmuje kolumny uÅ¼ywane w warunkach\n\n\n\nğŸ”¹ Rodzaje indeksÃ³w\nNajczÄ™Å›ciej spotykane:\n\nB-Tree (balanced tree) â€“ najpopularniejszy typ, sprawdza siÄ™ w wiÄ™kszoÅ›ci wyszukiwaÅ„, zakresÃ³w i sortowaÅ„\n\nHash â€“ szybki dostÄ™p po dokÅ‚adnej wartoÅ›ci (nie obsÅ‚uguje zakresÃ³w)\n\nBitmap â€“ efektywny dla kolumn o maÅ‚ej liczbie unikalnych wartoÅ›ci, np. pÅ‚eÄ‡ lub status\n\nKompozytowe â€“ obejmujÄ… kilka kolumn, przydatne przy filtrach i sortowaniach wielokolumnowych\n\n\n\nğŸ”¹ Co indeksuje?\n\nKolumny uÅ¼ywane w WHERE â€“ aby szybciej wyszukaÄ‡ dane\n\nKolumny uÅ¼ywane w JOIN â€“ przyspiesza Å‚Ä…czenie tabel\n\nKolumny w ORDER BY lub GROUP BY â€“ pomaga szybciej sortowaÄ‡ i grupowaÄ‡ wyniki\n\nKolumny unikalne lub klucze gÅ‚Ã³wne â€“ zapewnia integralnoÅ›Ä‡ danych i przyspiesza wyszukiwanie\n\n\n\nğŸ”¹ Wady nadmiaru indeksÃ³w\nIndeksy przyspieszajÄ… odczyt, ale majÄ… teÅ¼ koszty:\n\nğŸ”„ Spowolnienie operacji INSERT/UPDATE/DELETE, bo indeksy trzeba aktualizowaÄ‡\n\nğŸ’¾ ZwiÄ™kszone zuÅ¼ycie pamiÄ™ci i przestrzeni dyskowej\n\nâš–ï¸ Trzeba wybraÄ‡ optymalny zestaw indeksÃ³w, Å¼eby nie pogorszyÄ‡ ogÃ³lnej wydajnoÅ›ci",
    "crumbs": [
      "KsiÄ…Å¼ki",
      "WykÅ‚ady",
      "Podstawy PL/SQL, transakcje i indeksy"
    ]
  },
  {
    "objectID": "lectures/wyklad4.html#praktyczne-aspekty-uÅ¼ycia-indeksÃ³w",
    "href": "lectures/wyklad4.html#praktyczne-aspekty-uÅ¼ycia-indeksÃ³w",
    "title": "Podstawy PL/SQL, transakcje i indeksy",
    "section": "Praktyczne aspekty uÅ¼ycia indeksÃ³w",
    "text": "Praktyczne aspekty uÅ¼ycia indeksÃ³w\nW tej sekcji rozszerzamy temat indeksÃ³w, unikajÄ…c powtÃ³rzenia wczeÅ›niejszych przykÅ‚adÃ³w z SELECT po customer_id.\nPrzy Å‚Ä…czeniu tabel indeksy znaczÄ…co przyspieszajÄ… zapytania:\nSELECT o.id, c.name\nFROM orders o\nJOIN customers c ON o.customer_id = c.id\nWHERE c.region = 'Europe';\n\nIndeks na customers.id i orders.customer_id przyspiesza JOIN\nIndeks na customers.region przyspiesza filtrowanie po regionie",
    "crumbs": [
      "KsiÄ…Å¼ki",
      "WykÅ‚ady",
      "Podstawy PL/SQL, transakcje i indeksy"
    ]
  },
  {
    "objectID": "lectures/wyklad4.html#indeksy-a-sortowanie-i-grupowanie",
    "href": "lectures/wyklad4.html#indeksy-a-sortowanie-i-grupowanie",
    "title": "Podstawy PL/SQL, transakcje i indeksy",
    "section": "Indeksy a sortowanie i grupowanie",
    "text": "Indeksy a sortowanie i grupowanie\nIndeksy na kolumnach uÅ¼ywanych w ORDER BY lub GROUP BY pozwalajÄ… uniknÄ…Ä‡ kosztownych operacji sortowania w pamiÄ™ci:\nSELECT customer_id, SUM(total) \nFROM orders \nGROUP BY customer_id \nORDER BY SUM(total) DESC;\n\nIndeks na customer_id moÅ¼e przyspieszyÄ‡ agregacjÄ™\nIndeks kompozytowy z kolumnÄ… uÅ¼ywanÄ… w ORDER BY moÅ¼e wyeliminowaÄ‡ dodatkowe sortowanie\n\n\nğŸ”¹ WpÅ‚yw indeksÃ³w na modyfikacje danych\n\nOperacje INSERT, UPDATE, DELETE wymagajÄ… aktualizacji indeksÃ³w\nZbyt wiele indeksÃ³w moÅ¼e spowolniÄ‡ zapis danych\nW praktyce wybieramy najbardziej potrzebne indeksy i monitorujemy ich wpÅ‚yw\n\n\n\nğŸ”¹ WskazÃ³wki praktyczne\n\nTwÃ³rz indeksy tylko na kolumnach czÄ™sto filtrowanych lub sortowanych\nAnalizuj plany wykonania (EXPLAIN, EXPLAIN ANALYZE)\nZwracaj uwagÄ™ na koszt operacji (cost=â€¦) i liczbÄ™ wierszy (rows=â€¦)\nRÃ³wnowaÅ¼ czas odczytu i zapis danych â€“ nie kaÅ¼dy indeks jest opÅ‚acalny",
    "crumbs": [
      "KsiÄ…Å¼ki",
      "WykÅ‚ady",
      "Podstawy PL/SQL, transakcje i indeksy"
    ]
  },
  {
    "objectID": "lectures/wyklad3.html",
    "href": "lectures/wyklad3.html",
    "title": "Normalizacja i projektowanie baz danych",
    "section": "",
    "text": "Celem wykÅ‚adu jest pokazanie, jak unikaÄ‡ bÅ‚Ä™dÃ³w podczas projektowania relacyjnych baz danych poprzez stosowanie zasad normalizacji, zrozumienie zaleÅ¼noÅ›ci funkcjonalnych oraz wykorzystanie diagramÃ³w ERD (Entityâ€“Relationship Diagram).",
    "crumbs": [
      "KsiÄ…Å¼ki",
      "WykÅ‚ady",
      "Normalizacja i projektowanie baz danych"
    ]
  },
  {
    "objectID": "lectures/wyklad3.html#temat-jak-uniknÄ…Ä‡-bÅ‚Ä™dÃ³w-w-projektowaniu",
    "href": "lectures/wyklad3.html#temat-jak-uniknÄ…Ä‡-bÅ‚Ä™dÃ³w-w-projektowaniu",
    "title": "Normalizacja i projektowanie baz danych",
    "section": "",
    "text": "Celem wykÅ‚adu jest pokazanie, jak unikaÄ‡ bÅ‚Ä™dÃ³w podczas projektowania relacyjnych baz danych poprzez stosowanie zasad normalizacji, zrozumienie zaleÅ¼noÅ›ci funkcjonalnych oraz wykorzystanie diagramÃ³w ERD (Entityâ€“Relationship Diagram).",
    "crumbs": [
      "KsiÄ…Å¼ki",
      "WykÅ‚ady",
      "Normalizacja i projektowanie baz danych"
    ]
  },
  {
    "objectID": "lectures/wyklad3.html#cele-wykÅ‚adu",
    "href": "lectures/wyklad3.html#cele-wykÅ‚adu",
    "title": "Normalizacja i projektowanie baz danych",
    "section": "ğŸ§  Cele wykÅ‚adu",
    "text": "ğŸ§  Cele wykÅ‚adu\n\nnauczenie zasad normalizacji relacyjnych baz danych,\n\nzrozumienie pojÄ™cia zaleÅ¼noÅ›ci funkcjonalnych,\n\nwprowadzenie do diagramÃ³w ERD jako narzÄ™dzia modelowania danych.",
    "crumbs": [
      "KsiÄ…Å¼ki",
      "WykÅ‚ady",
      "Normalizacja i projektowanie baz danych"
    ]
  },
  {
    "objectID": "lectures/wyklad3.html#problemy-zÅ‚ego-projektu-bazy-danych",
    "href": "lectures/wyklad3.html#problemy-zÅ‚ego-projektu-bazy-danych",
    "title": "Normalizacja i projektowanie baz danych",
    "section": "1. Problemy zÅ‚ego projektu bazy danych",
    "text": "1. Problemy zÅ‚ego projektu bazy danych\nZÅ‚e zaprojektowanie struktury bazy danych prowadzi do wielu problemÃ³w:\n\nğŸ”¹ Redundancja danych\nTo powielanie tych samych informacji w rÃ³Å¼nych miejscach bazy.\nPrzykÅ‚ad: jeÅ›li w kaÅ¼dej tabeli z zamÃ³wieniami przechowujemy peÅ‚ne dane klienta, to zmiana jego adresu wymaga aktualizacji wielu rekordÃ³w.\n\n\nğŸ”¹ Anomalie danych\nBÅ‚Ä™dy i niekonsekwencje wynikajÄ…ce z nadmiarowej struktury danych.\n\nAnomalia aktualizacji â€“ zmiana jednej informacji wymaga wielu modyfikacji.\nNp. zmiana nazwiska wykÅ‚adowcy w kilku wierszach tabeli.\nAnomalia wstawiania â€“ brak moÅ¼liwoÅ›ci dodania danych bez istnienia innych.\nNp. nie moÅ¼na dodaÄ‡ nowego kursu, dopÃ³ki nie zapisze siÄ™ na niego student.\nAnomalia usuwania â€“ usuniÄ™cie rekordu powoduje utratÄ™ innych informacji.\nNp. usuniÄ™cie ostatniego studenta z kursu powoduje utratÄ™ danych o samym kursie.\n\nğŸ‘‰ Wniosek: bÅ‚Ä™dy projektowe utrudniajÄ… utrzymanie spÃ³jnoÅ›ci danych.",
    "crumbs": [
      "KsiÄ…Å¼ki",
      "WykÅ‚ady",
      "Normalizacja i projektowanie baz danych"
    ]
  },
  {
    "objectID": "lectures/wyklad3.html#zaleÅ¼noÅ›ci-funkcjonalne",
    "href": "lectures/wyklad3.html#zaleÅ¼noÅ›ci-funkcjonalne",
    "title": "Normalizacja i projektowanie baz danych",
    "section": "2. ZaleÅ¼noÅ›ci funkcjonalne",
    "text": "2. ZaleÅ¼noÅ›ci funkcjonalne\n\nğŸ”¹ Definicja\nZaleÅ¼noÅ›Ä‡ funkcjonalna (ang. functional dependency) opisuje relacjÄ™ miÄ™dzy atrybutami w tabeli.\nMÃ³wimy, Å¼e atrybut B jest funkcyjnie zaleÅ¼ny od atrybutu A (zapis:\nA â†’ B), jeÅ›li kaÅ¼dej wartoÅ›ci A odpowiada dokÅ‚adnie jedna wartoÅ›Ä‡ B.\n\n\nğŸ”¹ PrzykÅ‚ady\n\nNrIndeksu â†’ ImiÄ™, Nazwisko, Kierunek\n(kaÅ¼dy numer indeksu jednoznacznie identyfikuje studenta)\nKurs â†’ Sala, ProwadzÄ…cy\n(dany kurs odbywa siÄ™ zawsze w tej samej sali, prowadzony przez tÄ™ samÄ… osobÄ™)\n\n\n\nğŸ”¹ Klucze\n\nKlucz gÅ‚Ã³wny (primary key) â€“ jednoznacznie identyfikuje wiersz tabeli.\n\nKlucz kandydujÄ…cy (candidate key) â€“ minimalny zestaw atrybutÃ³w, ktÃ³ry moÅ¼e byÄ‡ kluczem.\n\nKlucz obcy (foreign key) â€“ wskazuje na klucz gÅ‚Ã³wny w innej tabeli i tworzy powiÄ…zanie miÄ™dzy tabelami.\n\n\n\nğŸ”¹ Typy zaleÅ¼noÅ›ci\n\nZaleÅ¼noÅ›Ä‡ peÅ‚na â€“ atrybut zaleÅ¼y od caÅ‚ego klucza zÅ‚oÅ¼onego.\n\nZaleÅ¼noÅ›Ä‡ czÄ™Å›ciowa â€“ atrybut zaleÅ¼y tylko od czÄ™Å›ci klucza.\n\nZaleÅ¼noÅ›Ä‡ przechodnia â€“ atrybut zaleÅ¼y poÅ›rednio od klucza (A â†’ B â†’ C).",
    "crumbs": [
      "KsiÄ…Å¼ki",
      "WykÅ‚ady",
      "Normalizacja i projektowanie baz danych"
    ]
  },
  {
    "objectID": "lectures/wyklad3.html#formy-normalne-1nf-3nf-bcnf",
    "href": "lectures/wyklad3.html#formy-normalne-1nf-3nf-bcnf",
    "title": "Normalizacja i projektowanie baz danych",
    "section": "3. Formy normalne (1NF â€“ 3NF, BCNF)",
    "text": "3. Formy normalne (1NF â€“ 3NF, BCNF)\nNormalizacja to proces przeksztaÅ‚cania tabel w taki sposÃ³b, aby usunÄ…Ä‡ redundancjÄ™ i zapobiec anomaliom.\n\nğŸ§© Pierwsza postaÄ‡ normalna (1NF)\n\nWszystkie wartoÅ›ci w tabeli sÄ… atomowe (niepodzielne).\n\nBrak list, zbiorÃ³w lub kolumn powtarzajÄ…cych siÄ™.\n\nâœ… KaÅ¼da kolumna ma jednÄ… wartoÅ›Ä‡ w komÃ³rce.\nPrzykÅ‚ad (naruszenie 1NF):\n\n\n\nStudent\nNrIndeksu\nKursy\n\n\n\n\nJan Nowak\n12345\nBazy danych, Programowanie\n\n\n\nâœ… Poprawnie:\nTworzymy osobnÄ… tabelÄ™ STUDENT_KURS, gdzie kaÅ¼dy kurs to osobny rekord.\n\n\n\nğŸ§© Druga postaÄ‡ normalna (2NF)\n\nTabela jest w 1NF i wszystkie atrybuty niekluczowe zaleÅ¼Ä… w peÅ‚ni od caÅ‚ego klucza gÅ‚Ã³wnego.\n\nDotyczy tabel z kluczem zÅ‚oÅ¼onym.\n\nPrzykÅ‚ad:\nTabela ZAPISY(StudentID, KursID, Sala)\nâ†’ atrybut Sala zaleÅ¼y tylko od KursID, a nie od caÅ‚ego klucza (StudentID, KursID).\nRozwiÄ…zanie: wydziel tabelÄ™ KURS(KursID, Sala).\n\n\n\nğŸ§© Trzecia postaÄ‡ normalna (3NF)\n\nTabela jest w 2NF i nie zawiera zaleÅ¼noÅ›ci przechodnich.\n\nKaÅ¼dy atrybut niekluczowy zaleÅ¼y bezpoÅ›rednio od klucza gÅ‚Ã³wnego.\n\nPrzykÅ‚ad:\nNrIndeksu â†’ Kierunek, Kierunek â†’ Dziekan\nâ¡ï¸ Dziekan zaleÅ¼y poÅ›rednio od NrIndeksu.\nRozwiÄ…zanie: osobna tabela KIERUNEK(Dziekan, Kierunek).",
    "crumbs": [
      "KsiÄ…Å¼ki",
      "WykÅ‚ady",
      "Normalizacja i projektowanie baz danych"
    ]
  },
  {
    "objectID": "lectures/wyklad3.html#diagramy-erd-entityrelationship-diagram",
    "href": "lectures/wyklad3.html#diagramy-erd-entityrelationship-diagram",
    "title": "Normalizacja i projektowanie baz danych",
    "section": "4. Diagramy ERD (Entityâ€“Relationship Diagram)",
    "text": "4. Diagramy ERD (Entityâ€“Relationship Diagram)\nDiagram ERD jest graficznym sposobem przedstawienia modelu konceptualnego bazy danych.\n\nğŸ”¹ GÅ‚Ã³wne elementy ERD\n\nEncja (Entity) â€“ obiekt, o ktÃ³rym przechowujemy dane (np. Student, Kurs).\n\nAtrybut (Attribute) â€“ wÅ‚aÅ›ciwoÅ›Ä‡ encji (np. ImiÄ™, Nazwisko, NrIndeksu).\n\nRelacja (Relationship) â€“ powiÄ…zanie miÄ™dzy encjami (np. Student zapisuje siÄ™ na Kurs).\n\nKardynalnoÅ›Ä‡ (Cardinality) â€“ okreÅ›la licznoÅ›Ä‡ relacji:\n\n1:1 (jeden do jednego)\n\n1:N (jeden do wielu)\n\nN:M (wielu do wielu)\n\n\nIdentyfikator (Primary Key) â€“ atrybut jednoznacznie identyfikujÄ…cy encjÄ™.\n\n\n\nğŸ”¹ PrzykÅ‚ad:\nSTUDENT (NrIndeksu, ImiÄ™, Nazwisko, Kierunek)\nKURS (KursID, Nazwa, ProwadzÄ…cy)\nZAPIS (NrIndeksu, KursID, DataZapisu)\nRelacja miÄ™dzy STUDENT a KURS: N:M poprzez encjÄ™ poÅ›redniczÄ…cÄ… ZAPIS.",
    "crumbs": [
      "KsiÄ…Å¼ki",
      "WykÅ‚ady",
      "Normalizacja i projektowanie baz danych"
    ]
  },
  {
    "objectID": "lectures/wyklad3.html#proces-projektowania-bazy-danych",
    "href": "lectures/wyklad3.html#proces-projektowania-bazy-danych",
    "title": "Normalizacja i projektowanie baz danych",
    "section": "5. Proces projektowania bazy danych",
    "text": "5. Proces projektowania bazy danych\nProjektowanie bazy to proces etapowy:\n\nAnaliza wymagaÅ„ â€“ zrozumienie, jakie dane sÄ… potrzebne i jakie operacje bÄ™dÄ… wykonywane.\n\nModel konceptualny â€“ opis danych w postaci ERD.\n\nModel logiczny â€“ zamiana modelu ERD na relacyjny schemat tabel.\n\nModel fizyczny â€“ implementacja w konkretnym systemie DBMS (np. PostgreSQL, MySQL).",
    "crumbs": [
      "KsiÄ…Å¼ki",
      "WykÅ‚ady",
      "Normalizacja i projektowanie baz danych"
    ]
  },
  {
    "objectID": "cwiczenia/cw1.html",
    "href": "cwiczenia/cw1.html",
    "title": "ğŸ“˜ Od plikÃ³w pÅ‚askich do systemÃ³w zarzÄ…dzania bazami danych",
    "section": "",
    "text": "Zanim zaczniemy korzystaÄ‡ z profesjonalnych systemÃ³w zarzÄ…dzania bazami danych (DBMS), warto zrozumieÄ‡, dlaczego sÄ… one potrzebne. Na poczÄ…tku dane czÄ™sto przechowuje siÄ™ w plikach tekstowych, np. CSV (Comma Separated Values). Pliki te moÅ¼na Å‚atwo tworzyÄ‡ i edytowaÄ‡, np. w Excelu, LibreOffice czy nawet w Notatniku.\nJednak takie â€proste bazy plikoweâ€ majÄ… swoje ograniczenia:\nRelacyjne systemy baz danych, takie jak PostgreSQL czy SQLite, rozwiÄ…zujÄ… te problemy. Dane sÄ… tam przechowywane w tabelach o jasno okreÅ›lonej strukturze (kolumny, typy danych), a system dba o integralnoÅ›Ä‡ i spÃ³jnoÅ›Ä‡ informacji. Zanim jednak przejdziemy do PostgreSQL, przyjrzyjmy siÄ™, jak wyglÄ…da â€prosta baza plikowaâ€ i jak moÅ¼na jÄ… przeksztaÅ‚ciÄ‡ w prawdziwÄ… bazÄ™ danych.",
    "crumbs": [
      "KsiÄ…Å¼ki",
      "Laboratorium",
      "ğŸ“˜ Od plikÃ³w pÅ‚askich do systemÃ³w zarzÄ…dzania bazami danych"
    ]
  },
  {
    "objectID": "cwiczenia/cw1.html#plikowa-baza-danych---sqlite",
    "href": "cwiczenia/cw1.html#plikowa-baza-danych---sqlite",
    "title": "ğŸ“˜ Od plikÃ³w pÅ‚askich do systemÃ³w zarzÄ…dzania bazami danych",
    "section": "Plikowa baza danych - SQLite",
    "text": "Plikowa baza danych - SQLite\nJak wspomniano na wykÅ‚adzie, dane moÅ¼na gromadziÄ‡ w rÃ³Å¼nego rodzaju bazach danych. CzÄ™sto jednak potrzebne jest nam szybkie i Å‚atwe rozwiÄ…zanie, bez koniecznoÅ›ci mozolnego budowania architektury klient-serwer. Chcemy bowiem przechowywaÄ‡ dane w prostym pliku i edytowaÄ‡ je rÃ³wnie Å‚atwo jak w przypadku dokumentu tekstowego, takiego jak w programie Word. W takich przypadkach najbardziej optymalne jest uÅ¼ycie wÅ‚aÅ›nie SQLite. SQLite jest najczÄ™Å›ciej wykorzystywanym na Å›wiecie systemem zarzÄ…dzania bazÄ… danych. ZostaÅ‚ zastosowany w iPhonach, iPadach, w urzÄ…dzeniach z systemem operacyjnym Android i Windows Mobile. Znajdziesz go rÃ³wnieÅ¼ w termostatach, a takÅ¼e w samochodowych systemach komputerowych. Jest teÅ¼ wykorzystywany w satelitach i w wielu innych nowoczesnych urzÄ…dzeniach, w przypadku ktÃ³rych konieczne jest przechowywanie danych i proste ich przeszukiwanie. Z SQLite korzysta w duÅ¼ym stopniu zarÃ³wno system operacyjny Windows, jak i system samolotu Airbus A350 XWB. Jest on wiÄ™c stosowany wszÄ™dzie tam, gdzie istotna jest Å‚atwoÅ›Ä‡ korzystania z niego oraz niskie koszty staÅ‚e. Jest rÃ³wnieÅ¼ doskonaÅ‚y do przygotowywania prototypÃ³w baz danych dla przedsiÄ™biorstw. Jednak coÅ› za coÅ› â€” z uwagi na brak serwera zarzÄ…dzajÄ…cego dostÄ™pem do bazy danych SQLite nie moÅ¼e byÄ‡ jednoczeÅ›nie wykorzystywany przez wielu uÅ¼ytkownikÃ³w. Nie jest bowiem moÅ¼liwe edytowanie tego samego pliku przez wiele osÃ³b w tym samym czasie. Ten system zarzÄ…dzania bazÄ… danych nadaje siÄ™ natomiast Å›wietnie do celÃ³w szkoleniowych.\nEdytor bazy SQLite - sqlite studio\n\nimport sqlite3\nimport csv\n\n# PoÅ‚Ä…czenie z bazÄ… (plik .db zostanie utworzony, jeÅ›li nie istnieje)\nconn = sqlite3.connect(\"klienci.db\")\ncur = conn.cursor()\n\n# Utworzenie tabeli\ncur.execute(\"\"\"\nCREATE TABLE IF NOT EXISTS klienci (\n    dane_osobowe TEXT,\n    adres TEXT,\n    produkty INTEGER\n);\n\"\"\")\n\n# Wczytanie danych z pliku CSV\nwith open(\"klienci_produkty_v2.csv\", newline='', encoding='utf-8') as csvfile:\n    reader = csv.DictReader(csvfile)\n    for row in reader:\n        cur.execute(\"\"\"\n            INSERT INTO klienci (dane_osobowe, adres, produkty)\n            VALUES (?, ?, ?)\n        \"\"\", (row['dane_osobowe'], row['adres'], row['produkty']))\n\n# Zapisanie zmian i zamkniÄ™cie poÅ‚Ä…czenia\nconn.commit()\nconn.close()\n\nprint(\"Dane zostaÅ‚y zaimportowane do bazy danych klienci.db\")\n\nDane zostaÅ‚y zaimportowane do bazy danych klienci.db\n\n\n\nimport sqlite3\nimport pandas as pd\n\n\ndb_file = \"klienci.db\"\n\n# PoÅ‚Ä…czenie z bazÄ… SQLite (plik zostanie utworzony jeÅ›li nie istnieje)\nconn = sqlite3.connect(db_file)\ncur = conn.cursor()\n\n# Pobranie 10 pierwszych rekordÃ³w do DataFrame\ndf = pd.read_sql_query(\"SELECT * FROM klienci LIMIT 10;\", conn)\n\n# WyÅ›wietlenie DataFrame\ndf\n\n\n\n\n\n\n\n\nid\ndane_osobowe\nadres\nprodukty\n\n\n\n\n0\n1\nKatarzyna WiÅ›niewski\nul. Lipowa 1,\nSÅ‚uchawki, Router, Drukarka, Telefon\n\n\n1\n2\nAnna Grabowska\nul. Mickiewicza ,\nTelefon, Laptop, Kamera internetowa, SÅ‚uchawki\n\n\n2\n3\nMarek CzerwiÅ„ska\nul. SÅ‚oneczna ,\nRouter\n\n\n3\n4\nPiotr KrÃ³l\nul. Szkolna 27,\nMonitor, Tablet, Klawiatura\n\n\n4\n5\nMarek Kowalski\nul. Polna ,\nMonitor\n\n\n5\n6\nMichaÅ‚ WÃ³jcik\nul. Spacerowa 30,\nMysz, Monitor\n\n\n6\n7\nAnna Baran\nul. Lipowa , 30-400\nMysz\n\n\n7\n8\nAdam Kowalski\nul. Mickiewicza , 60-100\nMonitor, Drukarka\n\n\n8\n9\nMarek CzerwiÅ„ska\nul. Lipowa , 35-100 PoznaÅ„\nLaptop, SÅ‚uchawki, Router\n\n\n9\n10\nPaweÅ‚ Pawlak\nul. Spacerowa ,\nMysz, Kamera internetowa, Laptop\n\n\n\n\n\n\n\n\n# ZamkniÄ™cie poÅ‚Ä…czenia\nconn.close()\n\n\n\n\nobrazek\n\n\n\nNowa baza â€œwyklikanaâ€\nNowa baza z pliku\nProsty kod sql\nZaÅ‚adowanie tabel i danych z kodu pliku sql",
    "crumbs": [
      "KsiÄ…Å¼ki",
      "Laboratorium",
      "ğŸ“˜ Od plikÃ³w pÅ‚askich do systemÃ³w zarzÄ…dzania bazami danych"
    ]
  },
  {
    "objectID": "cwiczenia/cw1.html#ddl-w-sqlite",
    "href": "cwiczenia/cw1.html#ddl-w-sqlite",
    "title": "ğŸ“˜ Od plikÃ³w pÅ‚askich do systemÃ³w zarzÄ…dzania bazami danych",
    "section": "DDL w SQLite",
    "text": "DDL w SQLite\n\n1. Tworzenie tabeli klienci\n\nTworzymy tabelÄ™, jeÅ›li jeszcze nie istnieje\n\n\nCREATE TABLE IF NOT EXISTS klienci (\n    id INTEGER PRIMARY KEY AUTOINCREMENT,\n    dane_osobowe TEXT,    -- pole z imieniem i nazwiskiem\n    adres TEXT,           -- pole z peÅ‚nym adresem\n    produkty TEXT         -- pole z produktami, w wersji nienormalizowanej (lista w jednej komÃ³rce)\n);\n\nINSERT przykÅ‚adowego rekordu do demonstracji dziaÅ‚ania\n\nINSERT INTO klienci (dane_osobowe, adres, produkty)\nVALUES ('Jan Kowalski', 'ul. Lipowa 12, 00-001 Warszawa', 'Laptop, Telefon');\n\nSprawdzenie zawartoÅ›ci tabeli\n\n\nSELECT * FROM klienci;\n\n\n2. Dodanie dodatkowej kolumny\n\nDodajemy kolumnÄ™ â€œtypâ€ (np. kategoria klienta: standard/premium)\n\nALTER TABLE klienci ADD COLUMN typ TEXT;\n\nWstawiamy przykÅ‚adowe wartoÅ›ci dla nowych rekordÃ³w\n\nUPDATE klienci SET typ = 'standard' WHERE id = 1;\n\nSprawdzamy aktualnÄ… tabelÄ™\n\nSELECT * FROM klienci;\n\n\n3. Tworzenie indeksu\nCREATE INDEX idx_klienci_nazwisko ON klienci(dane_osobowe);\n\n\n4. Usuwanie kolumny (ograniczenia SQLite)\n\nUwaga! - SQLite nie pozwala bezpoÅ›rednio usunÄ…Ä‡ kolumny\n\n-- 1. Tworzymy nowÄ… tabelÄ™ bez kolumny \"typ\"\nCREATE TABLE klienci_nowa AS\nSELECT id, dane_osobowe, adres, produkty\nFROM klienci;\n\n-- 2. Usuwamy starÄ… tabelÄ™\nDROP TABLE klienci;\n\n-- 3. Zmieniamy nazwÄ™ nowej tabeli na starÄ…\nALTER TABLE klienci_nowa RENAME TO klienci;\n\n-- Sprawdzamy strukturÄ™ tabeli po usuniÄ™ciu kolumny\nPRAGMA table_info(klienci);\n\n\n5. Zmiana nazwy tabeli\nALTER TABLE klienci RENAME TO klienci_stara;\n\n\n6. UsuniÄ™cie tabeli\nDROP TABLE IF EXISTS klienci;\nProblemy nienormalizowanej tabeli:\n\nKolumna produkty zawiera wiele wartoÅ›ci (1â€“4 produkty w jednej komÃ³rce).\nKolumna adres moÅ¼e byÄ‡ duplikowana, jeÅ›li wielu klientÃ³w mieszka pod tym samym adresem.\nTrudno wykonywaÄ‡ analizy typu â€ktÃ³rzy klienci kupili ten sam produktâ€.\nRyzyko powielania danych i bÅ‚Ä™dÃ³w aktualizacji.",
    "crumbs": [
      "KsiÄ…Å¼ki",
      "Laboratorium",
      "ğŸ“˜ Od plikÃ³w pÅ‚askich do systemÃ³w zarzÄ…dzania bazami danych"
    ]
  },
  {
    "objectID": "cwiczenia/cw1.html#pierwsza-postaÄ‡-normalna-1nf-analiza-tabeli-klienci",
    "href": "cwiczenia/cw1.html#pierwsza-postaÄ‡-normalna-1nf-analiza-tabeli-klienci",
    "title": "ğŸ“˜ Od plikÃ³w pÅ‚askich do systemÃ³w zarzÄ…dzania bazami danych",
    "section": "Pierwsza PostaÄ‡ Normalna (1NF) â€“ analiza tabeli klienci",
    "text": "Pierwsza PostaÄ‡ Normalna (1NF) â€“ analiza tabeli klienci\nProblemy tabeli:\n\nKolumna produkty zawiera wiele wartoÅ›ci â†’ brak atomowoÅ›ci.\nBrak klucza gÅ‚Ã³wnego.\nTrudno wyszukiwaÄ‡ klientÃ³w po produktach lub adresach.\nImiÄ™ i nazwisko, adres sÄ… w jednej kolumnie.\n\n\nKrok 0: Dodanie klucza gÅ‚Ã³wnego\n\nuwaga w SQLite takÄ… kolumnÄ™ moÅ¼na dodaÄ‡ tylko podczas tworzenia tabeli.\n\n\nid INTEGER PRIMARY KEY AUTOINCREMENT;\n\nKaÅ¼dy rekord ma teraz unikalny identyfikator id.\nMoÅ¼na bezpiecznie rozdzielaÄ‡ produkty w kolejnych krokach.\n\n\n\nKrok 1 â€“ Pierwsza PostaÄ‡ Normalna (1NF)\nCel: rozdzielamy wielowartoÅ›ciowe kolumny (produkty) na osobne wiersze.\nTabela 1NF â€“ przykÅ‚adowe rekordy:\nCREATE TABLE klienci_1nf (\n    klient_id INTEGER,\n    dane_osobowe TEXT,\n    adres TEXT,\n    produkt TEXT\n);\n\n-- Wstawienie przykÅ‚adowych danych\nINSERT INTO klienci_1nf (klient_id, dane_osobowe, adres, produkt) VALUES\n(1, 'Jan Kowalski', 'ul. Lipowa 12, 00-001 Warszawa', 'Laptop'),\n(1, 'Jan Kowalski', 'ul. Lipowa 12, 00-001 Warszawa', 'Telefon'),\n(2, 'Anna Nowak', 'ul. DÅ‚uga 7, KrakÃ³w', 'Monitor'),\n(3, 'Piotr WiÅ›niewski', 'ul. Parkowa 3, ÅÃ³dÅº', 'Tablet'),\n(3, 'Piotr WiÅ›niewski', 'ul. Parkowa 3, ÅÃ³dÅº', 'Mysz'),\n(3, 'Piotr WiÅ›niewski', 'ul. Parkowa 3, ÅÃ³dÅº', 'Klawiatura');\nEfekt dydaktyczny:\n\nKaÅ¼dy wiersz zawiera jednÄ… wartoÅ›Ä‡ produktu.\nMoÅ¼emy wyszukiwaÄ‡ klientÃ³w po produkcie:\n\nSELECT dane_osobowe, adres FROM klienci_1nf WHERE produkt='Laptop';\n\n\nKrok 2 â€“ Druga PostaÄ‡ Normalna (2NF)\nCel: usuwamy redundancjÄ™ zaleÅ¼noÅ›ci czÄ™Å›ciowych\nâ€“ dane, ktÃ³re zaleÅ¼Ä… tylko od klienta (adres, imiÄ™/nazwisko), przenosimy do osobnej tabeli klienci.\nCREATE TABLE klienci_2nf (\n    klient_id INTEGER PRIMARY KEY,\n    dane_osobowe TEXT,\n    adres TEXT\n);\n\nCREATE TABLE zakupy (\n    klient_id INTEGER,\n    produkt TEXT,\n    FOREIGN KEY (klient_id) REFERENCES klienci_2nf(klient_id)\n);\n\n-- Wstawienie przykÅ‚adowych danych\nINSERT INTO klienci_2nf (klient_id, dane_osobowe, adres) VALUES\n(1, 'Jan Kowalski', 'ul. Lipowa 12, 00-001 Warszawa'),\n(2, 'Anna Nowak', 'ul. DÅ‚uga 7, KrakÃ³w'),\n(3, 'Piotr WiÅ›niewski', 'ul. Parkowa 3, ÅÃ³dÅº');\n\nINSERT INTO zakupy (klient_id, produkt) VALUES\n(1, 'Laptop'),\n(1, 'Telefon'),\n(2, 'Monitor'),\n(3, 'Tablet'),\n(3, 'Mysz'),\n(3, 'Klawiatura');\nEfekt:\n\nKlient pojawia siÄ™ tylko raz w tabeli klienci.\nTabela zakupy przechowuje produkty, a klient_id Å‚Ä…czy je z klientem.\nRedukcja redundancji i Å‚atwiejsze zarzÄ…dzanie danymi.\n\n\n\nKrok 3 â€“ Trzecia PostaÄ‡ Normalna (3NF)\nCel: peÅ‚na atomizacja danych â€“ dzielimy adres na ulicÄ™, numer, kod, miasto.\n\nimport sqlite3\nimport pandas as pd\n\n# Wczytanie CSV\ndf = pd.read_csv('klienci_produkty_v2.csv')  # kolumny: dane_osobowe, adres, produkty\n\n# Utworzenie poÅ‚Ä…czenia z bazÄ… SQLite\nconn = sqlite3.connect('klienci_normalizacja.db')\ncur = conn.cursor()\n\n# ===================================================\n# 1. Tworzymy tabele w 3NF\n# ===================================================\ncur.execute('''\nCREATE TABLE IF NOT EXISTS adresy (\n    adres_id INTEGER PRIMARY KEY AUTOINCREMENT,\n    ulica TEXT,\n    numer TEXT,\n    kod TEXT,\n    miasto TEXT\n)\n''')\n\ncur.execute('''\nCREATE TABLE IF NOT EXISTS klienci (\n    klient_id INTEGER PRIMARY KEY AUTOINCREMENT,\n    dane_osobowe TEXT,\n    adres_id INTEGER,\n    FOREIGN KEY (adres_id) REFERENCES adresy(adres_id)\n)\n''')\n\ncur.execute('''\nCREATE TABLE IF NOT EXISTS zakupy (\n    klient_id INTEGER,\n    produkt TEXT,\n    FOREIGN KEY (klient_id) REFERENCES klienci(klient_id)\n)\n''')\n\nconn.commit()\n\n# ===================================================\n# 2. WypeÅ‚nienie tabel\n# ===================================================\n\n# Pomocnicza funkcja do rozdzielania adresu\ndef rozdziel_adres(adres):\n    try:\n        # zakÅ‚adamy format: \"ul. Lipowa 12, 00-001 Warszawa\"\n        czesci = adres.split(',')\n        ulica_numer = czesci[0].strip().rsplit(' ', 1)\n        ulica = ulica_numer[0]\n        numer = ulica_numer[1] if len(ulica_numer) &gt; 1 else ''\n        kod_miasto = czesci[1].strip().split(' ', 1) if len(czesci) &gt; 1 else ['', '']\n        kod = kod_miasto[0]\n        miasto = kod_miasto[1] if len(kod_miasto) &gt; 1 else ''\n        return ulica, numer, kod, miasto\n    except:\n        return '', '', '', ''\n\n# Dodanie adresÃ³w i przypisanie adres_id\nadres_map = {}  # mapowanie peÅ‚nego adresu na adres_id\nfor index, row in df.iterrows():\n    adres = row['adres']\n    if adres not in adres_map:\n        ulica, numer, kod, miasto = rozdziel_adres(adres)\n        cur.execute('''\n            INSERT INTO adresy (ulica, numer, kod, miasto)\n            VALUES (?, ?, ?, ?)\n        ''', (ulica, numer, kod, miasto))\n        adres_id = cur.lastrowid\n        adres_map[adres] = adres_id\n\n    # Dodanie klienta\n    cur.execute('''\n        INSERT INTO klienci (dane_osobowe, adres_id)\n        VALUES (?, ?)\n    ''', (row['dane_osobowe'], adres_map[adres]))\n    klient_id = cur.lastrowid\n\n    # Rozdzielenie produktÃ³w i dodanie do zakupy\n    produkty = [p.strip() for p in str(row['produkty']).split(',')]\n    for produkt in produkty:\n        if produkt:  # pomijamy puste\n            cur.execute('''\n                INSERT INTO zakupy (klient_id, produkt)\n                VALUES (?, ?)\n            ''', (klient_id, produkt))\n\nconn.commit()\nconn.close()\n\nprint(\"Import i normalizacja zakoÅ„czone!\")\n\nImport i normalizacja zakoÅ„czone!\n\n\nOpis dziaÅ‚ania:\n\nAdresy sÄ… rozdzielane na ulica, numer, kod, miasto â†’ tabela adresy.\nKlienci trafiajÄ… do tabeli klienci z adres_id.\nProdukty sÄ… rozdzielane i dodawane do tabeli zakupy.\nKaÅ¼dy klient ma unikalny klient_id, wiÄ™c jeÅ›li kupiÅ‚ kilka produktÃ³w, w zakupy bÄ™dzie kilka wierszy.\n\n\nimport sqlite3\nimport pandas as pd\n\nconn = sqlite3.connect('klienci_normalizacja.db')\n\n# WyÅ›wietlenie 10 pierwszych klientÃ³w\ndf_klienci = pd.read_sql('SELECT * FROM klienci LIMIT 10', conn)\ndf_klienci.head(10)\n\n\n\n\n\n\n\n\nklient_id\ndane_osobowe\nadres_id\n\n\n\n\n0\n1\nKatarzyna WiÅ›niewski\n1\n\n\n1\n2\nAnna Grabowska\n2\n\n\n2\n3\nMarek CzerwiÅ„ska\n3\n\n\n3\n4\nPiotr KrÃ³l\n4\n\n\n4\n5\nMarek Kowalski\n5\n\n\n5\n6\nMichaÅ‚ WÃ³jcik\n6\n\n\n6\n7\nAnna Baran\n7\n\n\n7\n8\nAdam Kowalski\n8\n\n\n8\n9\nMarek CzerwiÅ„ska\n9\n\n\n9\n10\nPaweÅ‚ Pawlak\n10\n\n\n\n\n\n\n\n\n# WyÅ›wietlenie 10 pierwszych zakupÃ³w\ndf_zakupy = pd.read_sql('SELECT * FROM zakupy LIMIT 10', conn)\ndf_zakupy\n\n\n\n\n\n\n\n\nklient_id\nprodukt\n\n\n\n\n0\n1\nSÅ‚uchawki\n\n\n1\n1\nRouter\n\n\n2\n1\nDrukarka\n\n\n3\n1\nTelefon\n\n\n4\n2\nTelefon\n\n\n5\n2\nLaptop\n\n\n6\n2\nKamera internetowa\n\n\n7\n2\nSÅ‚uchawki\n\n\n8\n3\nRouter\n\n\n9\n4\nMonitor\n\n\n\n\n\n\n\n\nconn.close()\n\nNormalizacja tabeli klienci â€“ peÅ‚ne podsumowanie\nTabela poczÄ…tkowa (przed normalizacjÄ…)\n\nNazwa tabeli: klienci\nLiczba kolumn: 3 (dane_osobowe, adres, produkty)\nTypy danych: wszystkie TEXT (nienormalizowane)\nProblemy:\nBrak klucza gÅ‚Ã³wnego â†’ brak jednoznacznej identyfikacji rekordu.\nWielowartoÅ›ciowa kolumna produkty â†’ zÅ‚amanie zasad atomowoÅ›ci.\nImiÄ™/nazwisko i adres w jednej kolumnie â†’ brak peÅ‚nej atomowoÅ›ci.\nTrudnoÅ›ci w analizie i wyszukiwaniu.\n\nâ¸»\nProces normalizacji krok po kroku\nKrok 0 â€“ Dodanie klucza gÅ‚Ã³wnego\n\nKolumna id jako PRIMARY KEY.\nKaÅ¼dy rekord jednoznacznie identyfikowany.\n\nKrok 1 â€“ 1NF\n\nRozdzielenie wielowartoÅ›ciowej kolumny produkty na osobne wiersze.\nJeden wiersz = jeden klient + jeden produkt.\nCel: kaÅ¼da kolumna jest atomowa.\n\nKrok 2 â€“ 2NF\n\nRozdzielenie danych, ktÃ³re zaleÅ¼Ä… tylko od klienta (adres, imiÄ™/nazwisko), do osobnej tabeli klienci.\nProdukty przeniesione do tabeli zakupy.\nRelacja: klient_id w zakupy â†’ klient_id w klienci (1:N).\n\nKrok 3 â€“ 3NF\n\nRozdzielenie adresu na atomowe kolumny: ulica, numer, kod, miasto â†’ tabela adresy.\nW tabeli klienci pozostaje tylko adres_id jako klucz obcy.\nRelacje:\nklienci.adres_id â†’ adresy.adres_id (1:1)\nzakupy.klient_id â†’ klienci.klient_id (1:N)\n\n\nimport pandas as pd\n\n# Wczytanie CSV\ndf = pd.read_csv('klienci_produkty_v2.csv')  # kolumny: dane_osobowe, adres, produkty\n\n# Plik wynikowy SQL\nsql_file = open('klienci_3nf.sql', 'w', encoding='utf-8')\n\n# ===================================================\n# 1. Tworzenie tabel\n# ===================================================\nsql_file.write(\"\"\"\n-- Tabele w 3NF\nCREATE TABLE IF NOT EXISTS adresy (\n    adres_id INTEGER PRIMARY KEY AUTOINCREMENT,\n    ulica TEXT,\n    numer TEXT,\n    kod TEXT,\n    miasto TEXT\n);\n\nCREATE TABLE IF NOT EXISTS klienci (\n    klient_id INTEGER PRIMARY KEY AUTOINCREMENT,\n    dane_osobowe TEXT,\n    adres_id INTEGER,\n    FOREIGN KEY (adres_id) REFERENCES adresy(adres_id)\n);\n\nCREATE TABLE IF NOT EXISTS zakupy (\n    klient_id INTEGER,\n    produkt TEXT,\n    FOREIGN KEY (klient_id) REFERENCES klienci(klient_id)\n);\n\n\"\"\")\n\n# ===================================================\n# 2. Generowanie INSERT dla wszystkich danych\n# ===================================================\nadres_map = {}  # mapowanie peÅ‚nego adresu na adres_id\nadres_id_counter = 1\nklient_id_counter = 1\n\ndef rozdziel_adres(adres):\n    try:\n        czesci = adres.split(',')\n        ulica_numer = czesci[0].strip().rsplit(' ', 1)\n        ulica = ulica_numer[0]\n        numer = ulica_numer[1] if len(ulica_numer) &gt; 1 else ''\n        kod_miasto = czesci[1].strip().split(' ', 1) if len(czesci) &gt; 1 else ['', '']\n        kod = kod_miasto[0]\n        miasto = kod_miasto[1] if len(kod_miasto) &gt; 1 else ''\n        return ulica, numer, kod, miasto\n    except:\n        return '', '', '', ''\n\nfor index, row in df.iterrows():\n    adres = row['adres']\n    if adres not in adres_map:\n        ulica, numer, kod, miasto = rozdziel_adres(adres)\n        sql_file.write(f\"INSERT INTO adresy (adres_id, ulica, numer, kod, miasto) VALUES ({adres_id_counter}, '{ulica.replace('\\'','\\'\\'')}', '{numer}', '{kod}', '{miasto}');\\n\")\n        adres_map[adres] = adres_id_counter\n        adres_id_counter += 1\n\n    # Dodanie klienta\n    sql_file.write(f\"INSERT INTO klienci (klient_id, dane_osobowe, adres_id) VALUES ({klient_id_counter}, '{row['dane_osobowe'].replace('\\'','\\'\\'')}', {adres_map[adres]});\\n\")\n\n    # Rozdzielenie produktÃ³w\n    produkty = [p.strip() for p in str(row['produkty']).split(',')]\n    for produkt in produkty:\n        if produkt:\n            sql_file.write(f\"INSERT INTO zakupy (klient_id, produkt) VALUES ({klient_id_counter}, '{produkt.replace('\\'','\\'\\'')}');\\n\")\n\n    klient_id_counter += 1\n\nsql_file.close()\nprint(\"Plik SQL 'klienci_3nf.sql' zostaÅ‚ wygenerowany!\")\n\nPlik SQL 'klienci_3nf.sql' zostaÅ‚ wygenerowany!",
    "crumbs": [
      "KsiÄ…Å¼ki",
      "Laboratorium",
      "ğŸ“˜ Od plikÃ³w pÅ‚askich do systemÃ³w zarzÄ…dzania bazami danych"
    ]
  },
  {
    "objectID": "cwiczenia/cw1.html#serwer-baz-danych",
    "href": "cwiczenia/cw1.html#serwer-baz-danych",
    "title": "ğŸ“˜ Od plikÃ³w pÅ‚askich do systemÃ³w zarzÄ…dzania bazami danych",
    "section": "Serwer baz danych",
    "text": "Serwer baz danych\nPostgreSQL to relacyjny system zarzÄ…dzania bazÄ… danych (RDBMS â€“ Relational Database Management System), naleÅ¼Ä…cy do najbardziej zaawansowanych i niezawodnych rozwiÄ…zaÅ„ typu open source. UmoÅ¼liwia on tworzenie, przechowywanie i przetwarzanie danych w sposÃ³b zgodny z zasadami modelu relacyjnego, zapewniajÄ…c jednoczeÅ›nie obsÅ‚ugÄ™ transakcji, integralnoÅ›Ä‡ danych, bezpieczeÅ„stwo oraz wysokÄ… wydajnoÅ›Ä‡.\nDo pracy z PostgreSQL czÄ™sto wykorzystuje siÄ™ narzÄ™dzie pgAdmin â€“ graficzny interfejs uÅ¼ytkownika (GUI), ktÃ³ry pozwala w wygodny sposÃ³b zarzÄ…dzaÄ‡ serwerem i bazami danych, wykonywaÄ‡ zapytania SQL, projektowaÄ‡ struktury tabel oraz analizowaÄ‡ dane. DziÄ™ki pgAdmin uÅ¼ytkownik moÅ¼e Å‚Ä…czyÄ‡ siÄ™ z serwerem PostgreSQL, przeglÄ…daÄ‡ obiekty bazy (schematy, tabele, widoki, funkcje), a takÅ¼e monitorowaÄ‡ jej dziaÅ‚anie.\nPostgreSQL dziaÅ‚a w architekturze klientâ€“serwer. Oznacza to, Å¼e serwer baz danych (program postgres) dziaÅ‚a w tle i odpowiada za przechowywanie oraz zarzÄ…dzanie danymi, natomiast klienci (np. pgAdmin, aplikacje webowe, skrypty w Pythonie) Å‚Ä…czÄ… siÄ™ z nim za pomocÄ… sieciowego protokoÅ‚u i wysyÅ‚ajÄ… polecenia SQL. Serwer przetwarza te polecenia, wykonuje operacje na danych i zwraca wyniki do klienta. Takie rozwiÄ…zanie pozwala wielu uÅ¼ytkownikom lub aplikacjom jednoczeÅ›nie korzystaÄ‡ z tej samej bazy danych w sposÃ³b bezpieczny i kontrolowany.\nW trakcie laboratorium bÄ™dziemy korzystaÄ‡ z PostgreSQL i pgAdmin, aby poznaÄ‡ zasady dziaÅ‚ania relacyjnych systemÃ³w baz danych â€“ od projektowania schematÃ³w danych, poprzez tworzenie tabel i relacji, aÅ¼ po wykonywanie zapytaÅ„ SQL i analizÄ™ wynikÃ³w.",
    "crumbs": [
      "KsiÄ…Å¼ki",
      "Laboratorium",
      "ğŸ“˜ Od plikÃ³w pÅ‚askich do systemÃ³w zarzÄ…dzania bazami danych"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Informacje ogÃ³lne",
    "section": "",
    "text": "Kod:\nSemestr: letni",
    "crumbs": [
      "KsiÄ…Å¼ki",
      "Informacje ogÃ³lne"
    ]
  },
  {
    "objectID": "index.html#relacyjne-systemy-organizacji-danych",
    "href": "index.html#relacyjne-systemy-organizacji-danych",
    "title": "Informacje ogÃ³lne",
    "section": "",
    "text": "Kod:\nSemestr: letni",
    "crumbs": [
      "KsiÄ…Å¼ki",
      "Informacje ogÃ³lne"
    ]
  },
  {
    "objectID": "index.html#kalendarz",
    "href": "index.html#kalendarz",
    "title": "Informacje ogÃ³lne",
    "section": "Kalendarz",
    "text": "Kalendarz\n\nWykÅ‚ad dla grup: WEL23EV1S0, WEL23EA1S0\n\n\n09.10.2025 Czwartek WykÅ‚ad 1 - b. 61 sala 116 (3-4)\n\n\n14.10.2025 Wtorek WykÅ‚ad 2 - b. 61 sala 116 (9-10)\n\n\n15.10.2025 Åšroda WykÅ‚ad 3 - b. 61 sala 116 (3-4)\n\n\n29.10.2025 Åšroda WykÅ‚ad 4 - b. 61 sala 116 (9-10)\n\n\n30.10.2025 Czwartek WykÅ‚ad 5 - b. 61 sala 116 (5-6)\n\n\n\n\nLaboratorium grupa WEL23EV1S0:\n\n25.11.2025 Wtorek - b. 61 sala 116\n04.12.2025 czwartek - b. 61 sala 116\n18.12.2025 czwartek - b. 61 sala 116\n08.01.2026 Czwartek - b. 61 sala 116\n22.01.2026 czwartek - b. 61 sala 116\n\n\n\nLaboratorium grupa WEL23EA1S0:\n\n13.11.2025 Czwartek Lab - b. 61 sala 116\n26.11.2025 Å›roda Lab - b. 61 sala 116\n11.12.2025 czwartek - b. 61 sala 116\n15.01.2026 czwartek - b. 61 sala 116\n21.01.2026 Å›roda - b. 61 sala 116",
    "crumbs": [
      "KsiÄ…Å¼ki",
      "Informacje ogÃ³lne"
    ]
  },
  {
    "objectID": "ksiazki.html",
    "href": "ksiazki.html",
    "title": "KsiÄ…Å¼ki i strony WWW",
    "section": "",
    "text": "C.J. Date, An Introduction to Database Systems\nR. Elmasri, S.B. Navathe, Fundamentals of Database Systems\nDokumentacja PostgreSQL: https://www.postgresql.org/docs/"
  },
  {
    "objectID": "ksiazki.html#ksiÄ…Å¼ki",
    "href": "ksiazki.html#ksiÄ…Å¼ki",
    "title": "KsiÄ…Å¼ki i strony WWW",
    "section": "",
    "text": "C.J. Date, An Introduction to Database Systems\nR. Elmasri, S.B. Navathe, Fundamentals of Database Systems\nDokumentacja PostgreSQL: https://www.postgresql.org/docs/"
  },
  {
    "objectID": "cwiczenia/cw2.html",
    "href": "cwiczenia/cw2.html",
    "title": "Serwer baz danych - PostgreSQL",
    "section": "",
    "text": "PostgreSQL to relacyjny system zarzÄ…dzania bazÄ… danych (RDBMS â€“ Relational Database Management System), naleÅ¼Ä…cy do najbardziej zaawansowanych i niezawodnych rozwiÄ…zaÅ„ typu open source. UmoÅ¼liwia on tworzenie, przechowywanie i przetwarzanie danych w sposÃ³b zgodny z zasadami modelu relacyjnego, zapewniajÄ…c jednoczeÅ›nie obsÅ‚ugÄ™ transakcji, integralnoÅ›Ä‡ danych, bezpieczeÅ„stwo oraz wysokÄ… wydajnoÅ›Ä‡.\nDo pracy z PostgreSQL czÄ™sto wykorzystuje siÄ™ narzÄ™dzie pgAdmin â€“ graficzny interfejs uÅ¼ytkownika (GUI), ktÃ³ry pozwala w wygodny sposÃ³b zarzÄ…dzaÄ‡ serwerem i bazami danych, wykonywaÄ‡ zapytania SQL, projektowaÄ‡ struktury tabel oraz analizowaÄ‡ dane. DziÄ™ki pgAdmin uÅ¼ytkownik moÅ¼e Å‚Ä…czyÄ‡ siÄ™ z serwerem PostgreSQL, przeglÄ…daÄ‡ obiekty bazy (schematy, tabele, widoki, funkcje), a takÅ¼e monitorowaÄ‡ jej dziaÅ‚anie.\nPostgreSQL dziaÅ‚a w architekturze klientâ€“serwer. Oznacza to, Å¼e serwer baz danych (program postgres) dziaÅ‚a w tle i odpowiada za przechowywanie oraz zarzÄ…dzanie danymi, natomiast klienci (np. pgAdmin, aplikacje webowe, skrypty w Pythonie) Å‚Ä…czÄ… siÄ™ z nim za pomocÄ… sieciowego protokoÅ‚u i wysyÅ‚ajÄ… polecenia SQL. Serwer przetwarza te polecenia, wykonuje operacje na danych i zwraca wyniki do klienta. Takie rozwiÄ…zanie pozwala wielu uÅ¼ytkownikom lub aplikacjom jednoczeÅ›nie korzystaÄ‡ z tej samej bazy danych w sposÃ³b bezpieczny i kontrolowany.\nW trakcie laboratorium bÄ™dziemy korzystaÄ‡ z PostgreSQL i pgAdmin, aby poznaÄ‡ zasady dziaÅ‚ania relacyjnych systemÃ³w baz danych â€“ od projektowania schematÃ³w danych, poprzez tworzenie tabel i relacji, aÅ¼ po wykonywanie zapytaÅ„ SQL i analizÄ™ wynikÃ³w.",
    "crumbs": [
      "KsiÄ…Å¼ki",
      "Laboratorium",
      "Serwer baz danych - PostgreSQL"
    ]
  },
  {
    "objectID": "cwiczenia/cw2.html#analiza-bazy-danych-i-Ä‡wiczenia-sql-postgresql",
    "href": "cwiczenia/cw2.html#analiza-bazy-danych-i-Ä‡wiczenia-sql-postgresql",
    "title": "Serwer baz danych - PostgreSQL",
    "section": "ğŸ“Š Analiza Bazy Danych i Ä†wiczenia SQL (PostgreSQL)",
    "text": "ğŸ“Š Analiza Bazy Danych i Ä†wiczenia SQL (PostgreSQL)\nPoniÅ¼szy materiaÅ‚ omawia podstawowe operacje na bazie danych, wykorzystujÄ…c przykÅ‚adowÄ… tabelÄ™ teachers. Zawiera rÃ³wnieÅ¼ propozycje bardziej zaawansowanych Ä‡wiczeÅ„, w tym tworzenie indeksÃ³w i wykorzystanie zagnieÅ¼dÅ¼onych zapytaÅ„ (Subqueries), oraz odniesienia do funkcji systemowych PostgreSQL.\nPolecenie SQL,Opis CREATE TABLE teachers,Tworzy tabelÄ™ przechowujÄ…cÄ… dane o nauczycielach. INSERT INTO teachers,Dodaje rekordy (wiersze) do tabeli. SELECT * FROM teachers,WyÅ›wietla wszystkie dane ze wszystkich kolumn w tabeli.\nCREATE TABLE teachers (\n    id bigserial,\n    first_name varchar(25),\n    last_name varchar(50),\n    school varchar(50),\n    hire_date date,\n    salary numeric\n);\nPrzykÅ‚adowe dane\nINSERT INTO teachers (first_name, last_name, school, hire_date, salary)\nVALUES ('Janet', 'Smith', 'F.D. Roosevelt HS', '2011-10-30', 36200), \n('Lee', 'Reynolds', 'F.D. Roosevelt HS', '1993-05-22', 65000),\n('Samuel', 'Cole', 'Myers Middle School', '2005-08-01', 43500),\n('Samantha', 'Bush', 'Myers Middle School', '2011-10-30', 36200),\n('Betty', 'Diaz', 'Myers Middle School', '2005-08-30', 43500),\n('Kathleen', 'Roush', 'F.D. Roosevelt HS', '2010-10-22', 38500);\n\n2. Filtrowanie i Sortowanie Danych\n\n2.1. Filtrowanie Kolumn (SELECT)\nWybranie tylko konkretnych kolumn jest pierwszÄ… zasadÄ… optymalizacji zapytaÅ„ â€“ wybieraj tylko to, co jest potrzebne.\nSELECT last_name, first_name, salary FROM teachers;\n\n\n\n2.2. Sortowanie (ORDER BY)\nPozwala uporzÄ…dkowaÄ‡ wyniki. DESC (Descending) oznacza malejÄ…co, ASC (Ascending) oznacza rosnÄ…co (domyÅ›lne). Sortowanie moÅ¼na wykonaÄ‡ po nazwie kolumny, lub po jej numerze porzÄ…dkowym (liczÄ…c od 1).\n\nSortowanie malejÄ…co po pensji.\nSELECT first_name, last_name, salary FROM teachers ORDER BY salary DESC;\n\n\nSortowanie malejÄ…co po trzeciej kolumnie (salary).\nSELECT first_name, last_name, salary FROM teachers ORDER BY 3 DESC;\n\n\nSortowanie po wielu kolumnach: najpierw rosnÄ…co wg szkoÅ‚y, a w ramach szkoÅ‚y malejÄ…co wg daty zatrudnienia.\nSELECT last_name, school, hire_date FROM teachers ORDER BY school ASC, hire_date DESC;\n\n\n\n2.3. Eliminacja DuplikatÃ³w (DISTINCT)\nUÅ¼ywane do wyÅ›wietlenia unikalnych wartoÅ›ci.\n-- WyÅ›wietl unikalne nazwy szkÃ³Å‚\nSELECT DISTINCT school FROM teachers ORDER BY school;\n\n-- WyÅ›wietl unikalne kombinacje szkoÅ‚y i pensji\nSELECT DISTINCT school, salary FROM teachers ORDER BY school, salary;\n\n\n3. Filtrowanie Wierszy (WHERE)\nKlucz do precyzyjnego pobierania danych.\n\nRÃ³wnoÅ›Ä‡ (=),\nWHERE school = 'Myers Middle School';\nWybiera nauczycieli z konkretnej szkoÅ‚y.\n\n\nRÃ³Å¼noÅ›Ä‡ (&lt;&gt; lub !=),\nWHERE school &lt;&gt; 'F.D. Roosevelt HS';\nWybiera nauczycieli ze wszystkich szkÃ³Å‚ oprÃ³cz podanej.\n\n\nPorÃ³wnanie (&lt;, &gt;, &lt;=, &gt;=)\nWHERE hire_date &lt; '2000-01-01';\n,Wybiera zatrudnionych przed 2000 rokiem.\n\n\nZakres (BETWEEN)\nWHERE salary BETWEEN 40000 AND 65000\n,Wybiera pensje wÅ‚Ä…cznie z kraÅ„cami zakresu (rÃ³wnowaÅ¼ne: salary &gt;= 40000 AND salary &lt;= 65000).\n\n\nWzorce (LIKE / ILIKE)\nWHERE first_name LIKE 'sam%'\nlub\nWHERE first_name ILIKE 'sam%'\n,LIKE jest czuÅ‚e na wielkoÅ›Ä‡ liter;\nILIKE jest nieczuÅ‚e na wielkoÅ›Ä‡ liter (preferowane w PostgreSQL).\n% oznacza dowolnÄ… liczbÄ™ znakÃ³w.\n\n\n\n3.1. Operatory Logiczne (AND, OR)\n-- AND: Oba warunki muszÄ… byÄ‡ speÅ‚nione\nSELECT * FROM teachers\nWHERE school = 'Myers Middle School'\nAND salary &lt; 40000;\n\n-- OR: Wystarczy, Å¼e jeden warunek jest speÅ‚niony\nSELECT * FROM teachers\nWHERE last_name = 'Cole'\nOR last_name = 'Bush';\n\n-- ÅÄ…czenie AND i OR (nawiasy sÄ… kluczowe!)\nSELECT * FROM teachers\nWHERE school = 'F.D. Roosevelt HS'\nAND (salary &lt; 38000 OR salary &gt; 40000);\n\n\n3.2. Wyszukiwanie z Wzorem (LIKE z %)\nSELECT first_name, last_name, school, hire_date, salary\nFROM teachers\nWHERE school LIKE '%Roos%' -- Znajduje szkoÅ‚y, w ktÃ³rych nazwie wystÄ™puje 'Roos'\nORDER BY hire_date DESC;",
    "crumbs": [
      "KsiÄ…Å¼ki",
      "Laboratorium",
      "Serwer baz danych - PostgreSQL"
    ]
  },
  {
    "objectID": "cwiczenia/cw2.html#zaawansowane-subqueries-joins-indexing",
    "href": "cwiczenia/cw2.html#zaawansowane-subqueries-joins-indexing",
    "title": "Serwer baz danych - PostgreSQL",
    "section": "ğŸš€ Zaawansowane (Subqueries, JOINs, Indexing)",
    "text": "ğŸš€ Zaawansowane (Subqueries, JOINs, Indexing)\n\nProponowane Nowe Tabele\nAby umoÅ¼liwiÄ‡ Ä‡wiczenie relacji i zapytaÅ„ zagnieÅ¼dÅ¼onych, dodajmy tabelÄ™ students (studenci) i tabelÄ™ classes (przedmioty/klasy).\n-- Tabela PrzedmiotÃ³w (Classes)\nCREATE TABLE classes (\n    class_id serial PRIMARY KEY,\n    class_name varchar(100) NOT NULL,\n    teacher_id bigint REFERENCES teachers(id), -- Klucz obcy do tabeli teachers\n    grade_level varchar(10)\n);\n\n-- PrzykÅ‚adowe dane do classes\nINSERT INTO classes (class_name, teacher_id, grade_level) VALUES\n('Mathematics 101', 2, '10th'),\n('English Literature', 1, '9th'),\n('World History', 3, '11th');\n\n-- Tabela StudentÃ³w (Students)\nCREATE TABLE students (\n    student_id bigserial PRIMARY KEY,\n    first_name varchar(25),\n    last_name varchar(50),\n    enrollment_date date,\n    class_id bigint REFERENCES classes(class_id) -- Klucz obcy do tabeli classes\n);\n\n-- PrzykÅ‚adowe dane do students\nINSERT INTO students (first_name, last_name, enrollment_date, class_id) VALUES\n('Anna', 'Kowalska', '2023-09-01', 1),\n('Piotr', 'Nowak', '2023-09-01', 1),\n('Ewa', 'WiÅ›niewska', '2023-09-01', 2);\n\n\nZapytania w Zapytaniach (Subqueries)\nZapytanie wewnÄ™trzne (subquery) jest wykonywane jako pierwsze i zwraca wynik, ktÃ³ry jest uÅ¼ywany przez zapytanie zewnÄ™trzne.\n\nZnalezienie nauczycieli z najwyÅ¼szÄ… pensjÄ…:\n\nSELECT first_name, last_name FROM teachers WHERE salary = (SELECT MAX(salary) FROM teachers);\n\nZnalezienie nauczycieli, ktÃ³rzy prowadzÄ… klasy dla â€˜10thâ€™ grade:,\n\nSELECT first_name, last_name FROM teachers WHERE id IN (SELECT teacher_id FROM classes WHERE grade_level = '10th');\n\nWyÅ›wietlenie studentÃ³w, ktÃ³rych nauczyciel ma pensjÄ™ powyÅ¼ej Å›redniej:\n\nSELECT s.first_name, s.last_name FROM students s JOIN classes c ON s.class_id = c.class_id JOIN teachers t ON c.teacher_id = t.id WHERE t.salary &gt; (SELECT AVG(salary) FROM teachers);",
    "crumbs": [
      "KsiÄ…Å¼ki",
      "Laboratorium",
      "Serwer baz danych - PostgreSQL"
    ]
  },
  {
    "objectID": "cwiczenia/cw2.html#indeksowanie-w-postgresql",
    "href": "cwiczenia/cw2.html#indeksowanie-w-postgresql",
    "title": "Serwer baz danych - PostgreSQL",
    "section": "ğŸ’¡ Indeksowanie w PostgreSQL",
    "text": "ğŸ’¡ Indeksowanie w PostgreSQL\nIndeksy sÅ‚uÅ¼Ä… do szybszego wyszukiwania danych, dziaÅ‚ajÄ…c podobnie do spisu treÅ›ci w ksiÄ…Å¼ce. SÄ… kluczowe dla optymalizacji wydajnoÅ›ci, zwÅ‚aszcza w duÅ¼ych tabelach.\n\nTworzenie Indeksu\nZaleca siÄ™ tworzenie indeksÃ³w na kolumnach czÄ™sto uÅ¼ywanych w klauzulach WHERE, JOIN i ORDER BY.\n-- Tworzenie indeksu na kolumnie school w tabeli teachers\nCREATE INDEX idx_teachers_school ON teachers (school);\n\n\nWeryfikacja DziaÅ‚ania Indeksu (EXPLAIN ANALYZE)\nAby sprawdziÄ‡, czy PostgreSQL uÅ¼ywa indeksu i jak wpÅ‚ywa to na czas wykonania zapytania, uÅ¼yj polecenia EXPLAIN ANALYZE.\n\nWeryfikacja przyspieszenia po indeksowaniu:\n\nEXPLAIN ANALYZE SELECT * FROM teachers WHERE school = 'Myers Middle School';\nAnaliza zapytania bez uÅ¼ycia indeksu:,\nâ€œPo wykonaniu EXPLAIN ANALYZE, poszukaj w wynikach fraz takich jakâ€â€œIndex Scanâ€â€ (indeks zostaÅ‚ uÅ¼yty) lub â€œâ€œSeq Scanâ€â€ (skan sekwencyjny/caÅ‚ej tabeli - indeks nie zostaÅ‚ uÅ¼yty).â€\n\nWskazÃ³wka: W maÅ‚ej tabeli (jak teachers) zysk z indeksu moÅ¼e byÄ‡ niezauwaÅ¼alny, a nawet moÅ¼e nie zostaÄ‡ uÅ¼yty przez optymalizator. Indeksy sÄ… najbardziej efektywne w tabelach liczÄ…cych tysiÄ…ce/miliony wierszy.\n\n\nTEST A\nDROP INDEX IF EXISTS idx_teachers_school;\nDROP INDEX IF EXISTS idx_teachers_last_name;\nusun indeksy na tabeli teachers - uwaga nazwy mogÄ… siÄ™ rÃ³Å¼niÄ‡.\nUruchom test wyszukiwania dla jednej z kolumn uÅ¼ywajÄ…c EXPLAIN ANALYZE:\nEXPLAIN ANALYZE\nSELECT *\nFROM teachers\nWHERE school = 'Lincoln High School';\nW wynikach EXPLAIN ANALYZE zobaczysz Seq Scan (skan sekwencyjny). Zanotuj czas Execution Time.\n\n\nTest B: Z Indeksem (Test Optymalizacji)\nZaÅ‚aduj 500 tyÅ› wierszy z generatora.\nUtwÃ³rz indeks na kolumnie, ktÃ³rÄ… testowaÅ‚eÅ› (school):\nCREATE INDEX idx_teachers_school ON teachers (school);\nPowtÃ³rz dokÅ‚adnie to samo zapytanie z EXPLAIN ANALYZE:\nEXPLAIN ANALYZE\nSELECT *\nFROM teachers\nWHERE school = 'Lincoln High School';\nW wynikach EXPLAIN ANALYZE powinieneÅ› zobaczyÄ‡ Index Scan lub Bitmap Heap Scan. Zanotuj nowy czas Execution Time. BÄ™dzie on znaczÄ…co krÃ³tszy niÅ¼ w TeÅ›cie A, co udowodni efektywnoÅ›Ä‡ indeksu.",
    "crumbs": [
      "KsiÄ…Å¼ki",
      "Laboratorium",
      "Serwer baz danych - PostgreSQL"
    ]
  },
  {
    "objectID": "cwiczenia/cw2.html#systemowe-rzeczy-w-postgresql",
    "href": "cwiczenia/cw2.html#systemowe-rzeczy-w-postgresql",
    "title": "Serwer baz danych - PostgreSQL",
    "section": "âš™ï¸ Systemowe Rzeczy w PostgreSQL",
    "text": "âš™ï¸ Systemowe Rzeczy w PostgreSQL\nPostgreSQL oferuje wiele widokÃ³w i funkcji systemowych do monitorowania i zarzÄ…dzania.\n\nPrzeglÄ…danie Metadanych (Katalog Systemowy)\nLista wszystkich tabel w bieÅ¼Ä…cym schemacie:\nSELECT table_name FROM information_schema.tables WHERE table_schema = 'public' ORDER BY table_name;\n\nSzczegÃ³Å‚y kolumn w tabeli teachers:\n\nSELECT column_name, data_type, is_nullable FROM information_schema.columns WHERE table_name = 'teachers' AND table_schema = 'public';\n\n\nMonitorowanie WydajnoÅ›ci\nAktualnie uruchomione zapytania (sesje) i ich stan:\nSELECT pid, usename, datname, query, state FROM pg_stat_activity WHERE datname = current_database();\nStatystyki uÅ¼ycia indeksÃ³w (czy indeksy sÄ… uÅ¼ywane):\nSELECT relname, indexrelname, idx_scan, idx_tup_read, idx_tup_fetch FROM pg_stat_user_indexes WHERE relname = 'teachers';\n\nidx_scan: Liczba skanowaÅ„ indeksu (im wyÅ¼sza, tym lepiej, bo znaczy, Å¼e indeks jest uÅ¼ywany).",
    "crumbs": [
      "KsiÄ…Å¼ki",
      "Laboratorium",
      "Serwer baz danych - PostgreSQL"
    ]
  },
  {
    "objectID": "cwiczenia/cw2.html#zadanie-1-podstawowe-filtrowanie-i-Å‚Ä…czenie",
    "href": "cwiczenia/cw2.html#zadanie-1-podstawowe-filtrowanie-i-Å‚Ä…czenie",
    "title": "Serwer baz danych - PostgreSQL",
    "section": "Zadanie 1: Podstawowe Filtrowanie i ÅÄ…czenie",
    "text": "Zadanie 1: Podstawowe Filtrowanie i ÅÄ…czenie\n\nCel: UÅ¼ycie klauzuli WHERE, ORDER BY i operatora ILIKE.\n\nZnajdÅº imiona, nazwiska i pensje wszystkich nauczycieli, ktÃ³rych nazwisko zaczyna siÄ™ na literÄ™ â€˜Sâ€™ (niezaleÅ¼nie od wielkoÅ›ci liter).\nPosortuj wyniki malejÄ…co wedÅ‚ug daty zatrudnienia.",
    "crumbs": [
      "KsiÄ…Å¼ki",
      "Laboratorium",
      "Serwer baz danych - PostgreSQL"
    ]
  },
  {
    "objectID": "cwiczenia/cw2.html#zadanie-2-zapytanie-zagnieÅ¼dÅ¼one-subquery",
    "href": "cwiczenia/cw2.html#zadanie-2-zapytanie-zagnieÅ¼dÅ¼one-subquery",
    "title": "Serwer baz danych - PostgreSQL",
    "section": "Zadanie 2: Zapytanie ZagnieÅ¼dÅ¼one (Subquery)",
    "text": "Zadanie 2: Zapytanie ZagnieÅ¼dÅ¼one (Subquery)\n\nCel: UÅ¼ycie podzapytania do wyznaczenia wartoÅ›ci porÃ³wnawczej.\n\nWyÅ›wietl imiona i nazwiska tych nauczycieli, ktÃ³rych pensja jest wyÅ¼sza niÅ¼ Å›rednia pensja wszystkich nauczycieli w bazie.",
    "crumbs": [
      "KsiÄ…Å¼ki",
      "Laboratorium",
      "Serwer baz danych - PostgreSQL"
    ]
  },
  {
    "objectID": "cwiczenia/cw2.html#zadanie-3-Å‚Ä…czenie-tabela-join-i-agregacja",
    "href": "cwiczenia/cw2.html#zadanie-3-Å‚Ä…czenie-tabela-join-i-agregacja",
    "title": "Serwer baz danych - PostgreSQL",
    "section": "Zadanie 3: ÅÄ…czenie Tabela (JOIN) i Agregacja",
    "text": "Zadanie 3: ÅÄ…czenie Tabela (JOIN) i Agregacja\n\nCel: ÅÄ…czenie wielu tabel (JOIN) i uÅ¼ycie funkcji agregujÄ…cej (COUNT).\n\nDla kaÅ¼dego przedmiotu (class_name) wyÅ›wietl:\n\nNazwÄ™ przedmiotu.\nNazwisko i imiÄ™ nauczyciela prowadzÄ…cego.\nLiczbÄ™ studentÃ³w zapisanych do tego przedmiotu (COUNT).\n\nPosortuj wyniki malejÄ…co wedÅ‚ug liczby studentÃ³w.",
    "crumbs": [
      "KsiÄ…Å¼ki",
      "Laboratorium",
      "Serwer baz danych - PostgreSQL"
    ]
  },
  {
    "objectID": "cwiczenia/cw2.html#zadanie-4-porÃ³wnanie-dat-i-wieloaspektowe-filtrowanie",
    "href": "cwiczenia/cw2.html#zadanie-4-porÃ³wnanie-dat-i-wieloaspektowe-filtrowanie",
    "title": "Serwer baz danych - PostgreSQL",
    "section": "Zadanie 4: PorÃ³wnanie Dat i Wieloaspektowe Filtrowanie",
    "text": "Zadanie 4: PorÃ³wnanie Dat i Wieloaspektowe Filtrowanie\n\nCel: UÅ¼ycie funkcji na datach (EXTRACT), operatora AND / OR i zakresu.\n\nZnajdÅº imiona i nazwiska wszystkich studentÃ³w, ktÃ³rzy:\n\nZostali zapisani w 2023 roku (EXTRACT(YEAR FROM enrollment_date)) LUB uczÄ™szczajÄ… na zajÄ™cia prowadzone przez nauczyciela z pensjÄ… w zakresie 30000 do 40000.",
    "crumbs": [
      "KsiÄ…Å¼ki",
      "Laboratorium",
      "Serwer baz danych - PostgreSQL"
    ]
  },
  {
    "objectID": "cwiczenia/cw2.html#zadanie-5-weryfikacja-indeksu-Ä‡wiczenie-w-pgadmin",
    "href": "cwiczenia/cw2.html#zadanie-5-weryfikacja-indeksu-Ä‡wiczenie-w-pgadmin",
    "title": "Serwer baz danych - PostgreSQL",
    "section": "Zadanie 5: Weryfikacja Indeksu (Ä†wiczenie w pgAdmin)",
    "text": "Zadanie 5: Weryfikacja Indeksu (Ä†wiczenie w pgAdmin)\n\nCel: Zrozumienie, jak PostgreSQL wykonuje zapytania i testowanie efektywnoÅ›ci indeksÃ³w.\n\n\nStwÃ³rz indeks na kolumnie last_name w tabeli teachers.\nUruchom poniÅ¼sze zapytanie, uÅ¼ywajÄ…c funkcji systemowej EXPLAIN ANALYZE w pgAdmin.\n\nW raporcie zwrÃ³Ä‡ uwagÄ™ na:\nPlanning Time i Execution Time.\nCzy pojawiÅ‚a siÄ™ fraza Index Scan lub Bitmap Heap Scan z odwoÅ‚aniem do idx_teachers_last_name? JeÅ›li tak, indeks zostaÅ‚ uÅ¼yty.\nGdybyÅ› usunÄ…Å‚ indeks (DROP INDEX idx_teachers_last_name;) i powtÃ³rzyÅ‚ zapytanie, w raporcie prawdopodobnie pojawiÅ‚oby siÄ™ Seq Scan (skan sekwencyjny). PorÃ³wnaj czasy wykonania.",
    "crumbs": [
      "KsiÄ…Å¼ki",
      "Laboratorium",
      "Serwer baz danych - PostgreSQL"
    ]
  },
  {
    "objectID": "lectures/wyklad2.html",
    "href": "lectures/wyklad2.html",
    "title": "Model relacyjny i podstawy SQL",
    "section": "",
    "text": "Dane przechowywane sÄ… w tabelach (ang. relations).\n\nKaÅ¼dy wiersz (row) to rekord / krotka.\n\nKaÅ¼da kolumna (column) to atrybut.\n\nDziedzina (domain) to zbiÃ³r dopuszczalnych wartoÅ›ci w danej kolumnie.\n\nPrzykÅ‚ad relacji STUDENT:\n\n\n\nid\nimie\nnazwisko\nrok_urodzenia\n\n\n\n\n1\nAdam\nMickiewicz\n1798\n\n\n2\nHenryk\nSienkiewicz\n1846\n\n\n\n\n Schemat relacji: tabela STUDENT z kolumnami i wierszami\n\n\n\n\n\n\n\n\n\nUnikalnie identyfikuje kaÅ¼dy wiersz w tabeli.\n\nNie moÅ¼e przyjmowaÄ‡ wartoÅ›ci NULL.\n\nW tabeli moÅ¼e wystÄ™powaÄ‡ tylko jeden klucz gÅ‚Ã³wny.\n\n\n\n\n\nTworzy powiÄ…zanie z innÄ… tabelÄ….\n\nWymusza spÃ³jnoÅ›Ä‡ danych â€“ nie moÅ¼na wprowadziÄ‡ wartoÅ›ci, ktÃ³rej nie ma w tabeli nadrzÄ™dnej.\n\n\n\n\n\nUNIQUE â€“ zapewnia unikalnoÅ›Ä‡ wartoÅ›ci w kolumnie.\n\nNOT NULL â€“ kolumna nie moÅ¼e przyjmowaÄ‡ wartoÅ›ci pustych.\n\nCHECK â€“ sprawdza warunek logiczny (np. wiek &gt; 0).\n\n\n\n\n\n\n\n\n\nRodzaj klucza\nOpis\nPrzykÅ‚ad\n\n\n\n\nKlucz gÅ‚Ã³wny (Primary Key)\njednoznacznie identyfikuje rekord\nNrIndeksu w STUDENT\n\n\nKlucz obcy (Foreign Key)\ntworzy powiÄ…zanie miÄ™dzy tabelami\nKursID w tabeli ZAPIS\n\n\nKlucz kandydujÄ…cy (Candidate Key)\natrybut, ktÃ³ry moÅ¼e byÄ‡ kluczem gÅ‚Ã³wnym\nPESEL, NrIndeksu\n\n\nKlucz zÅ‚oÅ¼ony (Composite Key)\nskÅ‚ada siÄ™ z kilku kolumn\n(StudentID, KursID)\n\n\n\n\n Schemat: klucz gÅ‚Ã³wny i klucz obcy miÄ™dzy tabelami STUDENT, KURS, ZAPIS\n\n\n\n\n\n\nW relacyjnych bazach danych tabele Å‚Ä…czy siÄ™ przez klucze obce.\nNa tej podstawie tworzÄ… siÄ™ rÃ³Å¼ne typy relacji:\n\n\n\n\n\n\n\n\nTyp relacji\nOpis\nPrzykÅ‚ad\n\n\n\n\n1:1 (jeden do jednego)\njeden rekord w tabeli A odpowiada dokÅ‚adnie jednemu rekordowi w tabeli B\nStudent â†”ï¸ï¸ Legitymacja\n\n\n1:N (jeden do wielu)\njeden rekord w tabeli A moÅ¼e byÄ‡ powiÄ…zany z wieloma rekordami w tabeli B\nWykÅ‚adowca â†”ï¸ï¸ Kursy\n\n\nN:M (wielu do wielu)\nwiele rekordÃ³w w A moÅ¼e byÄ‡ powiÄ…zanych z wieloma w B\nStudenci â†”ï¸ï¸ Kursy\n\n\n\nRelacjÄ™ N:M realizuje siÄ™ przez tabelÄ™ poÅ›redniczÄ…cÄ…, np.:\nSTUDENT (NrIndeksu, Imie, Nazwisko)\nKURS (KursID, Nazwa)\nZAPIS (NrIndeksu, KursID, DataZapisu)\nTabela ZAPIS zawiera klucze obce wskazujÄ…ce na STUDENT i KURS.\n\n## 4ï¸âƒ£ Wprowadzenie do jÄ™zyka SQL (Structured Query Language)\nSQL to standardowy jÄ™zyk do definiowania, modyfikowania i pobierania danych w relacyjnych bazach danych.\n\n\n\n\n\n\n\n\nPodjÄ™zyk\nOpis\nPrzykÅ‚ady poleceÅ„\n\n\n\n\nDDL (Data Definition Language)\ndefiniuje strukturÄ™ bazy\nCREATE TABLE, ALTER TABLE, DROP TABLE\n\n\nDML (Data Manipulation Language)\noperacje na danych\nINSERT, UPDATE, DELETE, SELECT\n\n\nDCL (Data Control Language)\nkontrola dostÄ™pu\nGRANT, REVOKE\n\n\nTCL (Transaction Control Language)\nkontrola transakcji\nCOMMIT, ROLLBACK\n\n\n\n\n\n\nPolecenie CREATE TABLE sÅ‚uÅ¼y do utworzenia nowej tabeli w bazie danych.\nW tym poleceniu definiujemy nazwy kolumn, ich typy danych oraz rÃ³Å¼ne wiÄ™zy integralnoÅ›ci, takie jak PRIMARY KEY, NOT NULL czy FOREIGN KEY.\nKaÅ¼da tabela powinna mieÄ‡ kolumnÄ™, ktÃ³ra jednoznacznie identyfikuje kaÅ¼dy wiersz â€“ to wÅ‚aÅ›nie klucz gÅ‚Ã³wny.\nW przykÅ‚adzie poniÅ¼ej tworzymy dwie tabele: Autorzy i Ksiazki, ktÃ³re bÄ™dÄ… ze sobÄ… powiÄ…zane relacjÄ… klucz gÅ‚Ã³wnyâ€“klucz obcy.\n\n\n\n\nCREATE TABLE Autorzy (\n    autor_id     INTEGER PRIMARY KEY,         -- w SQLite automatycznie AUTOINCREMENT\n    imie         TEXT NOT NULL,\n    nazwisko     TEXT NOT NULL\n);\n\nCREATE TABLE Ksiazki (\n    ksiazka_id   SERIAL PRIMARY KEY,          -- PostgreSQL: automatyczna numeracja\n    tytul        VARCHAR(200) NOT NULL,\n    rok          INTEGER CHECK (rok &gt; 0),\n    autor_id     INTEGER,\n    FOREIGN KEY (autor_id) REFERENCES Autorzy(autor_id)\n);\n\nW SQLite INTEGER PRIMARY KEY = alias dla AUTOINCREMENT.\nW PostgreSQL uÅ¼ywamy SERIAL lub GENERATED ALWAYS AS IDENTITY.\n\nW powyÅ¼szym przykÅ‚adzie:\n\ntabela Autorzy przechowuje dane o autorach,\ntabela Ksiazki przechowuje dane o ksiÄ…Å¼kach,\nkolumna autor_id w Ksiazki to klucz obcy, ktÃ³ry wskazuje autora.\n\nDziÄ™ki wiÄ™zom integralnoÅ›ci baza pilnuje, by kaÅ¼da ksiÄ…Å¼ka miaÅ‚a poprawnego autora. Takie powiÄ…zania sÄ… podstawÄ… modelu relacyjnego.\n\n\n\n\n\n\nALTER TABLE Ksiazki ADD COLUMN gatunek TEXT;\n\n\n\nALTER TABLE STUDENT ALTER COLUMN Kierunek TYPE VARCHAR(100);\n\n\n\nALTER TABLE STUDENT DROP COLUMN Email;\n\n\n\nDROP TABLE Ksiazki;\n\n\n\n\nPolecenie INSERT INTO sÅ‚uÅ¼y do wprowadzania nowych wierszy (rekordÃ³w) do tabeli. WartoÅ›ci muszÄ… byÄ‡ zgodne z typami kolumn oraz ograniczeniami (NOT NULL, CHECK, itp.).\nMoÅ¼na dodaÄ‡ jeden lub wiele rekordÃ³w w jednym poleceniu.\nINSERT INTO Autorzy (imie, nazwisko) VALUES\n('Adam', 'Mickiewicz'),\n('Henryk', 'Sienkiewicz'),\n('BolesÅ‚aw', 'Prus');\n\nINSERT INTO Ksiazki (tytul, rok, autor_id) VALUES\n('Pan Tadeusz', 1834, 1),\n('Quo Vadis', 1896, 2),\n('Lalka', 1890, 3);\nKaÅ¼dy rekord reprezentuje jednÄ… pozycjÄ™ w tabeli. Polecenie INSERT wymaga podania wartoÅ›ci w tej samej kolejnoÅ›ci, w jakiej wymieniono kolumny. JeÅ›li nie podamy jakiejÅ› kolumny, a ma ona zdefiniowanÄ… wartoÅ›Ä‡ domyÅ›lnÄ… (DEFAULT), baza wstawi jÄ… automatycznie.\n\n\n\n\n\nSELECT * FROM Autorzy;\nPowyÅ¼sze zapytanie zwraca wszystkich autorÃ³w z tabeli Autorzy.\n\n\n\n\nSELECT imie, nazwisko FROM Autorzy;\n\n\n\nSELECT imie AS \"ImiÄ™\", nazwisko AS \"Nazwisko\" FROM Autorzy;\nAlias (AS) pozwala nadaÄ‡ kolumnom bardziej opisowe nazwy w wynikach.\n\n\n\n\nSELECT * FROM Ksiazki\nWHERE rok &gt; 1850;\n\n\n\n= , &lt;&gt;, &lt;, &gt;, &lt;=, &gt;=\nLIKE â€˜Q%â€™ â†’ zaczyna siÄ™ na Q\nIN (â€¦)\nBETWEEN 1800 AND 1900\nIS NULL, IS NOT NULL\n\nPrzykÅ‚ad wyszukiwania ksiÄ…Å¼ek zawierajÄ…cych literÄ™ â€œaâ€ w tytule:\nSELECT tytul FROM Ksiazki WHERE tytul LIKE '%a%';\n\n\n\n\nSELECT * FROM Ksiazki ORDER BY rok DESC;\nSortowanie wynikÃ³w moÅ¼na wykonaÄ‡ wedÅ‚ug dowolnej kolumny. DomyÅ›lnie ORDER BY sortuje rosnÄ…co (ASC). Dla kilku kolumn moÅ¼na napisaÄ‡ np.:\nSELECT * FROM Ksiazki ORDER BY autor_id ASC, rok DESC;\n\n\n\nSELECT autor_id, COUNT(*) AS liczba_ksiazek\nFROM Ksiazki\nGROUP BY autor_id\nHAVING COUNT(*) &gt; 1;\nKlauzula GROUP BY grupuje dane, a HAVING filtruje grupy po agregacji. Funkcje agregujÄ…ce: COUNT(), SUM(), AVG(), MIN(), MAX().\n\n\n\n\n\nSELECT k.tytul, a.imie, a.nazwisko\nFROM Ksiazki k\nJOIN Autorzy a ON k.autor_id = a.autor_id;\n\n\n\nSELECT k.tytul, a.imie, a.nazwisko\nFROM Ksiazki k\nLEFT JOIN Autorzy a ON k.autor_id = a.autor_id;\nINNER JOIN zwraca tylko dopasowane rekordy, LEFT JOIN â€“ wszystkie rekordy z lewej tabeli (nawet bez dopasowania).\n\n\n\n\n\n\nUPDATE Ksiazki SET rok = 1836 WHERE tytul = 'Pan Tadeusz';\n\n\n\nDELETE FROM Ksiazki WHERE rok &lt; 1850;\nZawsze naleÅ¼y uÅ¼ywaÄ‡ WHERE, aby nie zmodyfikowaÄ‡ lub nie usunÄ…Ä‡ wszystkich rekordÃ³w.\n\n\n\n\nSQL jest jÄ™zykiem deklaratywnym â€“ opisujemy co chcemy uzyskaÄ‡, a nie jak to zrobiÄ‡. DziÄ™ki temu uÅ¼ytkownik nie musi znaÄ‡ szczegÃ³Å‚Ã³w dziaÅ‚ania bazy danych.\nPoznane dziÅ› polecenia:\nCREATE, INSERT, SELECT, UPDATE, DELETE, JOIN, GROUP BY\nto fundament pracy z bazami danych. Opanowanie ich pozwala budowaÄ‡ i analizowaÄ‡ nawet bardzo zÅ‚oÅ¼one systemy informacyjne.\nâ¸»\n\n\n\nâ€¢   Dokumentacja SQLite\nâ€¢   Dokumentacja PostgreSQL\nâ€¢   A. Silberschatz, H. Korth, S. Sudarshan, Database System Concepts",
    "crumbs": [
      "KsiÄ…Å¼ki",
      "WykÅ‚ady",
      "Model relacyjny i podstawy SQL"
    ]
  },
  {
    "objectID": "lectures/wyklad2.html#model-relacyjny-przypomnienie-i-pojÄ™cia-podstawowe",
    "href": "lectures/wyklad2.html#model-relacyjny-przypomnienie-i-pojÄ™cia-podstawowe",
    "title": "Model relacyjny i podstawy SQL",
    "section": "",
    "text": "Dane przechowywane sÄ… w tabelach (ang. relations).\n\nKaÅ¼dy wiersz (row) to rekord / krotka.\n\nKaÅ¼da kolumna (column) to atrybut.\n\nDziedzina (domain) to zbiÃ³r dopuszczalnych wartoÅ›ci w danej kolumnie.\n\nPrzykÅ‚ad relacji STUDENT:\n\n\n\nid\nimie\nnazwisko\nrok_urodzenia\n\n\n\n\n1\nAdam\nMickiewicz\n1798\n\n\n2\nHenryk\nSienkiewicz\n1846\n\n\n\n\n Schemat relacji: tabela STUDENT z kolumnami i wierszami",
    "crumbs": [
      "KsiÄ…Å¼ki",
      "WykÅ‚ady",
      "Model relacyjny i podstawy SQL"
    ]
  },
  {
    "objectID": "lectures/wyklad2.html#klucze-i-wiÄ™zy-integralnoÅ›ci",
    "href": "lectures/wyklad2.html#klucze-i-wiÄ™zy-integralnoÅ›ci",
    "title": "Model relacyjny i podstawy SQL",
    "section": "",
    "text": "Unikalnie identyfikuje kaÅ¼dy wiersz w tabeli.\n\nNie moÅ¼e przyjmowaÄ‡ wartoÅ›ci NULL.\n\nW tabeli moÅ¼e wystÄ™powaÄ‡ tylko jeden klucz gÅ‚Ã³wny.\n\n\n\n\n\nTworzy powiÄ…zanie z innÄ… tabelÄ….\n\nWymusza spÃ³jnoÅ›Ä‡ danych â€“ nie moÅ¼na wprowadziÄ‡ wartoÅ›ci, ktÃ³rej nie ma w tabeli nadrzÄ™dnej.\n\n\n\n\n\nUNIQUE â€“ zapewnia unikalnoÅ›Ä‡ wartoÅ›ci w kolumnie.\n\nNOT NULL â€“ kolumna nie moÅ¼e przyjmowaÄ‡ wartoÅ›ci pustych.\n\nCHECK â€“ sprawdza warunek logiczny (np. wiek &gt; 0).\n\n\n\n\n\n\n\n\n\nRodzaj klucza\nOpis\nPrzykÅ‚ad\n\n\n\n\nKlucz gÅ‚Ã³wny (Primary Key)\njednoznacznie identyfikuje rekord\nNrIndeksu w STUDENT\n\n\nKlucz obcy (Foreign Key)\ntworzy powiÄ…zanie miÄ™dzy tabelami\nKursID w tabeli ZAPIS\n\n\nKlucz kandydujÄ…cy (Candidate Key)\natrybut, ktÃ³ry moÅ¼e byÄ‡ kluczem gÅ‚Ã³wnym\nPESEL, NrIndeksu\n\n\nKlucz zÅ‚oÅ¼ony (Composite Key)\nskÅ‚ada siÄ™ z kilku kolumn\n(StudentID, KursID)\n\n\n\n\n Schemat: klucz gÅ‚Ã³wny i klucz obcy miÄ™dzy tabelami STUDENT, KURS, ZAPIS",
    "crumbs": [
      "KsiÄ…Å¼ki",
      "WykÅ‚ady",
      "Model relacyjny i podstawy SQL"
    ]
  },
  {
    "objectID": "lectures/wyklad2.html#rodzaje-zwiÄ…zkÃ³w-relacji-miÄ™dzy-tabelami",
    "href": "lectures/wyklad2.html#rodzaje-zwiÄ…zkÃ³w-relacji-miÄ™dzy-tabelami",
    "title": "Model relacyjny i podstawy SQL",
    "section": "",
    "text": "W relacyjnych bazach danych tabele Å‚Ä…czy siÄ™ przez klucze obce.\nNa tej podstawie tworzÄ… siÄ™ rÃ³Å¼ne typy relacji:\n\n\n\n\n\n\n\n\nTyp relacji\nOpis\nPrzykÅ‚ad\n\n\n\n\n1:1 (jeden do jednego)\njeden rekord w tabeli A odpowiada dokÅ‚adnie jednemu rekordowi w tabeli B\nStudent â†”ï¸ï¸ Legitymacja\n\n\n1:N (jeden do wielu)\njeden rekord w tabeli A moÅ¼e byÄ‡ powiÄ…zany z wieloma rekordami w tabeli B\nWykÅ‚adowca â†”ï¸ï¸ Kursy\n\n\nN:M (wielu do wielu)\nwiele rekordÃ³w w A moÅ¼e byÄ‡ powiÄ…zanych z wieloma w B\nStudenci â†”ï¸ï¸ Kursy\n\n\n\nRelacjÄ™ N:M realizuje siÄ™ przez tabelÄ™ poÅ›redniczÄ…cÄ…, np.:\nSTUDENT (NrIndeksu, Imie, Nazwisko)\nKURS (KursID, Nazwa)\nZAPIS (NrIndeksu, KursID, DataZapisu)\nTabela ZAPIS zawiera klucze obce wskazujÄ…ce na STUDENT i KURS.\n\n## 4ï¸âƒ£ Wprowadzenie do jÄ™zyka SQL (Structured Query Language)\nSQL to standardowy jÄ™zyk do definiowania, modyfikowania i pobierania danych w relacyjnych bazach danych.\n\n\n\n\n\n\n\n\nPodjÄ™zyk\nOpis\nPrzykÅ‚ady poleceÅ„\n\n\n\n\nDDL (Data Definition Language)\ndefiniuje strukturÄ™ bazy\nCREATE TABLE, ALTER TABLE, DROP TABLE\n\n\nDML (Data Manipulation Language)\noperacje na danych\nINSERT, UPDATE, DELETE, SELECT\n\n\nDCL (Data Control Language)\nkontrola dostÄ™pu\nGRANT, REVOKE\n\n\nTCL (Transaction Control Language)\nkontrola transakcji\nCOMMIT, ROLLBACK\n\n\n\n\n\n\nPolecenie CREATE TABLE sÅ‚uÅ¼y do utworzenia nowej tabeli w bazie danych.\nW tym poleceniu definiujemy nazwy kolumn, ich typy danych oraz rÃ³Å¼ne wiÄ™zy integralnoÅ›ci, takie jak PRIMARY KEY, NOT NULL czy FOREIGN KEY.\nKaÅ¼da tabela powinna mieÄ‡ kolumnÄ™, ktÃ³ra jednoznacznie identyfikuje kaÅ¼dy wiersz â€“ to wÅ‚aÅ›nie klucz gÅ‚Ã³wny.\nW przykÅ‚adzie poniÅ¼ej tworzymy dwie tabele: Autorzy i Ksiazki, ktÃ³re bÄ™dÄ… ze sobÄ… powiÄ…zane relacjÄ… klucz gÅ‚Ã³wnyâ€“klucz obcy.\n\n\n\n\nCREATE TABLE Autorzy (\n    autor_id     INTEGER PRIMARY KEY,         -- w SQLite automatycznie AUTOINCREMENT\n    imie         TEXT NOT NULL,\n    nazwisko     TEXT NOT NULL\n);\n\nCREATE TABLE Ksiazki (\n    ksiazka_id   SERIAL PRIMARY KEY,          -- PostgreSQL: automatyczna numeracja\n    tytul        VARCHAR(200) NOT NULL,\n    rok          INTEGER CHECK (rok &gt; 0),\n    autor_id     INTEGER,\n    FOREIGN KEY (autor_id) REFERENCES Autorzy(autor_id)\n);\n\nW SQLite INTEGER PRIMARY KEY = alias dla AUTOINCREMENT.\nW PostgreSQL uÅ¼ywamy SERIAL lub GENERATED ALWAYS AS IDENTITY.\n\nW powyÅ¼szym przykÅ‚adzie:\n\ntabela Autorzy przechowuje dane o autorach,\ntabela Ksiazki przechowuje dane o ksiÄ…Å¼kach,\nkolumna autor_id w Ksiazki to klucz obcy, ktÃ³ry wskazuje autora.\n\nDziÄ™ki wiÄ™zom integralnoÅ›ci baza pilnuje, by kaÅ¼da ksiÄ…Å¼ka miaÅ‚a poprawnego autora. Takie powiÄ…zania sÄ… podstawÄ… modelu relacyjnego.",
    "crumbs": [
      "KsiÄ…Å¼ki",
      "WykÅ‚ady",
      "Model relacyjny i podstawy SQL"
    ]
  },
  {
    "objectID": "lectures/wyklad2.html#modyfikacja-i-usuwanie-tabel",
    "href": "lectures/wyklad2.html#modyfikacja-i-usuwanie-tabel",
    "title": "Model relacyjny i podstawy SQL",
    "section": "",
    "text": "ALTER TABLE Ksiazki ADD COLUMN gatunek TEXT;\n\n\n\nALTER TABLE STUDENT ALTER COLUMN Kierunek TYPE VARCHAR(100);\n\n\n\nALTER TABLE STUDENT DROP COLUMN Email;\n\n\n\nDROP TABLE Ksiazki;",
    "crumbs": [
      "KsiÄ…Å¼ki",
      "WykÅ‚ady",
      "Model relacyjny i podstawy SQL"
    ]
  },
  {
    "objectID": "lectures/wyklad2.html#wstawianie-danych-dml-data-manipulation-language",
    "href": "lectures/wyklad2.html#wstawianie-danych-dml-data-manipulation-language",
    "title": "Model relacyjny i podstawy SQL",
    "section": "",
    "text": "Polecenie INSERT INTO sÅ‚uÅ¼y do wprowadzania nowych wierszy (rekordÃ³w) do tabeli. WartoÅ›ci muszÄ… byÄ‡ zgodne z typami kolumn oraz ograniczeniami (NOT NULL, CHECK, itp.).\nMoÅ¼na dodaÄ‡ jeden lub wiele rekordÃ³w w jednym poleceniu.\nINSERT INTO Autorzy (imie, nazwisko) VALUES\n('Adam', 'Mickiewicz'),\n('Henryk', 'Sienkiewicz'),\n('BolesÅ‚aw', 'Prus');\n\nINSERT INTO Ksiazki (tytul, rok, autor_id) VALUES\n('Pan Tadeusz', 1834, 1),\n('Quo Vadis', 1896, 2),\n('Lalka', 1890, 3);\nKaÅ¼dy rekord reprezentuje jednÄ… pozycjÄ™ w tabeli. Polecenie INSERT wymaga podania wartoÅ›ci w tej samej kolejnoÅ›ci, w jakiej wymieniono kolumny. JeÅ›li nie podamy jakiejÅ› kolumny, a ma ona zdefiniowanÄ… wartoÅ›Ä‡ domyÅ›lnÄ… (DEFAULT), baza wstawi jÄ… automatycznie.",
    "crumbs": [
      "KsiÄ…Å¼ki",
      "WykÅ‚ady",
      "Model relacyjny i podstawy SQL"
    ]
  },
  {
    "objectID": "lectures/wyklad2.html#wybieranie-danych-select",
    "href": "lectures/wyklad2.html#wybieranie-danych-select",
    "title": "Model relacyjny i podstawy SQL",
    "section": "",
    "text": "SELECT * FROM Autorzy;\nPowyÅ¼sze zapytanie zwraca wszystkich autorÃ³w z tabeli Autorzy.\n\n\n\n\nSELECT imie, nazwisko FROM Autorzy;\n\n\n\nSELECT imie AS \"ImiÄ™\", nazwisko AS \"Nazwisko\" FROM Autorzy;\nAlias (AS) pozwala nadaÄ‡ kolumnom bardziej opisowe nazwy w wynikach.",
    "crumbs": [
      "KsiÄ…Å¼ki",
      "WykÅ‚ady",
      "Model relacyjny i podstawy SQL"
    ]
  },
  {
    "objectID": "lectures/wyklad2.html#filtrowanie-where",
    "href": "lectures/wyklad2.html#filtrowanie-where",
    "title": "Model relacyjny i podstawy SQL",
    "section": "",
    "text": "SELECT * FROM Ksiazki\nWHERE rok &gt; 1850;\n\n\n\n= , &lt;&gt;, &lt;, &gt;, &lt;=, &gt;=\nLIKE â€˜Q%â€™ â†’ zaczyna siÄ™ na Q\nIN (â€¦)\nBETWEEN 1800 AND 1900\nIS NULL, IS NOT NULL\n\nPrzykÅ‚ad wyszukiwania ksiÄ…Å¼ek zawierajÄ…cych literÄ™ â€œaâ€ w tytule:\nSELECT tytul FROM Ksiazki WHERE tytul LIKE '%a%';",
    "crumbs": [
      "KsiÄ…Å¼ki",
      "WykÅ‚ady",
      "Model relacyjny i podstawy SQL"
    ]
  },
  {
    "objectID": "lectures/wyklad2.html#sortowanie-order-by",
    "href": "lectures/wyklad2.html#sortowanie-order-by",
    "title": "Model relacyjny i podstawy SQL",
    "section": "",
    "text": "SELECT * FROM Ksiazki ORDER BY rok DESC;\nSortowanie wynikÃ³w moÅ¼na wykonaÄ‡ wedÅ‚ug dowolnej kolumny. DomyÅ›lnie ORDER BY sortuje rosnÄ…co (ASC). Dla kilku kolumn moÅ¼na napisaÄ‡ np.:\nSELECT * FROM Ksiazki ORDER BY autor_id ASC, rok DESC;",
    "crumbs": [
      "KsiÄ…Å¼ki",
      "WykÅ‚ady",
      "Model relacyjny i podstawy SQL"
    ]
  },
  {
    "objectID": "lectures/wyklad2.html#grupowanie-i-agregacja-group-by-having",
    "href": "lectures/wyklad2.html#grupowanie-i-agregacja-group-by-having",
    "title": "Model relacyjny i podstawy SQL",
    "section": "",
    "text": "SELECT autor_id, COUNT(*) AS liczba_ksiazek\nFROM Ksiazki\nGROUP BY autor_id\nHAVING COUNT(*) &gt; 1;\nKlauzula GROUP BY grupuje dane, a HAVING filtruje grupy po agregacji. Funkcje agregujÄ…ce: COUNT(), SUM(), AVG(), MIN(), MAX().",
    "crumbs": [
      "KsiÄ…Å¼ki",
      "WykÅ‚ady",
      "Model relacyjny i podstawy SQL"
    ]
  },
  {
    "objectID": "lectures/wyklad2.html#Å‚Ä…czenie-tabel-join",
    "href": "lectures/wyklad2.html#Å‚Ä…czenie-tabel-join",
    "title": "Model relacyjny i podstawy SQL",
    "section": "",
    "text": "SELECT k.tytul, a.imie, a.nazwisko\nFROM Ksiazki k\nJOIN Autorzy a ON k.autor_id = a.autor_id;\n\n\n\nSELECT k.tytul, a.imie, a.nazwisko\nFROM Ksiazki k\nLEFT JOIN Autorzy a ON k.autor_id = a.autor_id;\nINNER JOIN zwraca tylko dopasowane rekordy, LEFT JOIN â€“ wszystkie rekordy z lewej tabeli (nawet bez dopasowania).",
    "crumbs": [
      "KsiÄ…Å¼ki",
      "WykÅ‚ady",
      "Model relacyjny i podstawy SQL"
    ]
  },
  {
    "objectID": "lectures/wyklad2.html#aktualizacja-i-usuwanie-danych",
    "href": "lectures/wyklad2.html#aktualizacja-i-usuwanie-danych",
    "title": "Model relacyjny i podstawy SQL",
    "section": "",
    "text": "UPDATE Ksiazki SET rok = 1836 WHERE tytul = 'Pan Tadeusz';\n\n\n\nDELETE FROM Ksiazki WHERE rok &lt; 1850;\nZawsze naleÅ¼y uÅ¼ywaÄ‡ WHERE, aby nie zmodyfikowaÄ‡ lub nie usunÄ…Ä‡ wszystkich rekordÃ³w.",
    "crumbs": [
      "KsiÄ…Å¼ki",
      "WykÅ‚ady",
      "Model relacyjny i podstawy SQL"
    ]
  },
  {
    "objectID": "lectures/wyklad2.html#podsumowanie",
    "href": "lectures/wyklad2.html#podsumowanie",
    "title": "Model relacyjny i podstawy SQL",
    "section": "",
    "text": "SQL jest jÄ™zykiem deklaratywnym â€“ opisujemy co chcemy uzyskaÄ‡, a nie jak to zrobiÄ‡. DziÄ™ki temu uÅ¼ytkownik nie musi znaÄ‡ szczegÃ³Å‚Ã³w dziaÅ‚ania bazy danych.\nPoznane dziÅ› polecenia:\nCREATE, INSERT, SELECT, UPDATE, DELETE, JOIN, GROUP BY\nto fundament pracy z bazami danych. Opanowanie ich pozwala budowaÄ‡ i analizowaÄ‡ nawet bardzo zÅ‚oÅ¼one systemy informacyjne.\nâ¸»",
    "crumbs": [
      "KsiÄ…Å¼ki",
      "WykÅ‚ady",
      "Model relacyjny i podstawy SQL"
    ]
  },
  {
    "objectID": "lectures/wyklad2.html#ÅºrÃ³dÅ‚a-i-literatura",
    "href": "lectures/wyklad2.html#ÅºrÃ³dÅ‚a-i-literatura",
    "title": "Model relacyjny i podstawy SQL",
    "section": "",
    "text": "â€¢   Dokumentacja SQLite\nâ€¢   Dokumentacja PostgreSQL\nâ€¢   A. Silberschatz, H. Korth, S. Sudarshan, Database System Concepts",
    "crumbs": [
      "KsiÄ…Å¼ki",
      "WykÅ‚ady",
      "Model relacyjny i podstawy SQL"
    ]
  },
  {
    "objectID": "lectures/wyklad1.html",
    "href": "lectures/wyklad1.html",
    "title": "Od pliku do bazy danych",
    "section": "",
    "text": "W tym module poznasz podstawowe pojÄ™cia zwiÄ…zane z danymi i bazami danych. Dowiesz siÄ™, czym rÃ³Å¼ni siÄ™ system plikowy od bazy danych, jak wyglÄ…da architektura systemu DBMS oraz dlaczego model relacyjny staÅ‚ siÄ™ standardem w przechowywaniu informacji.\nNa koÅ„cu wprowadzimy CiÄ™ w Å›wiat jÄ™zyka SQL â€“ narzÄ™dzia, ktÃ³re pozwala komunikowaÄ‡ siÄ™ z bazÄ… danych.\nâ¸»",
    "crumbs": [
      "KsiÄ…Å¼ki",
      "WykÅ‚ady",
      "Od pliku do bazy danych"
    ]
  },
  {
    "objectID": "lectures/wyklad1.html#cele-wykÅ‚adu",
    "href": "lectures/wyklad1.html#cele-wykÅ‚adu",
    "title": "Od pliku do bazy danych",
    "section": "",
    "text": "W tym module poznasz podstawowe pojÄ™cia zwiÄ…zane z danymi i bazami danych. Dowiesz siÄ™, czym rÃ³Å¼ni siÄ™ system plikowy od bazy danych, jak wyglÄ…da architektura systemu DBMS oraz dlaczego model relacyjny staÅ‚ siÄ™ standardem w przechowywaniu informacji.\nNa koÅ„cu wprowadzimy CiÄ™ w Å›wiat jÄ™zyka SQL â€“ narzÄ™dzia, ktÃ³re pozwala komunikowaÄ‡ siÄ™ z bazÄ… danych.\nâ¸»",
    "crumbs": [
      "KsiÄ…Å¼ki",
      "WykÅ‚ady",
      "Od pliku do bazy danych"
    ]
  },
  {
    "objectID": "lectures/wyklad1.html#dane-informacja-baza-danych",
    "href": "lectures/wyklad1.html#dane-informacja-baza-danych",
    "title": "Od pliku do bazy danych",
    "section": "1ï¸âƒ£ Dane, informacja, baza danych",
    "text": "1ï¸âƒ£ Dane, informacja, baza danych\n\nğŸ”¹ Dane\nNa poczÄ…tku warto zadaÄ‡ pytanie: czym wÅ‚aÅ›ciwie sÄ… dane?\nDane to surowe fakty â€“ liczby, teksty, symbole â€“ ktÃ³re same w sobie nie majÄ… znaczenia. PrzykÅ‚adowo, zapis:\n12345\nJan Kowalski\nBazy danych\nnie mÃ³wi nam jeszcze nic o tym, co oznacza. MoÅ¼e to byÄ‡ numer indeksu, nazwisko klienta albo temat zajÄ™Ä‡.\n\n (np. piramida DIKW â€“ Data, Information, Knowledge, Wisdom)\n\n\n\nğŸ”¹ Informacja\nInformacja powstaje wtedy, gdy dane zostanÄ… zinterpretowane w okreÅ›lonym kontekÅ›cie. JeÅ›li wiemy, Å¼e â€12345â€ to numer indeksu studenta Jana Kowalskiego, ktÃ³ry zapisaÅ‚ siÄ™ na kurs Bazy danych, mamy juÅ¼ informacjÄ™.\nW Å¼yciu codziennym czÄ™sto mamy mnÃ³stwo danych (np. z mediÃ³w spoÅ‚ecznoÅ›ciowych), ale niewiele z nich przekÅ‚ada siÄ™ na prawdziwÄ… wiedzÄ™.\nâ¸»\n\n\nğŸ”¹ Baza danych\nBaza danych (ang. database) to uporzÄ…dkowany zbiÃ³r danych, przechowywany w sposÃ³b umoÅ¼liwiajÄ…cy szybkie wyszukiwanie, aktualizacjÄ™ i kontrolÄ™ spÃ³jnoÅ›ci. MoÅ¼na jÄ… porÃ³wnaÄ‡ do dobrze zorganizowanego archiwum, w ktÃ³rym kaÅ¼dy dokument ma swoje miejsce i jest Å‚atwy do odnalezienia.\nWizualizacja bazy danych â€“ zestaw powiÄ…zanych tabel w relacyjnym modelu danych.\n\n\nğŸ”¹ System zarzÄ…dzania bazÄ… danych (DBMS)\nSystem zarzÄ…dzania bazÄ… danych, czyli DBMS (Database Management System), to oprogramowanie poÅ›redniczÄ…ce miÄ™dzy uÅ¼ytkownikiem a bazÄ… danych.\nTo ono umoÅ¼liwia:\n\ndefiniowanie struktur (np. tabel),\nprzechowywanie i wyszukiwanie danych,\nzapewnienie bezpieczeÅ„stwa i spÃ³jnoÅ›ci,\nobsÅ‚ugÄ™ wielu uÅ¼ytkownikÃ³w jednoczeÅ›nie.\n\nDo najpopularniejszych DBMS naleÅ¼Ä…: PostgreSQL, Oracle, MySQL, SQLite, MS SQL Server.",
    "crumbs": [
      "KsiÄ…Å¼ki",
      "WykÅ‚ady",
      "Od pliku do bazy danych"
    ]
  },
  {
    "objectID": "lectures/wyklad1.html#rodzaje-danych",
    "href": "lectures/wyklad1.html#rodzaje-danych",
    "title": "Od pliku do bazy danych",
    "section": "2ï¸âƒ£ Rodzaje danych",
    "text": "2ï¸âƒ£ Rodzaje danych\nW informatyce dane wystÄ™pujÄ… w rÃ³Å¼nych formach. MoÅ¼na je podzieliÄ‡ wedÅ‚ug stopnia strukturyzacji.\n\nğŸ”¸ Dane ustrukturyzowane\nTo dane zapisane w tabelach â€“ kaÅ¼da kolumna ma nazwÄ™ i okreÅ›lony typ. Znajdujemy je np. w arkuszach kalkulacyjnych lub relacyjnych bazach danych.\n\n\n\nID\nImiÄ™\nNazwisko\nMiasto\n\n\n\n\n1\nAnna\nNowak\nKrakÃ³w\n\n\n2\nJan\nKowalski\nWarszawa\n\n\n\n\n\n\nğŸ”¸ Dane pÃ³Å‚ustrukturyzowane\nMajÄ… pewnÄ… strukturÄ™, ale nie tak sztywnÄ… jak dane tabelaryczne.\nPrzykÅ‚adem mogÄ… byÄ‡ pliki JSON lub XML:\n{\n  \"imie\": \"Anna\",\n  \"miasto\": \"KrakÃ³w\",\n  \"zainteresowania\": [\"sport\", \"muzyka\"]\n}\n\n\n\nğŸ”¸ Dane nieustrukturyzowane\nTo dane, ktÃ³re nie majÄ… jasno zdefiniowanej struktury â€” na przykÅ‚ad obrazy, pliki audio, wideo czy dokumenty PDF. Ich analiza wymaga specjalistycznych narzÄ™dzi (np. rozpoznawania obrazÃ³w lub przetwarzania jÄ™zyka naturalnego).\nâ¸»",
    "crumbs": [
      "KsiÄ…Å¼ki",
      "WykÅ‚ady",
      "Od pliku do bazy danych"
    ]
  },
  {
    "objectID": "lectures/wyklad1.html#pliki-jako-forma-przechowywania-danych",
    "href": "lectures/wyklad1.html#pliki-jako-forma-przechowywania-danych",
    "title": "Od pliku do bazy danych",
    "section": "3ï¸âƒ£ Pliki jako forma przechowywania danych",
    "text": "3ï¸âƒ£ Pliki jako forma przechowywania danych\nZanim powstaÅ‚y systemy baz danych, dane przechowywano w prostych plikach tekstowych.\nNa przykÅ‚ad w pliku CSV:\nID,ImiÄ™,Nazwisko,Miasto\n1,Anna,Nowak,KrakÃ³w\n2,Jan,Kowalski,Warszawa\n3,Piotr,WiÅ›niewski,PoznaÅ„\nChoÄ‡ taki plik moÅ¼na Å‚atwo otworzyÄ‡ w Excelu, ma on liczne ograniczenia:\n\nbrak kontroli poprawnoÅ›ci danych,\nbrak powiÄ…zaÅ„ miÄ™dzy plikami,\nbrak wspÃ³Å‚bieÅ¼noÅ›ci przy edycji.\n\n\n## 4ï¸âƒ£ Problemy pracy z plikami\nSystem plikowy dziaÅ‚a poprawnie przy niewielkiej liczbie danych i prostych zastosowaniach. Wraz ze wzrostem iloÅ›ci informacji i liczbÄ… uÅ¼ytkownikÃ³w pojawiajÄ… siÄ™ jednak powaÅ¼ne ograniczenia, ktÃ³re utrudniajÄ… bezpieczne i efektywne zarzÄ…dzanie danymi.\n\nâš ï¸ Typowe problemy\n\n\n\n\n\n\n\nProblem\nOpis\n\n\n\n\nğŸ” Redundancja\nTe same dane pojawiajÄ… siÄ™ w wielu miejscach (np. adres klienta powielony w kaÅ¼dym zamÃ³wieniu).\n\n\nâš ï¸ NiespÃ³jnoÅ›Ä‡\nRÃ³Å¼ne wersje tej samej informacji w rÃ³Å¼nych plikach (np. inny numer telefonu u klienta w dwÃ³ch plikach).\n\n\nâ›” Brak wspÃ³Å‚bieÅ¼noÅ›ci\nTrudnoÅ›ci przy jednoczesnej edycji â€” ryzyko nadpisania zmian.\n\n\nâŒ Brak kontroli dostÄ™pu\nBrak rÃ³l, uprawnieÅ„ i mechanizmÃ³w audytu.\n\n\nğŸ§© SÅ‚aba integracja\nDane rozproszone po rÃ³Å¼nych formatach i miejscach, trudne do poÅ‚Ä…czenia.\n\n\n\n\n Schemat: system plikÃ³w z wieloma niespÃ³jnymi plikami vs.Â centralna baza danych\n\n\nPrzykÅ‚ad (plikowy):\nklienci.txt:\n1;Anna Nowak;KrakÃ³w\n2;Jan Kowalski;Warszawa\nzamowienia.txt:\n10;Laptop;1\n11;Monitor;2\n12;Kabel HDMI;1\nDziaÅ‚a to, ale jeÅ›li zmienimy ID klienta lub nazwÄ™ produktu, powstaje trudnoÅ›Ä‡ w utrzymaniu spÃ³jnoÅ›ci.",
    "crumbs": [
      "KsiÄ…Å¼ki",
      "WykÅ‚ady",
      "Od pliku do bazy danych"
    ]
  },
  {
    "objectID": "lectures/wyklad1.html#od-pliku-do-bazy-danych",
    "href": "lectures/wyklad1.html#od-pliku-do-bazy-danych",
    "title": "Od pliku do bazy danych",
    "section": "5ï¸âƒ£ Od pliku do bazy danych",
    "text": "5ï¸âƒ£ Od pliku do bazy danych\nAby rozwiÄ…zaÄ‡ problemy zwiÄ…zane z plikami pÅ‚askimi, wprowadzono koncepcjÄ™ systemu zarzÄ…dzania bazÄ… danych (DBMS). GÅ‚Ã³wne idee to:\n\ncentralne repozytorium danych,\nkontrolowany dostÄ™p i uprawnienia,\nmechanizmy zapewniajÄ…ce spÃ³jnoÅ›Ä‡ i integralnoÅ›Ä‡,\nobsÅ‚uga wspÃ³Å‚bieÅ¼noÅ›ci i transakcji,\nmoÅ¼liwoÅ›Ä‡ zapytaÅ„ (np. SQL) zamiast peÅ‚nego skanowania plikÃ³w.\n\n\nPorÃ³wnanie: plik CSV vs baza danych (SQL)\n\n\n\n\n\n\n\n\nCecha\nPlik CSV\nBaza danych (SQL)\n\n\n\n\nStruktura danych\nTekstowa, dowolna\nÅšciÅ›le zdefiniowana (kolumny, typy)\n\n\nSpÃ³jnoÅ›Ä‡ danych\nNie\nZapewniana przez DBMS\n\n\nWspÃ³Å‚bieÅ¼noÅ›Ä‡\nBrak\nObsÅ‚ugiwana\n\n\nWyszukiwanie\nPeÅ‚ne skanowanie\nZapytania, indeksy\n\n\nBezpieczeÅ„stwo\nBrak\nKontrola dostÄ™pu\n\n\n\n\n Diagram: â€Od pliku do bazyâ€ â€“ ewolucja sposobu przechowywania danych",
    "crumbs": [
      "KsiÄ…Å¼ki",
      "WykÅ‚ady",
      "Od pliku do bazy danych"
    ]
  },
  {
    "objectID": "lectures/wyklad1.html#rÃ³Å¼nice-w-przetwarzaniu-danych-przykÅ‚ad-porÃ³wnawczy",
    "href": "lectures/wyklad1.html#rÃ³Å¼nice-w-przetwarzaniu-danych-przykÅ‚ad-porÃ³wnawczy",
    "title": "Od pliku do bazy danych",
    "section": "6ï¸âƒ£ RÃ³Å¼nice w przetwarzaniu danych â€“ przykÅ‚ad porÃ³wnawczy",
    "text": "6ï¸âƒ£ RÃ³Å¼nice w przetwarzaniu danych â€“ przykÅ‚ad porÃ³wnawczy\nRodzaj przetwarzania zaleÅ¼y od typu danych:\n\n\n\n\n\n\n\n\n\nTyp danych\nPrzykÅ‚ad\nNarzÄ™dzie przetwarzania\nTypowe operacje\n\n\n\n\nTabelaryczne\nsprzedaÅ¼, klienci\nSQL, Excel\nsortowanie, sumowanie, filtracja\n\n\nTekstowe\nartykuÅ‚y, maile\nwyszukiwanie peÅ‚notekstowe\nindeksowanie, analiza sÅ‚Ã³w\n\n\nObraz\nzdjÄ™cia, wideo\nbiblioteki CV, AI\nklasyfikacja, rozpoznawanie obiektÃ³w\n\n\nDÅºwiÄ™k\nnagrania, mowa\nDSP, ML\nfiltracja, transkrypcja\n\n\n\n\nPytanie do dyskusji: Dlaczego dane tabelaryczne Å‚atwo ujÄ…Ä‡ w relacje, a dÅºwiÄ™k czy obraz â€” juÅ¼ nie?\n\n\n Ilustracja: porÃ³wnanie przetwarzania danych tabelarycznych i multimedialnych",
    "crumbs": [
      "KsiÄ…Å¼ki",
      "WykÅ‚ady",
      "Od pliku do bazy danych"
    ]
  },
  {
    "objectID": "lectures/wyklad1.html#architektura-systemÃ³w-baz-danych-ansisparc",
    "href": "lectures/wyklad1.html#architektura-systemÃ³w-baz-danych-ansisparc",
    "title": "Od pliku do bazy danych",
    "section": "7ï¸âƒ£ Architektura systemÃ³w baz danych (ANSI/SPARC)",
    "text": "7ï¸âƒ£ Architektura systemÃ³w baz danych (ANSI/SPARC)\nAby osiÄ…gnÄ…Ä‡ niezaleÅ¼noÅ›Ä‡ danych od aplikacji, wprowadzono model trÃ³jwarstwowy ANSI/SPARC:\n\n\n\n\n\n\n\n\nPoziom\nOpis\nPrzykÅ‚ad\n\n\n\n\nZewnÄ™trzny\nWidok uÅ¼ytkownika â€” sposÃ³b, w jaki konkretni uÅ¼ytkownicy widzÄ… dane\nWidok â€Studenci z kierunku Informatykaâ€\n\n\nLogiczny (koncepcyjny)\nGlobalna struktura danych â€” tabele, relacje, ograniczenia\nSchemat bazy uczelni\n\n\nWewnÄ™trzny (fizyczny)\nFizyczne przechowywanie danych na dysku\nIndeksy, pliki danych, metody dostÄ™pu\n\n\n\n\n Schemat trÃ³jwarstwowy ANSI/SPARC: uÅ¼ytkownicy â†”ï¸ DBMS â†”ï¸ fizyczne dane\n\nKorzyÅ›ci:\n\nniezaleÅ¼noÅ›Ä‡ logiczna danych (zmiana schematu logicznego nie musi wymagaÄ‡ zmian w aplikacjach),\nniezaleÅ¼noÅ›Ä‡ fizyczna danych (zmiana sposobu przechowywania nie wpÅ‚ywa na logikÄ™ aplikacji).",
    "crumbs": [
      "KsiÄ…Å¼ki",
      "WykÅ‚ady",
      "Od pliku do bazy danych"
    ]
  },
  {
    "objectID": "lectures/wyklad1.html#typy-baz-danych",
    "href": "lectures/wyklad1.html#typy-baz-danych",
    "title": "Od pliku do bazy danych",
    "section": "8ï¸âƒ£ Typy baz danych",
    "text": "8ï¸âƒ£ Typy baz danych\nW zaleÅ¼noÅ›ci od modelu danych i sposobu ich uÅ¼ycia wyrÃ³Å¼niamy kilka typÃ³w baz:\n\n\n\n\n\n\n\n\nTyp bazy\nOpis\nPrzykÅ‚ad\n\n\n\n\nHierarchiczna\nDane uÅ‚oÅ¼one w strukturÄ™ drzewa\nIMS (IBM)\n\n\nSieciowa\nRekordy poÅ‚Ä…czone sÄ… w zÅ‚oÅ¼one grafy\nIDMS\n\n\nRelacyjna\nDane w tabelach, zwiÄ…zki przez klucze\nPostgreSQL, MySQL\n\n\nObiektowa\nDane jako obiekty z metodami\nObjectDB\n\n\nDokumentowa (NoSQL)\nDane w formacie dokumentÃ³w (JSON)\nMongoDB, CouchDB\n\n\nGrafowa\nModele relacji jako wÄ™zÅ‚y i krawÄ™dzie\nNeo4j\n\n\n\n\n Grafika: schematy â€” drzewo, sieÄ‡, tabela, graf\n\nUwaga: Model relacyjny jest najpowszechniej stosowany z uwagi na prostotÄ™ i solidne podstawy teoretyczne (algebra relacji).",
    "crumbs": [
      "KsiÄ…Å¼ki",
      "WykÅ‚ady",
      "Od pliku do bazy danych"
    ]
  },
  {
    "objectID": "lectures/wyklad1.html#historia-i-ewolucja-baz-danych",
    "href": "lectures/wyklad1.html#historia-i-ewolucja-baz-danych",
    "title": "Od pliku do bazy danych",
    "section": "9ï¸âƒ£ Historia i ewolucja baz danych",
    "text": "9ï¸âƒ£ Historia i ewolucja baz danych\nKrÃ³tka oÅ› czasu najwaÅ¼niejszych etapÃ³w:\n\nSystemy plikowe (lata 50â€“60) â€” proste pliki, brak centralnej kontroli.\n\nPierwsze DBMS (lata 60â€“70) â€” centralizacja, lepsze zarzÄ…dzanie danymi.\n\nModele hierarchiczne i sieciowe â€” stosowane w duÅ¼ych organizacjach, lecz trudne w utrzymaniu.\n\nModel relacyjny (E. F. Codd, 1970) â€” rewolucja: tabele, relacje i algebra relacji.\n\nSQL i standaryzacja â€” jÄ™zyk pozwalajÄ…cy na zdefiniowanie i manipulacjÄ™ danymi.\n\nNoSQL i chmura (XXI wiek) â€” elastycznoÅ›Ä‡, skalowalnoÅ›Ä‡, nowe modele danych.\n\n\n OÅ› czasu: rozwÃ³j baz danych od plikÃ³w do NoSQL i rozwiÄ…zaÅ„ chmurowych",
    "crumbs": [
      "KsiÄ…Å¼ki",
      "WykÅ‚ady",
      "Od pliku do bazy danych"
    ]
  },
  {
    "objectID": "lectures/wyklad1.html#zalety-podejÅ›cia-relacyjnego",
    "href": "lectures/wyklad1.html#zalety-podejÅ›cia-relacyjnego",
    "title": "Od pliku do bazy danych",
    "section": "ğŸ”Ÿ Zalety podejÅ›cia relacyjnego",
    "text": "ğŸ”Ÿ Zalety podejÅ›cia relacyjnego\n\nredukcja redundancji poprzez normalizacjÄ™ i klucze,\n\nÅ‚atwoÅ›Ä‡ Å‚Ä…czenia danych (JOINy),\n\nkontrola integralnoÅ›ci (ograniczenia, klucze obce),\n\nmechanizmy bezpieczeÅ„stwa i wielodostÄ™pnoÅ›ci,\n\nprzewidywalnoÅ›Ä‡ i zgodnoÅ›Ä‡ z formalnymi podstawami matematycznymi.\n\n\n Schemat relacji miÄ™dzy tabelami: STUDENT â†’ ZAPISY â†’ KURS",
    "crumbs": [
      "KsiÄ…Å¼ki",
      "WykÅ‚ady",
      "Od pliku do bazy danych"
    ]
  },
  {
    "objectID": "lectures/wyklad1.html#wprowadzenie-do-jÄ™zyka-sql",
    "href": "lectures/wyklad1.html#wprowadzenie-do-jÄ™zyka-sql",
    "title": "Od pliku do bazy danych",
    "section": "1ï¸âƒ£1ï¸âƒ£ Wprowadzenie do jÄ™zyka SQL",
    "text": "1ï¸âƒ£1ï¸âƒ£ Wprowadzenie do jÄ™zyka SQL\nSQL (Structured Query Language) to standardowy jÄ™zyk do komunikacji z relacyjnymi bazami danych. Dzieli siÄ™ na kilka czÄ™Å›ci:\n\nDDL (Data Definition Language) â€” definiowanie struktur (CREATE, ALTER, DROP),\n\nDML (Data Manipulation Language) â€” operacje na danych (SELECT, INSERT, UPDATE, DELETE),\n\nDCL (Data Control Language) â€” kontrola dostÄ™pu (GRANT, REVOKE),\n\nTCL (Transaction Control Language) â€” kontrola transakcji (COMMIT, ROLLBACK).",
    "crumbs": [
      "KsiÄ…Å¼ki",
      "WykÅ‚ady",
      "Od pliku do bazy danych"
    ]
  },
  {
    "objectID": "lectures/wyklad5.html",
    "href": "lectures/wyklad5.html",
    "title": "Mechanizmy zapewniania spÃ³jnoÅ›ci danych i wprowadzenie do widokÃ³w",
    "section": "",
    "text": "Transakcja to logiczna jednostka pracy w bazie danych, skÅ‚adajÄ…ca siÄ™ z jednej lub wielu operacji (INSERT, UPDATE, DELETE, itp.), ktÃ³re powinny byÄ‡ wykonane caÅ‚oÅ›ciowo.\nTransakcja to zbiÃ³r operacji, ktÃ³re albo wszystkie siÄ™ powiodÄ…, albo Å¼adna â€“ nie ma stanu poÅ›redniego.\nPrzykÅ‚ad:\nBEGIN;\nUPDATE Konta SET Saldo = Saldo - 100 WHERE NrKonta = 101;\nUPDATE Konta SET Saldo = Saldo + 100 WHERE NrKonta = 202;\nCOMMIT;\nâ¡ï¸ JeÅ›li obie aktualizacje siÄ™ powiodÄ… â€“ zmiany zostanÄ… zatwierdzone (COMMIT).\nâ¡ï¸ JeÅ›li jedna z operacji siÄ™ nie uda â€“ baza moÅ¼e przywrÃ³ciÄ‡ stan sprzed transakcji (ROLLBACK).\n\n\n\n\nBEGIN / START TRANSACTION â€“ rozpoczÄ™cie transakcji,\nCOMMIT â€“ zatwierdzenie zmian,\nROLLBACK â€“ cofniÄ™cie zmian do stanu poczÄ…tkowego,\nSAVEPOINT â€“ ustawienie punktu czÄ™Å›ciowego cofniÄ™cia.\n\nBEGIN;\nINSERT INTO Studenci VALUES (1001, 'Anna', 'Nowak', 22);\nSAVEPOINT p1;\nUPDATE Studenci SET Wiek = 23 WHERE NrIndeksu = 1001;\nROLLBACK TO SAVEPOINT p1;\nCOMMIT;\nâ¡ï¸ Zmieniono wiek Anny, ale cofniÄ™to tylko ostatniÄ… operacjÄ™ (ROLLBACK TO p1).\nâ¡ï¸ Wstawienie rekordu pozostaÅ‚o",
    "crumbs": [
      "KsiÄ…Å¼ki",
      "WykÅ‚ady",
      "Mechanizmy zapewniania spÃ³jnoÅ›ci danych i wprowadzenie do widokÃ³w"
    ]
  },
  {
    "objectID": "lectures/wyklad5.html#transakcje-i-ich-wÅ‚aÅ›ciwoÅ›ci-acid",
    "href": "lectures/wyklad5.html#transakcje-i-ich-wÅ‚aÅ›ciwoÅ›ci-acid",
    "title": "Mechanizmy zapewniania spÃ³jnoÅ›ci danych i wprowadzenie do widokÃ³w",
    "section": "",
    "text": "Transakcja to logiczna jednostka pracy w bazie danych, skÅ‚adajÄ…ca siÄ™ z jednej lub wielu operacji (INSERT, UPDATE, DELETE, itp.), ktÃ³re powinny byÄ‡ wykonane caÅ‚oÅ›ciowo.\nTransakcja to zbiÃ³r operacji, ktÃ³re albo wszystkie siÄ™ powiodÄ…, albo Å¼adna â€“ nie ma stanu poÅ›redniego.\nPrzykÅ‚ad:\nBEGIN;\nUPDATE Konta SET Saldo = Saldo - 100 WHERE NrKonta = 101;\nUPDATE Konta SET Saldo = Saldo + 100 WHERE NrKonta = 202;\nCOMMIT;\nâ¡ï¸ JeÅ›li obie aktualizacje siÄ™ powiodÄ… â€“ zmiany zostanÄ… zatwierdzone (COMMIT).\nâ¡ï¸ JeÅ›li jedna z operacji siÄ™ nie uda â€“ baza moÅ¼e przywrÃ³ciÄ‡ stan sprzed transakcji (ROLLBACK).\n\n\n\n\nBEGIN / START TRANSACTION â€“ rozpoczÄ™cie transakcji,\nCOMMIT â€“ zatwierdzenie zmian,\nROLLBACK â€“ cofniÄ™cie zmian do stanu poczÄ…tkowego,\nSAVEPOINT â€“ ustawienie punktu czÄ™Å›ciowego cofniÄ™cia.\n\nBEGIN;\nINSERT INTO Studenci VALUES (1001, 'Anna', 'Nowak', 22);\nSAVEPOINT p1;\nUPDATE Studenci SET Wiek = 23 WHERE NrIndeksu = 1001;\nROLLBACK TO SAVEPOINT p1;\nCOMMIT;\nâ¡ï¸ Zmieniono wiek Anny, ale cofniÄ™to tylko ostatniÄ… operacjÄ™ (ROLLBACK TO p1).\nâ¡ï¸ Wstawienie rekordu pozostaÅ‚o",
    "crumbs": [
      "KsiÄ…Å¼ki",
      "WykÅ‚ady",
      "Mechanizmy zapewniania spÃ³jnoÅ›ci danych i wprowadzenie do widokÃ³w"
    ]
  },
  {
    "objectID": "lectures/wyklad5.html#wspÃ³Å‚bieÅ¼noÅ›Ä‡-i-problemy-spÃ³jnoÅ›ci",
    "href": "lectures/wyklad5.html#wspÃ³Å‚bieÅ¼noÅ›Ä‡-i-problemy-spÃ³jnoÅ›ci",
    "title": "Mechanizmy zapewniania spÃ³jnoÅ›ci danych i wprowadzenie do widokÃ³w",
    "section": "2ï¸âƒ£ WspÃ³Å‚bieÅ¼noÅ›Ä‡ i problemy spÃ³jnoÅ›ci",
    "text": "2ï¸âƒ£ WspÃ³Å‚bieÅ¼noÅ›Ä‡ i problemy spÃ³jnoÅ›ci\n\nğŸ”¹ Co to jest wspÃ³Å‚bieÅ¼noÅ›Ä‡?\nWspÃ³Å‚bieÅ¼noÅ›Ä‡ (ang. concurrency) to sytuacja, gdy wiele transakcji wykonuje siÄ™ jednoczeÅ›nie na tej samej bazie danych.\nDziÄ™ki wspÃ³Å‚bieÅ¼noÅ›ci baza moÅ¼e obsÅ‚ugiwaÄ‡ wielu uÅ¼ytkownikÃ³w naraz, aleâ€¦\nâ¡ï¸ moÅ¼e dojÅ›Ä‡ do konfliktÃ³w, jeÅ›li transakcje modyfikujÄ… te same dane.\n\n\nğŸ”¹ PrzykÅ‚ad konfliktu wspÃ³Å‚bieÅ¼noÅ›ci\nTransakcja 1\nBEGIN;\nUPDATE Konto SET Saldo = Saldo - 500 WHERE ID = 1;\nTransakcja 2\nBEGIN;\nUPDATE Konto SET Saldo = Saldo - 300 WHERE ID = 1;\nObie modyfikujÄ… ten sam rekord. JeÅ›li system nie zapewni izolacji â€” saldo koÅ„cowe moÅ¼e byÄ‡ bÅ‚Ä™dne.",
    "crumbs": [
      "KsiÄ…Å¼ki",
      "WykÅ‚ady",
      "Mechanizmy zapewniania spÃ³jnoÅ›ci danych i wprowadzenie do widokÃ³w"
    ]
  },
  {
    "objectID": "lectures/wyklad5.html#poziomy-izolacji-transakcji",
    "href": "lectures/wyklad5.html#poziomy-izolacji-transakcji",
    "title": "Mechanizmy zapewniania spÃ³jnoÅ›ci danych i wprowadzenie do widokÃ³w",
    "section": "3ï¸âƒ£ Poziomy izolacji transakcji",
    "text": "3ï¸âƒ£ Poziomy izolacji transakcji\nBazy danych zapewniajÄ… rÃ³Å¼ne poziomy izolacji, ktÃ³re rÃ³wnowaÅ¼Ä… spÃ³jnoÅ›Ä‡ danych i wydajnoÅ›Ä‡.\n\nğŸ”¹ PrzykÅ‚ad w PostgreSQL:\nBEGIN TRANSACTION ISOLATION LEVEL REPEATABLE READ;\nSELECT * FROM Zamowienia WHERE KlientID = 10;\n-- Inna transakcja modyfikuje dane\nSELECT * FROM Zamowienia WHERE KlientID = 10;\nCOMMIT;\nâ¡ï¸ Na poziomie REPEATABLE READ oba SELECT-y zobaczÄ… ten sam zestaw danych, nawet jeÅ›li inna transakcja je zmieniÅ‚a w miÄ™dzyczasie.",
    "crumbs": [
      "KsiÄ…Å¼ki",
      "WykÅ‚ady",
      "Mechanizmy zapewniania spÃ³jnoÅ›ci danych i wprowadzenie do widokÃ³w"
    ]
  },
  {
    "objectID": "lectures/wyklad5.html#podzapytanie-w-klauzuli-where-jednowartoÅ›ciowe",
    "href": "lectures/wyklad5.html#podzapytanie-w-klauzuli-where-jednowartoÅ›ciowe",
    "title": "Mechanizmy zapewniania spÃ³jnoÅ›ci danych i wprowadzenie do widokÃ³w",
    "section": "ğŸ”¹ 1. Podzapytanie w klauzuli WHERE (jednowartoÅ›ciowe)",
    "text": "ğŸ”¹ 1. Podzapytanie w klauzuli WHERE (jednowartoÅ›ciowe)\nTo najczÄ™stszy typ podzapytania.\nZapytanie gÅ‚Ã³wne wybiera dane na podstawie wartoÅ›ci zwrÃ³conej przez podzapytanie.\n\nğŸ§© PrzykÅ‚ad:\nZnajdÅº ksiÄ…Å¼ki napisane przez autora o nazwisku Sienkiewicz.\nSELECT tytul, rok\nFROM Ksiazki\nWHERE autor_id = (\n    SELECT autor_id\n    FROM Autorzy\n    WHERE nazwisko = 'Sienkiewicz'\n);\n\n\nğŸ“˜ Opis dziaÅ‚ania:\n\nPodzapytanie wewnÄ™trzne szuka identyfikatora autora autor_id, ktÃ³rego nazwisko to Sienkiewicz.\nZapytanie gÅ‚Ã³wne wybiera z tabeli Ksiazki tylko te rekordy, w ktÃ³rych autor_id jest rÃ³wny wynikowi podzapytania.\n\n\nğŸ”¸ Takie podzapytanie musi zwrÃ³ciÄ‡ jednÄ… wartoÅ›Ä‡ (scalar subquery) â€“ w przeciwnym razie wystÄ…pi bÅ‚Ä…d.",
    "crumbs": [
      "KsiÄ…Å¼ki",
      "WykÅ‚ady",
      "Mechanizmy zapewniania spÃ³jnoÅ›ci danych i wprowadzenie do widokÃ³w"
    ]
  },
  {
    "objectID": "lectures/wyklad5.html#podzapytanie-zwracajÄ…ce-wiele-wartoÅ›ci-operator-in",
    "href": "lectures/wyklad5.html#podzapytanie-zwracajÄ…ce-wiele-wartoÅ›ci-operator-in",
    "title": "Mechanizmy zapewniania spÃ³jnoÅ›ci danych i wprowadzenie do widokÃ³w",
    "section": "ğŸ”¹ 2. Podzapytanie zwracajÄ…ce wiele wartoÅ›ci (operator IN)",
    "text": "ğŸ”¹ 2. Podzapytanie zwracajÄ…ce wiele wartoÅ›ci (operator IN)\nJeÅ›li podzapytanie zwraca wiÄ™cej niÅ¼ jeden rekord, uÅ¼ywamy operatora IN.\n\nğŸ§© PrzykÅ‚ad:\nZnajdÅº wszystkie ksiÄ…Å¼ki autorÃ³w, ktÃ³rych nazwiska zaczynajÄ… siÄ™ na literÄ™ M.\nSELECT tytul, rok\nFROM Ksiazki\nWHERE autor_id IN (\n    SELECT autor_id\n    FROM Autorzy\n    WHERE nazwisko LIKE 'M%'\n);\n\n\nğŸ“˜ Opis dziaÅ‚ania:\n\nPodzapytanie wewnÄ™trzne zwraca listÄ™ identyfikatorÃ³w autorÃ³w, np. [1, 5, 7].\nZapytanie gÅ‚Ã³wne wybiera ksiÄ…Å¼ki, ktÃ³rych autor_id znajduje siÄ™ na tej liÅ›cie.\n\n\nğŸ”¸ Operator IN moÅ¼na traktowaÄ‡ jak porÃ³wnanie z â€wieloma wartoÅ›ciami jednoczeÅ›nieâ€.",
    "crumbs": [
      "KsiÄ…Å¼ki",
      "WykÅ‚ady",
      "Mechanizmy zapewniania spÃ³jnoÅ›ci danych i wprowadzenie do widokÃ³w"
    ]
  },
  {
    "objectID": "lectures/wyklad5.html#podzapytanie-w-klauzuli-select",
    "href": "lectures/wyklad5.html#podzapytanie-w-klauzuli-select",
    "title": "Mechanizmy zapewniania spÃ³jnoÅ›ci danych i wprowadzenie do widokÃ³w",
    "section": "ğŸ”¹ 3. Podzapytanie w klauzuli SELECT",
    "text": "ğŸ”¹ 3. Podzapytanie w klauzuli SELECT\nPodzapytanie moÅ¼e teÅ¼ zwracaÄ‡ pojedynczÄ… wartoÅ›Ä‡ (skalarnÄ…) i byÄ‡ uÅ¼yte w liÅ›cie kolumn.\n\nğŸ§© PrzykÅ‚ad:\nWyÅ›wietl listÄ™ autorÃ³w wraz z liczbÄ… ich ksiÄ…Å¼ek.\nSELECT\n    a.imie,\n    a.nazwisko,\n    (\n        SELECT COUNT(*)\n        FROM Ksiazki k\n        WHERE k.autor_id = a.autor_id\n    ) AS liczba_ksiazek\nFROM Autorzy a;\n\n\nğŸ“˜ Opis dziaÅ‚ania:\n\nDla kaÅ¼dego autora (a.autor_id) wykonuje siÄ™ osobne podzapytanie, ktÃ³re liczy ksiÄ…Å¼ki przypisane do tego autora.\nWynik jest dodawany jako nowa kolumna liczba_ksiazek.\n\n\nğŸ”¸ To tzw. podzapytanie skorelowane (correlated subquery), poniewaÅ¼ odnosi siÄ™ do kolumny z zapytania gÅ‚Ã³wnego.",
    "crumbs": [
      "KsiÄ…Å¼ki",
      "WykÅ‚ady",
      "Mechanizmy zapewniania spÃ³jnoÅ›ci danych i wprowadzenie do widokÃ³w"
    ]
  },
  {
    "objectID": "lectures/wyklad5.html#podzapytanie-w-klauzuli-from-tabela-pochodna",
    "href": "lectures/wyklad5.html#podzapytanie-w-klauzuli-from-tabela-pochodna",
    "title": "Mechanizmy zapewniania spÃ³jnoÅ›ci danych i wprowadzenie do widokÃ³w",
    "section": "ğŸ”¹ 4. Podzapytanie w klauzuli FROM (tabela pochodna)",
    "text": "ğŸ”¹ 4. Podzapytanie w klauzuli FROM (tabela pochodna)\nPodzapytanie moÅ¼e tworzyÄ‡ tymczasowÄ… tabelÄ™ w sekcji FROM. Takie rozwiÄ…zanie nazywa siÄ™ derived table i pozwala na pracÄ™ z przetworzonymi danymi.\n\nğŸ§© PrzykÅ‚ad:\nPolicz Å›redni rok wydania ksiÄ…Å¼ek, a nastÄ™pnie wybierz te, ktÃ³re sÄ… starsze od Å›redniej.\nSELECT tytul, rok\nFROM (\n    SELECT *\n    FROM Ksiazki\n) AS K\nWHERE K.rok &lt; (\n    SELECT AVG(rok) FROM Ksiazki\n);\n\n\nğŸ“˜ Opis dziaÅ‚ania:\n\nPodzapytanie w FROM tworzy tymczasowÄ… tabelÄ™ K.\nW klauzuli WHERE uÅ¼ywamy innego podzapytania, ktÃ³re liczy Å›redni rok wydania.\nWynik to ksiÄ…Å¼ki starsze od Å›redniej publikacji.",
    "crumbs": [
      "KsiÄ…Å¼ki",
      "WykÅ‚ady",
      "Mechanizmy zapewniania spÃ³jnoÅ›ci danych i wprowadzenie do widokÃ³w"
    ]
  },
  {
    "objectID": "lectures/wyklad5.html#korelowane-podzapytanie-correlated-subquery",
    "href": "lectures/wyklad5.html#korelowane-podzapytanie-correlated-subquery",
    "title": "Mechanizmy zapewniania spÃ³jnoÅ›ci danych i wprowadzenie do widokÃ³w",
    "section": "ğŸ”¹ 5. Korelowane podzapytanie (correlated subquery)",
    "text": "ğŸ”¹ 5. Korelowane podzapytanie (correlated subquery)\nTo podzapytanie, ktÃ³re odwoÅ‚uje siÄ™ do kolumn z zapytania gÅ‚Ã³wnego. Wykonuje siÄ™ dla kaÅ¼dego wiersza osobno â€“ dlatego bywa wolniejsze, ale bardzo elastyczne.\n\nğŸ§© PrzykÅ‚ad:\nZnajdÅº najstarszÄ… ksiÄ…Å¼kÄ™ kaÅ¼dego autora.\nSELECT k.tytul, k.rok, a.nazwisko\nFROM Ksiazki k\nJOIN Autorzy a ON k.autor_id = a.autor_id\nWHERE k.rok = (\n    SELECT MIN(rok)\n    FROM Ksiazki\n    WHERE autor_id = k.autor_id\n);\n\n\nğŸ“˜ Opis dziaÅ‚ania:\n\nDla kaÅ¼dego wiersza w tabeli Ksiazki podzapytanie szuka najmniejszego roku dla tego samego autora.\nPorÃ³wnanie k.rok = (MIN(rok)) sprawia, Å¼e zostaje tylko najstarsza ksiÄ…Å¼ka kaÅ¼dego autora.",
    "crumbs": [
      "KsiÄ…Å¼ki",
      "WykÅ‚ady",
      "Mechanizmy zapewniania spÃ³jnoÅ›ci danych i wprowadzenie do widokÃ³w"
    ]
  },
  {
    "objectID": "lectures/wyklad5.html#podzapytanie-z-exists",
    "href": "lectures/wyklad5.html#podzapytanie-z-exists",
    "title": "Mechanizmy zapewniania spÃ³jnoÅ›ci danych i wprowadzenie do widokÃ³w",
    "section": "ğŸ”¹ 6. Podzapytanie z EXISTS",
    "text": "ğŸ”¹ 6. Podzapytanie z EXISTS\nOperator EXISTS sprawdza, czy podzapytanie zwrÃ³ciÅ‚o jakiekolwiek wiersze. Nie liczy ich â€” interesuje nas jedynie, czy wynik istnieje (TRUE/FALSE).\n\nğŸ§© PrzykÅ‚ad:\nZnajdÅº autorÃ³w, ktÃ³rzy napisali przynajmniej jednÄ… ksiÄ…Å¼kÄ™.\nSELECT imie, nazwisko\nFROM Autorzy a\nWHERE EXISTS (\n    SELECT 1\n    FROM Ksiazki k\n    WHERE k.autor_id = a.autor_id\n);\n\n\nğŸ“˜ Opis dziaÅ‚ania:\n\nDla kaÅ¼dego autora sprawdzane jest, czy istnieje co najmniej jeden wiersz w tabeli Ksiazki z tym samym autor_id.\nJeÅ›li tak â€” warunek EXISTS zwraca TRUE, a autor pojawia siÄ™ w wyniku.",
    "crumbs": [
      "KsiÄ…Å¼ki",
      "WykÅ‚ady",
      "Mechanizmy zapewniania spÃ³jnoÅ›ci danych i wprowadzenie do widokÃ³w"
    ]
  },
  {
    "objectID": "lectures/wyklad5.html#porÃ³wnania-z-all-any",
    "href": "lectures/wyklad5.html#porÃ³wnania-z-all-any",
    "title": "Mechanizmy zapewniania spÃ³jnoÅ›ci danych i wprowadzenie do widokÃ³w",
    "section": "ğŸ”¹ 7. PorÃ³wnania z ALL / ANY",
    "text": "ğŸ”¹ 7. PorÃ³wnania z ALL / ANY\nOperator ALL wymaga, aby warunek byÅ‚ speÅ‚niony dla wszystkich wynikÃ³w podzapytania. Operator ANY (lub SOME) â€“ aby warunek byÅ‚ speÅ‚niony dla przynajmniej jednego.\n\nğŸ§© PrzykÅ‚ad:\nZnajdÅº ksiÄ…Å¼ki wydane wczeÅ›niej niÅ¼ wszystkie ksiÄ…Å¼ki Prusa.\nSELECT tytul, rok\nFROM Ksiazki\nWHERE rok &lt; ALL (\n    SELECT rok\n    FROM Ksiazki\n    WHERE autor_id = (\n        SELECT autor_id FROM Autorzy WHERE nazwisko = 'Prus'\n    )\n);\n\n\nğŸ“˜ Opis dziaÅ‚ania:\n\nPodzapytanie wewnÄ™trzne zwraca lata publikacji ksiÄ…Å¼ek Prusa.\nZapytanie gÅ‚Ã³wne wybiera tylko te ksiÄ…Å¼ki, ktÃ³rych rok jest mniejszy niÅ¼ wszystkie te wartoÅ›ci.\n\n\n\nğŸ§® Podsumowanie typÃ³w podzapytaÅ„ w SQL\n\n\n\n\n\n\n\n\n\n\nTyp podzapytania\nMiejsce uÅ¼ycia\nZwracany wynik\nTypowe operatory\nPrzykÅ‚ad zastosowania\n\n\n\n\nJednowartoÅ›ciowe (scalar)\nWHERE, SELECT\nPojedyncza wartoÅ›Ä‡ (1 rekord, 1 kolumna)\n=, &lt;, &gt;\nAutor o nazwisku â€Sienkiewiczâ€\n\n\nWielowartoÅ›ciowe (multivalue)\nWHERE\nLista wartoÅ›ci (wiele rekordÃ³w)\nIN, NOT IN\nAutorzy, ktÃ³rych nazwisko zaczyna siÄ™ na â€Mâ€\n\n\nKorelowane (correlated)\nWHERE, SELECT\nZmienny wynik dla kaÅ¼dego wiersza\n=, EXISTS\nNajstarsza ksiÄ…Å¼ka danego autora\n\n\nZagnieÅ¼dÅ¼one w FROM (tabela pochodna)\nFROM\nZbiÃ³r wierszy (tymczasowa tabela)\nâ€”\nÅšredni rok wydania ksiÄ…Å¼ek i porÃ³wnanie ze Å›redniÄ…\n\n\nZ operatorem EXISTS / NOT EXISTS\nWHERE\nPrawda / FaÅ‚sz (czy istnieje wynik)\nEXISTS, NOT EXISTS\nAutorzy, ktÃ³rzy napisali przynajmniej jednÄ… ksiÄ…Å¼kÄ™\n\n\nZ operatorem ALL / ANY / SOME\nWHERE\nPorÃ³wnanie z wieloma wartoÅ›ciami\nALL, ANY, SOME\nKsiÄ…Å¼ki starsze niÅ¼ wszystkie ksiÄ…Å¼ki Prusa",
    "crumbs": [
      "KsiÄ…Å¼ki",
      "WykÅ‚ady",
      "Mechanizmy zapewniania spÃ³jnoÅ›ci danych i wprowadzenie do widokÃ³w"
    ]
  },
  {
    "objectID": "lectures/wyklad5.html#widoki-views",
    "href": "lectures/wyklad5.html#widoki-views",
    "title": "Mechanizmy zapewniania spÃ³jnoÅ›ci danych i wprowadzenie do widokÃ³w",
    "section": "4ï¸âƒ£ Widoki (Views)",
    "text": "4ï¸âƒ£ Widoki (Views)\n\nğŸ”¹ Czym jest widok?\nWidok (VIEW) to wirtualna tabela, ktÃ³ra prezentuje dane pochodzÄ…ce z jednej lub wielu tabel. Widok nie przechowuje danych samodzielnie â€“ zawsze opiera siÄ™ na zapytaniu SQL.\nPrzykÅ‚ad:\nCREATE VIEW StudenciPelnoletni AS\nSELECT Imie, Nazwisko, Wiek\nFROM Studenci\nWHERE Wiek &gt;= 18;\nâ¡ï¸ Teraz moÅ¼na uÅ¼yÄ‡ widoku jak zwykÅ‚ej tabeli:\nSELECT * FROM StudenciPelnoletni;\n\n\nğŸ”¹ Zalety widokÃ³w\n\nAbstrakcja danych â€“ uÅ¼ytkownik nie musi znaÄ‡ zÅ‚oÅ¼onej struktury tabel.\nBezpieczeÅ„stwo â€“ moÅ¼na ograniczyÄ‡ dostÄ™p do wraÅ¼liwych kolumn.\nReuÅ¼ywalnoÅ›Ä‡ â€“ skomplikowane zapytania moÅ¼na zapisaÄ‡ raz jako widok.\nIzolacja logiki â€“ zmiana struktury tabeli nie wymaga zmiany zapytaÅ„ uÅ¼ytkownikÃ³w.\n\n\n\nğŸ”¹ Widoki z ograniczeniami (WITH CHECK OPTION)\nJeÅ›li chcesz, aby przez widok moÅ¼na byÅ‚o wstawiaÄ‡ dane tylko zgodne z jego definicjÄ…, uÅ¼yj WITH CHECK OPTION.\nCREATE VIEW StudenciMlodsi AS\nSELECT * FROM Studenci\nWHERE Wiek &lt; 25\nWITH CHECK OPTION;\nâ¡ï¸ PrÃ³ba wstawienia studenta starszego niÅ¼ 25 lat zakoÅ„czy siÄ™ bÅ‚Ä™dem:\nINSERT INTO StudenciMlodsi VALUES (1234, 'Jan', 'Kowalski', 30);\n-- ERROR: nie speÅ‚nia warunku widoku\n\n\nğŸ”¹ Widoki w praktyce â€“ bezpieczeÅ„stwo danych\nPrzykÅ‚ad ograniczenia dostÄ™pu do poufnych danych:\nCREATE VIEW PracownicyPubliczni AS\nSELECT Imie, Nazwisko, Dzial\nFROM Pracownicy;\nUÅ¼ytkownicy mogÄ… zobaczyÄ‡ tylko dane dziaÅ‚owe, ale nie np. pensje.",
    "crumbs": [
      "KsiÄ…Å¼ki",
      "WykÅ‚ady",
      "Mechanizmy zapewniania spÃ³jnoÅ›ci danych i wprowadzenie do widokÃ³w"
    ]
  }
]